

### 19.删除链表的倒数第N个节点

```javascript
//双指针
var removeNthFromEnd = function(head, n) {
    let p1 = head, p2 = head;
    for(let i = 0; i < n; i++) p1 = p1.next;
    //注意这里，表示n为链表长度,不能返回null.next，所以遍历到<n
    if(p1 === null) return head.next;
    while(1){
        p1 = p1.next;
        if(p1 == null){
            p2.next = p2.next.next;
            return head;
        }
        p2 = p2.next;
    }
};
```

### 24.两两交换链表中的节点

```javascript
var swapPairs = function(head) {
	let sentinel = new ListNode();
    sentinel.next = head;
    let curr = sentinel;
    while(curr.next != null && curr.next.next != null){
        let temp1 = curr.next;//第一个节点
        let temp2 = curr.next.next;//第二个节点
        let temp3 = curr.next.next;//第三个节点
        curr.next = temp2;//curr为哨兵，让链表第一个节点为原链表第二个节点
        temp2.next = temp1;//原链表第二个节点指向原链表第一个节点
        temp1.next = temp3;//现链表第二个节点指向原链表第三个节点,至此完成交换
        curr = temp1;//更新curr到下一组要交换的第一个节点的前一个节点，即为一开始创建哨兵的意义
    }
    //返回哨兵的下一个，即交换后的链表的第一个节点
    return sentinel.next;
}
```

### 138.随机链表的复制

```javascript
var copyRandomList = function(head) {
    if(!head) return null;
    //第一步，在原链表的每一个节点后创建一个新的节点，值与其相同
    let p = head;
    while(p != null){
        let newNode = new Node(p.val,null,null);
        newNode.next = p.next.next;
        p.next = newNode;
        p = newNode.next;
    }
    //第二步，判断原链表节点的random指针是否为空，不为空为每一个新增节点创建与原节点相同的指向
    p = head;
    while(p){
        if(p.random){
            p.next.random = p.random.next;
        }
        p = p.next.next;
    }
    //第三步，拆分新旧节点链表
    p = head;
    let sentinel = new Node();//哨兵，为空，便于最后返回
    let curr = sentinel;
    curr.next = head;//指向头结点
    while(p){
        curr.next = p.next;//从空指向第一个新节点
        curr = curr.next;//到下一个新节点（即为上面刚指向的节点）
        p.next = curr.next;//改变就节点的指向，与新节点断开，指向旧结点
        p = p.next;//到下一个旧节点（即为上面刚指向的节点）
    }
    return sentinel.next;
}
```

### 148.排序链表

==归并排序==

```javascript
var sortList = function(head) {
    if(!head || !head.next) return head;//如果链表只有1个元素，直接返回
    let slow = head, fast = head.next;//如果为2个节点，fast=head会无法分割
    //因为如果fast = head,2个节点时while会执行,slow走了一步，导致无法分割
    while(fast && fast.next){
        slow = slow.next;
        fast = fast.fast;//快慢指针分割链表
    }
    //定义分开的链表右半部分的起点
    let temp = new ListNode();
    temp = slow.next;
    //递归分割左边部分
    let left = new ListNode();
    left = sortList(head);
    //递归分割右半部分
    let right = new ListNode();
    right = sortList(temp);
    
    //定义哨兵，用来返回排序后的新链表
    let sentitel = new ListNode();
    let curr = sentitel;
    //按大小添加到新链表中
    while(left && right){
        if(left.val < right.val){
            curr.next = left;
            left = left.next;
        }else{
            curr.next = right;
           	right = right.next;
        }
        curr = curr.next;
    }
    curr.next = left != null ? left : right;
    return sentinel.next;
};
```

==快排====+数组==

```javascript
var sortList = function (head) {
    let arr = [];
    //添加到数组中
    while(head){
        arr.push(head);
        head = head.next;
    }
    //升序排列
    arr.sort((a,b) = > a.val - b.val);
    //从前往后连接指针
    head = arr[0];
    //注意循环条件要为<=,这样刚好给链表尾指向空
    //而且如果链表长度为1则直接指空，为空不执行循环，返回判断进行返回null
    for(let i = 1; i <= arr.length; i++){
        head.next = arr[i] ? arr[i] : null;
        head = head.next;
    }
    return arr[0] ? arr[0] : null;
}
```

### 二叉树的中序遍历

```javascript
var inorderTraversal = function(root) {
    const arr = [];
	const inOrder = (root) => {
        if(!root) return;
        inOrder(root.left);
        arr.push(root.val);
        inOrder(root.right);
    }
    inOrder(root);
    return arr;
}
```

### 翻转二叉树

```javascript
var inverTree(root){
    if(!root) return null;
    let left = invertTree(root.left);
    let right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
}
```

### 102.二叉树的层序遍历

`````javascript
var levelOrder = function(root) {
    //声名存放结果的数组
    const arr = [];
    if(!root) return arr;//如果空树，返回空数组
    let arr2 = [];
    arr2.push(root);//用来存放树每一层节点的数组
    while(arr2.length !== 0){//树不为空
        arr.push([]);//返回结果是二维数组，代表每一层，添加当前层，再对当前层节点值进行添加
        let n = arr2.length;//树当前层当前长度
        for(let i = 0; i < n; i++){//遍历当前层节点值，数量即为arr2中数组长度
            let node = arr2.shift();//取出数组中节点
            arr[arr.length-1].push(node.val);//对当前层结果进行添加
            //当前层节点的下一层节点
            if(node.left) arr2.push(node.left);
            if(node.right) arr2.push(node.right);
        }
    }
    return arr;
}
整体思路:
采用队列的思想，对当前层节点入队，循环中出队，然后向结果中添加值，同时对下一层节点入队
队列为空时即树遍历完成
`````

### 108.将有序数组转化为二叉搜索树

`````javascript
var sortedArrayToBST = function(nums) {
    if(!nums.length) return null;
    const func = (nums,low,high) => {
        if(low > high) return null;
        //注意这里是加，取中间位置
        let mid = (high + low) >>> 1;//对2整除向下取整
        const root = new TreeNode();
        root.val = nums[mid];
        root.left = func(nums, low, mid-1);
        root.right = func(nums, mid+1, high);
        return root;
	}
    return func(nums,0,nums.length-1);
}
`````

### 98.验证二叉搜索树

```javascript
思路：逐层传值，在下一层节点进行比较，如果不符合返回假，同时如果遍历到根部了，即为空，则返回true
var isValidBST = function(root) {
    const helper=(root,lower,upper)=>{
        if(!root) return true;
        //划定一个区间，当前节点大于左边小于右边，不符合则为假
        if(root.val <= lower || root.val >= upper) return false;
        //
        return helper(root.left, lower, root.val) && helper(root.right, root.val, upper);
    }
    return helper(root,-Infinity, Infinity);
}
```

### 230.二叉搜索树中第K小的元素

```javascript
思路，遍历二叉树添加到数组，取已排序的数组中k-1位的元素即为第k小
小细节：利用二叉搜索树性质进行递归添加即自动排序
var kthSmallest = function(root, k) {
    const arr = [];
    let dfs = function(root){
        if(!root) return;
        //小细节，利用短路特性，如果left为空，则不再递归调用，防止空指针异常同时优化效率
        root.left && dfs(root.left);
        arr.push(root.val);
        root.right && dfs(root.right);
    }
    return arr[k-1];
}
```

### 199.二叉树的右视图

```javascript
思路：
第一种自己做的：对右子树进行调用，值加到数组中，没有在调用左子树，但是会有一个问题，如果左子树比右子树高就会造成结果不正确
第二种自己做的：层序遍历，再将二维数组中的每个数组最右边的值加到结果数组中

题解思路：辅助函数多接收一个参数deep，deep==结果数组长度就添加节点值到结果
var rightSideView = function(root) {
    const res = [];
    const dfs = function(root,deep){
        if(!root) return;
        if(res.length === deep) res.push(root.val);
        dfs(root.right,deep+1);
        dfs(root.left,deep+1);
    }
    dfs(root,0);
    return res;
}
```

### 114.二叉树转化为链表

```javascript
思路：先序遍历，将节点存到数组，然后依次进行连接和赋值
var flatten = function(root) {
    const res = [];
    const helper = function(root){
        if(!root) return;
        res.push(root);
        helper(root.left);
        helper(root.right);
    } 
    helper(root);
    const head = res[0];
    for(let i = 0; i < res.length - 1; i++){
        res[i].left = null;
        res[i].right = res[i+1];
    }
    return head;
}
```

### 105.从前序与中序遍历序列构造二叉树

```javascript
//思路，先序遍历的第一个节点即为根节点，中序遍历根据根节点位置确认左右子树
//依次递归遍历，为空返回null
var buildTree = function(preorder, inorder) {
    if(preorder.length === 0) return null;
    const newVal = preorder[0];
    const root = new TreeNode(newVal);
    let i = 0;
    for(; i < inorder.length; i++){
        if(newVal === inorder[i]) break;
    }
    root.left = buildTree(preorder.slice(1,i+1),inorder.slice(0,i));
    //注意这里为什么是i+1,js的slice函数返回从包含当前索引值下标往后的其余元素（下标从0开始）
    //递归的是右子树，所以要+1
    root.right = buildTree(preorder.slice(i+1),inorder.slice(i+1));
    return root;
}
```

### 437.路径总和|||

```javascript
var pathSum = function(root, targetSum) {
	const perfix = new Map();
    perfix.set(0,1);
        /*初始化：在开始遍历树之前，我们需要一个初始值来表示路径的前缀和为 0。这是因为在从根节点到某个节点的路径上，如果从根节点出发，没有任何节点，则路径的前缀和为 0。
    第一个节点：考虑第一个节点的情况，如果第一个节点的值恰好等于目标和 targetSum，那么这个节点本身就可以构成一条路径。而这个节点到根节点的路径的前缀和为 0，因此我们需要将前缀和为 0 的出现次数初始化为 1，以确保能够正确地计算出路径的数量。所以，在开始遍历树之前，我们将前缀和为 0 的出现次数设为 1，以确保算法能够正确地处理路径的情况。*/
};
const dfs = function(root,perfix,curr,targetSum){
    if(!root) return 0;
    let ret = 0;//用于存储从当前节点开始的满足路径总和等于目标和的路径数
    curr += root.val;//累加前缀和
	
    ret += perfix.get(curr - targetSum) || 0;//判断有没有满足的前缀和
    perfix.set(curr,(perfix.get(curr - targetSum) || 0) + 1);//向map添加当前值的前缀和
    ret += dfs(root.left,perfix,curr,targetSum);
    ret += dfs(root.right,perfix,curr,targetSum);
    perfix.set(curr,perfix.get(curr - 1);
//将 perfix.set(curr,(perfix.get(curr) || 0) - 1); 放到末尾的目的是在当前节点的递归处理结束后，及时将当前前缀和 curr 的出现次数减 1。这样可以保证在回溯到父节点时，前缀和 Map 中记录的信息是正确的，不会影响到父节点及其后续的处理。
//具体来说，这行代码的执行时机在于当前节点的递归处理结束后，即当前节点的左右子树都已经递归处理完毕，返回到了当前节点的父节点。在这个时候，我们需要将当前节点的前缀和从前缀和 Map 中去除，以确保下一次遇到同样的前缀和时，能够得到正确的计数
    return ret;
}
```

### 236.二叉树的最近公共祖先

题解：[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&envId=top-100-liked)

```javascript
思路：向下找，如果找到了子节点，返回子节点，
	如果子节点都找到了返回当前root,
    如果左边有右边没有，返回左边，右边有左边没有，返回右边，
	都没有返回空
var lowestCommonAncestor = function(root, p, q) {
    if(!root || root == p || root == q) return root;
    
    let left = new TreeNode();
    left = lowestCommonAncestor(root.left,p,q);
    
    let right = new TreeNode();
    right = lowestCommonAncestor(root.right,p,q);
    
    if(!left && !root) return null;
    if(!left) return right;
    if(!right) return left;
    
    return root;
    
}
```

### 200.岛屿数量

详细题解：[200. 岛屿数量 - 力扣（r）](https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?envType=study-plan-v2&envId=top-100-liked)

```javascript
var numIslands = function(grid) {
  let landNum = 0;
  for(let i = 0; i < grid.length; i++){
      for(let j = 0; j < grid[0].length; j++){
          if(grid[i][j] == 1){
              landNum++;
              dfs(grid, i, j);
          }
      }
  }
    return landNum;
};
const inArea(grid, r, c){//判断是否在矩阵区域内
    //注意这里，与循环中的i 和 j相对应
    return r >=0 && r < grid.length && c >=0 && c <grid[0].length;
};
const dfs = (grid, r, c) => {
    if(!inArea(grid, r, c)) return;
    if(gird[r][c] != 1) return;//判断是否为岛屿
    
    grid[r][c] = 2;//标记已经到达过的岛屿避免后续重复死循环
    //进行递归遍历
    dfs(grid, r-1, c);
   	dfs(grid, r+1, c);
    dfs(grid, r, c-1);
    dfs(grid, r, c+1);
}
```

### 994.腐烂的橘子

```javascript
思路：
遍历矩阵，将腐烂橘子所在位置的坐标[i,j]添加到队列中，同时记录新鲜橘子数量
初始化轮数为0，循环遍历，条件为新鲜橘子数量>0且队列（队列内为腐烂橘子坐标）不为空
内循环遍历将当前队列大小范围的队列内腐烂橘子依次出队，同时对腐烂橘子的上下左右进行Infect
最后进行返回，如果新鲜橘子数量>0说明有橘子无法被感染到，返回-1，否则返回轮数
var orangesRotting = function(grid) {
    let M = grid.length;
    let N = grid[0].length;
    let count = 0;//新鲜橘子数
    let queue = [];//存放腐烂橘子左坐标的队列
    for(let i = 0; i < M; i++){
        for(let j = 0; j < N; j++){
            if(grid[i][j] == 1) count++;
            if(grid[i][j] == 2) queue.push([i,j]);
        }
    }
    let round = 0;//感染轮数
    while(count > 0 && queue.length){
        round++;
        const len = queue.length;//当前队列长度
        for(let i = 0; i < len; i++){
			let orange = queue.shift();//队列内烂橘子二维坐标
            let r = orange[0];//横坐标
            let c = orange[1];//纵坐标
            if(r-1 >= 0 && grid[r-1][c] == 1){//烂橘子的上方
                grid[r-1][c] = 2;//标记为烂橘子
                count--;//新鲜橘子数量
                queue.push([r-1,c]);//添加新的烂橘子到队列
            }
            if(r+1 < M && grid[r+1][c] == 1){//下方
                grid[r+1][c] = 2;
                count--;
                queue.push([r+1,c]);
            }
            if(c-1 >= 0 && grid[r][c-1] == 1){//左方
                grid[r][c-1] = 2;
                count--;
                queue.push([r,c-1]);
            }
            if(c+1 < N && grid[r][c+1] == 1){//右方
                grid[r][c+1] = 2;
                count--;
                queue.push([r,c+1]);
            }
        }
    }
    if(count > 0 ) return -1;
    return round;
}
```

### 207.课程表

```javascript
思路：
创建入度数组填充为0，存放对应索引值位置的入度
创建邻接表存储对应的键值，需要先修的课程为建，依赖于它的课程为值
将所有入度为0的元素入列，即为没有依赖先修课程的课程
将队列中不依赖先修的课程出列，匹配map中所对应的依赖于这些课程的后续课程，对他们的入度--
如果入度为0了，则将其加入到队列中
最后返回课程数与出队的课程数是否相等，相等则说明可以修完
var canFinish = function (numCourses, prerequisites) {
    const inDegree = new Array(numCourses).fill(0);//入度数组
    const map = {};//邻接表，有先修的课程的课为键，需要依赖它作为先修的课程为值
    //初始化入度数组和邻接表
    for(let i = 0; i < prerequisites.length; i++){
        inDegree[prerequisites[i][0]]++;//有前置先修课程的课程
        if(map[prerequisites[i][1]]){//没有先修的课程的课为键，需要依赖它作为先修的课程为值
            map[prerequisites[i][1]].push([prerequisites[i][0]]);
        }else{
            map[prerequisites[i][1]] = [prerequisites[i][0]];
        }
    }
    //将所有不需要先修课程的课入队
    const queue = [];
    for(let i = 0; i < inDegree.length; i++){
        if(inDegree[i] == 0) queue.push(i);
    }
    let count = 0;//已上的课程数
    while(queue.length){
		const selected = queue.shift();//出队
        count++;
        const toEnQueue = map[selected];//选择依赖它的课程的课
        if(toEnQueue && toEnQueue.length){//判断是否存在依赖它的课，
            //即使不存在，count也已经++，所以也会统计进课程数
            for(let i = 0; i < toEnQueue.length; i++){
                inDegree[toEnQueue[i]]--;//依赖于它的后续课的入度--
                if(inDegree[toEnQueue[i]] == 0){
                    queue.push(toEnQueue[i]);
                }
            }
        }
    }
    return count == numCourses;
}
重点在于搞清楚map,toEnqueue,inDegree,selected之间的关系
```

### 208.实现Trie(前缀树)

[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/98390/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/?envType=study-plan-v2&envId=top-100-liked)

1. **构造函数 `Trie`**：

   - 构造函数初始化了一个 Trie 树的根节点，该节点没有值，但有一个名为 `children` 的空对象，用于存储子节点。

2. **`insert` 方法**：

   - 参数：`word`，要插入到 Trie 中的字符串。
   - 插入操作从 Trie 的根节点开始，依次遍历字符串的每个字符，如果字符对应的节点不存在，则在 `children` 对象中创建该字符的节点，然后进入下一层节点。
   - 当遍历完成后，将最后一个字符所在的节点标记为单词的结束，即将 `isEnd` 属性设置为 `true`。

3. **`search` 方法**：

   - 参数：`word`，要搜索的字符串。
   - 搜索操作从 Trie 的根节点开始，依次遍历字符串的每个字符，在遍历过程中，如果遇到字符对应的节点不存在，则返回 `false`。
   - 如果遍历完成后，最后一个字符所在的节点存在且标记为单词的结束（即 `isEnd` 属性为 `true`），则返回 `true`，否则返回 `false`。

4. **`startsWith` 方法**：

   - 参数：`prefix`，要搜索的前缀字符串。
   - 这个方法与 `search` 方法类似，不同之处在于，它不要求最后一个字符所在的节点必须是单词的结束，只要能够匹配到相应的前缀即可。
   - 返回值为布尔值，表示 Trie 中是否存在以给定前缀开头的单词。

5. **`searchPrefix` 方法**（未公开，仅用于内部）：

   - 参数：`prefix`，要搜索的前缀字符串。

   - 这个方法与 `startsWith` 方法实现类似，不同之处在于，它返回的是匹配到的前缀的最后一个字符所在的节点，而不是布尔值。

   - 如果 Trie 中存在以给定前缀开头的单词，返回匹配到的前缀的最后一个字符所在的节点；如果不存在，则返回 `false`。

   - ```javascript
     var Trie = function() {
         this.children = {};
     };
     
     /** 
      * @param {string} word
      * @return {void}
      */
     Trie.prototype.insert = function(word) {
         let node = this.children;
         for(const ch of word){
             if(!node[ch]){
                 node[ch] = {};
             }
             node = node[ch];
         }
         node.isEnd = true;
     };
     
     /** 
      * @param {string} word
      * @return {boolean}
      */
     Trie.prototype.search = function(word) {
         const node = this.searchPrefix(word);
         return node !== undefined && node.isEnd !== undefined;
     };
     
     /** 
      * @param {string} prefix
      * @return {boolean}
      */
     Trie.prototype.startsWith = function(prefix) {
         return this.searchPrefix(prefix);
     };
     Trie.prototype.searchPrefix = function(prefix) {
         let node = this.children;
         for(const ch of prefix){
             if(!node[ch]) return false;
             node = node[ch];
         }
         return node;
     }
     ```

### 46.全排列

~~~java
 ```javascript
 一直困惑的一个点就是回溯后也都是为false不是会重复吗
 但是回溯之后回到循环进行弹栈和置为false，接着进行的是下一轮循环，下标不一样
 对应的值就不一样了，等于说数组元素都进行回溯了一遍，所以是不会重复的
 var permute = function(nums) {
     const res = [], path = [];
   	function backtracking(n, k, used){
         if(path.length == k){
             res.push(Array.from(path));
             return;
         }
         for(let i = 0; i < k; i++){
             if(used[i]) continue;
             path.push(n[i]);
             used[i] = true;
             backtracking(n, k, used);
             path.pop();
             used[i] = false;
         }
     }
 }
 ```
~~~

### 78.子集

~~~java
 ```javascript
 思路:basecase为index长度等于数组长度,说明已经完成遍历越界了,此时将结果加到答案数组中返回
 当前索引位置加到临时数组中后回溯,回溯后弹出回溯位置添加的值,随后再次回溯,即可跳过所在位置,遍历到全部的可能性
 var subsets = function(nums){
     const res = [];
     function backtrack(index,arr){
         if(index == nums.length){
             res.push(arr.slice());//slice的作用是返回数组内容的浅拷贝,且不改变原数组
             return;
         }
         arr.push(nums[index]);
         backtrack(index+1, arr);
         arr.pop();
         backtrack(index+1, arr);
     }
     backtrack(0, []);
     return res;
 }
 ```
~~~

### 17.电话号码的字母组合



~~~java
 ```javascript
 思路:
 创建map字母表
 创建回溯函数,接收一个表示当前长度和当前字符的参数
 basecase:当字符串长度为要求的字符长度+1时,将字符串push到结果中,然后return,进行回溯
 currStr是深拷贝,不为引用,所以返回之后就回到前面的值了
 同时通过i进行控制字母组合,如difits='23',第一次进入回溯函数i=0,对应digits[i]即为map中2对应的字母,
 随后对回溯进行递归传参为i+1,即为与后面的组合,如此通过循环找出所有可能
 var letterCombinations = function (digits) {
     if(digits.length == 0) return [];
     const res = [];
     const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', 
     '7': 'pqrs', '8': 'tuv', '9': 'wxyz' };
     function dfs(i, currStr) {
         if (i > digits.length - 1) {
             res.push(currStr);
             return;
         }
         const letters = map[digits[i]];
         for (const letter of letters) {
             dfs(i + 1, currStr + letter);
         }
     };
     dfs(0, '');
     return res;
 };
 ```
~~~

### 39.组合总和

~~~java
 ```javascript
 思路:将目标数比作根节点,对于数组中每一个元素,是第一层分支,如target-7,arr=[2,3,6,7]
 对于2,则在后续节点中如果能凑成5,则加到结果数组,即target逐层减小,如果为0则将路径中的元素加到结果数组中
 对于如何保障结果集内元素不重复,dfs的参数中的begin来控制,基于begin位置开始找,不能往前,则不会重复
 对于优化,将数组排序,如果target减去当前索引位置元素小于0,直接break
 var combinationSum = function (candidates, target) {
     const res = [];
     const len = candidates.length;
     if(len < 1) return res;
     const path = [];
     dfs(0, path, target, len);
     return res;
     
     function dfs(begin, path, target, len){
         if(target == 0){
             res.push(Array.from(path));
             return;
         }
         for(let i = begin; i < len; i++){
             if(target - candidates[i] < 0) break;
             path.push(candidates[i]);
             dfs(i, path, target-candidates[i], len);
             path.pop();
 		}
     }
 }
 ```
~~~

### 22.括号生成

~~~java
 ```javascript
 思路:
 对左右括号计数,左右括号都为n则正好成对添加到结果
 如果当前暂存的结果中右括号大于左括号,一定不会成对,return
 如果左括号数小于n,递归遍历左括号+1
 如果右括号数小于n,递归遍历右括号+1
 var generateParenthesis = function(n) {
     const res = [];
     dfs(0, 0, '', n);
     return res;
     
     function dfs(left, right, currStr, n){
         if(left == n && right == n){
             res.push(currStr);
             return;
         }
         if(left < right) return;
         if(left < n) {
             dfs(left+1, right, currStr + '(', n);
         }
         if(right < n){
             dfs(left, right+1, currStr + ')', n);
         }
         
     }
 }
 
 ```
~~~

### 79.单词搜索

```javascript
思路:对矩阵每个位置的字母进行回溯
basecase:坐标超出矩阵有效范围,或者当前位置字符与目标字符不同,return false;
相同返回true,只有当下标位置索引值为目标单词长度-1的时候才返回true,即可正确进行判断
同时对执行过的矩阵位置标空,避免重复访问,对当前位置的上下左右进行递归,
回溯将置空的位置复原,
    最后返回结果.
var exist = function(board, word) {
    for(let i = 0; i < board.length; i++){
		for(let j = 0; j < board[0].length; j++){
			if(dfs(i,j,0)) return true;	
        }
    }
    return false;
    function dfs(i, j, k){
        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length 
           || word[k] !== board[i][j]) return false;
        if(k == word.length-1) return true;
        board[i][j] = '';//置空避免重复访问
        //对相邻位置进行递归
        let res = dfs(i+1,j,k+1) || dfs(i,j+1,k+1) || dfs(i-1,j,k+1) || dfs(i,j-1,k+1);
        //回溯,状态重置
        board[i][j] = word[k];
        return res;
    }
}
```

### 131.分割回文串

```javascript
var isPalindrome = function (s, left, right) {
    while(left < right){
        if(s.charAt(left++) !== s.charAt(right--)) return false;
    }
    return true;
}
var partition = function(s) {
    const res = [], path = [];
    const n = s.length;
    dfs(0);
    return res;
    function dfs(i){
        if(i === n){
            res.push(path.slice());
            //path.slice() 方法用于创建一个新的数组，其中包含 path 数组的所有元素。这个新数组是 path 数组的一个浅拷贝，
            // 也就是说，它包含的是 path 数组中的相同的元素，而不是引用。
            // 在这段代码中，ans.push(path.slice()) 的作用是将当前的 path 数组内容添加到 ans 数组中。
            // 由于 slice() 方法返回一个新的数组，这样可以避免在后续的操作中改变 path 数组的内容对 ans 数组造成影响。
            // 这样做是为了保持回溯过程中 path 数组的状态，确保每个回文子串都被正确保存在 ans 数组中。
            return;
        }
        for(let j = i; j < n; j++){
            if(isPalindrome(s, i, j)){//只有是回文才有必要加进数组
                path.push(s.substring(i, j+1));
                //path 数组存储的是子串而不是单个字符。当我们发现一个回文子串时，我们希望将这个回文子串加入到 path 中，
                // 而不是将它的每个字符单独加入。
                // substring 方法用于从原始字符串中提取子串，而 push 方法用于将提取的子串加入到数组中。
                // 因此，当我们发现一个回文子串时，使用 s.substring(i, j+1) 将该子串提取出来，
                // 并将整个子串加入到 path 数组中。这样做可以保留回文串的完整性，方便后续的操作和处理。
                dfs(j+1);
                path.pop();//回溯,重置状态
            }
        }
    }
}
```

### 35.搜索插入位置

```javascript
var searchInsert = function(nums, target) {
    let i = 0;
    let j = nums.length - 1;

    function search(i, j) {
        if(i > j) return i;
        let mid = (i + j) >>> 1;
        if(target > nums[mid]) return search(mid+1, j);
        if(target == nums[mid]) return mid;
        if(target < nums[mid]) return search(i, mid-1); 
    }

    return search(i, j);
};
```

### 74.搜索二维矩阵

```javascript
思路:将矩阵抽象成一颗树,右上角为树根
如果树根小于target,树根下移一行,如果树根大于target,树根左移一行
注意点在搞清楚坐标判定有效性,以及树根变更位置时具体变量的操作(搞清楚对应的横纵坐标)
var searchMatrix = function (matrix, target) {
    let x = 0;
    let y = matrix[0].length - 1;
    while (check(x, y) && matrix[x][y] !== target){
        if(target > matrix[x][y]){
            x++;
        } else{
            y--;
        }

    }
    return check(x, y) && matrix[x][y] === target;
    function check(x, y){
        return x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length;
    }
}
```

### 34.在排序数组中查找元素的第一个和最后一个位置

```javascript
思路:二分查找确定中间位置
向前和后进行遍历,找到最前和最后的出现位置,因为数组有序,如果大于或小于目标break;
同时二分查找中,如果等于目标值,直接break;防止后面出现所在位置就是最前/后元素,导致只找到一边
var searchRange = function(nums, target) {
    let l = 0, r = nums.length - 1;
    while(l < r){
        let mid = l + r >> 1;
        if(target > nums[mid]){
            l = mid + 1;
        }else{
            r = mid - 1;
        }
    }
    let first = '', end = '';
    for(let i = l; i < nums.length; i++){
        if(nums[i] === target) end = i;
        if(nums[i] > target) break;
    }
    for(let i = l; i >= 0; i--){
        if(nums[i] === target) first = i;
        if(nums[i] < target) break;
    }
    if(first === '' && end === '') return[-1,-1];
    if(first === '' && end !== '') return [end,end];
    if(first !== '' && end === '') return [first,first];
    return [first,end];
};

console.log(searchRange([1,2,2],2))
```

### 33.搜索旋转排序数组

```javascript
var searchRange = function(nums, target) {
    let l = 0;
    let r = nums.length - 1;
    while(l <= r){//l为len-1,所以<=
        let mid = l + r >>> 1;
        if(nums[mid] === target) return mid;
        //因为是从一个未知位置旋转的顺序数组,则将其二分一定有一段是有序的
        if(nums[l] <= nums[mid]){//说明l-mid是顺序区间
            (target >= nums[l] && target < nums[mid]) ? r = mid - 1 : l = mid + 1;
        }else{//说明mid-right是顺序区间
            (target > nums[mid] && target <= nums[r]) ? l = mid + 1 : r = mid - 1;
        }
    }
    return -1;
};
```

### 153.寻找旋转排序数组中的最小值

```javascript
如果中间的值大于右边, l = mid + 1
				else r = mid;

var findMin  = function(nums) {
    let l = 0;
    let r = nums.length - 1;
    while (l < r){
        let mid = (r + l) >> 1;
        if(nums[mid] > nums[r]){
            l = mid + 1;
        } else{
            r = mid;
        } 
    }
    return nums[r];
};
```

### 20.有效的括号

```javascript
思路:利用栈的特性来做,创建键为左括号值为右括号的字典
如果当前遍历字符在字典中,压栈,则可确定栈中都是左括号
如果不在字典中,即为右括号,则判断字典中键为栈顶元素的值是否为当前遍历字符,不符合则返回false
边界问题:如果栈空,弹栈会报错,因此，我们采用一个取巧方法给stack赋初值?,并在字典中建立?的索引,
当栈为空且字符为空右括号时,disc[stack.pop()]为'?',即可正确处理
若遍历完后栈中有左括号,则说明不完全成对,对此判断栈长度===1
var isValid = function(s) {
    let disc = {'{':'}', '(':')', '[':']', '?':'?'};
    let stack = ['?'];
    for(let c of s){
        if(disc[c]) stack.push(c);
        else if(disc[stack.pop()] !== c) return false;
    }
    return stack.length === 1;
}


```

### 155.最小栈

```javascript
思路:因为取最小值的时间复杂度要求O(1),所以需要一个辅助栈,栈顶存放当前栈中元素最小值
var MinStack = function() {
    this.x_stack = [];
    this.min_stack = [Infinity];
};

/**
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    this.x_stack.push(x);
    //js中数组下标为负数不报错,返回undefined,undefined在min中与任何数比较都是false,
    //这样就完成了首次比较的添加
    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length-1], x));
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.x_stack.pop();
    this.min_stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.x_stack[this.x_stack.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.min_stack[this.min_stack.length-1];
};

```

### 394.字符串解码

算法流程：

构建辅助栈 stack， 遍历字符串 s 中每个字符 c；
当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；
当 c 为字母时，在 res 尾部添加 c；
当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 000：
记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；
记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。
进入到新 [ 后，res 和 multi 重新记录。
当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:
last_res是上个 [ 到当前 [ 的字符串，例如 "3[a2[c]]" 中的 a；
cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 "3[a2[c]]" 中的 2。
返回字符串 res。
链接：https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/

```javascript

var decodeString = function(s) {
    const stack = [];
    let res = "", multi = 0;
    for (let i = 0; i < s.length; i++) {
        const c = s.charAt(i);
        if (c === '[') {
            stack.push([multi, res]);
            res = "", multi = 0;
        } else if (c === ']') {
            const [cur_multi, last_res] = stack.pop();
            res = last_res + res.repeat(cur_multi);
        } else if ('0' <= c && c <= '9') {
            multi = multi * 10 + parseInt(c);
/*parseInt(c) 用于将字符 c 转换为整数值。例如，如果 c 是 '3'，那么 parseInt(c) 将返回整数 3。
multi * 10 用于将之前计算得到的多位数的值向左移动一位，相当于在其个位数上增加一位的数字。
最后，将 parseInt(c) 得到的个位数加到 multi * 10 的结果上，从而构建出一个新的多位数。
这行代码的目的是处理可能由多个数字字符构成的数字，确保能够正确解析并构建这个数字。*/
        } else {
            res += c;
        }
    }
    return res;
};
let s = "3[a2[c]]"
console.log(decodeString(s));
```

### 739.每日温度

<video src="C:\Users\28018\Downloads\QQ2024322-131613.mp4"></video>

```javascript
var dailyTemperatures = function(temperatures) {
    const stack = [0];
    const res = new Array(temperatures.length).fill(0);
    for(let i = 1; i < temperatures.length; i++){
        //while循环,对应栈中有多个依次不递增的温度,出现一个大于他们温度的计算索引差值将他们弹出
		while(stack.length && temperatures[i] > temperatures[stack[stack.length-1]]){
            const idx = stack.pop();
            res[idx] = idx - i;
        }
        stack.push[i];
    }
}
```

### 215.数组中的第K个最大元素

快速排序的核心包括“哨兵划分” 和 “递归” 。

哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。
递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。
下图展示了数组 [2,4,1,0,3,5] 的快速排序流程。

![image-20240322195226612](F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240322195226612.png)

快速选择」：设 NNN 为数组长度。根据快速排序原理，如果某次哨兵划分后，基准数的索引正好是 N−kN-kN−k ，则意味着它就是第 kkk 大的数字 。此时就可以直接返回它，无需继续递归下去了。

然而，对于包含大量重复元素的数组，每轮的哨兵划分都可能将数组划分为长度为 111 和 n−1n-1n−1 的两个部分，这种情况下快速排序的时间复杂度会退化至 O(N2)O(N^2)O(N 
2
 ) 。

一种解决方案是使用「三路划分」，即每轮将数组划分为三个部分：小于、等于和大于基准数的所有元素。这样当发现第 k大数字处在“等于基准数”的子数组中时，便可以直接返回该元素。

为了进一步提升算法的稳健性，我们采用随机选择的方式来选定基准数。

```javascript
var findKthLargest = function(nums, k) {
    const quickSelect = (nums, k) => {
        // 随机选择基准数
        const pivot = nums[Math.floor(Math.random() * nums.length)];
        let big = [], equal = [], small = [];
        // 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中
        for (const num of nums) {
            if (num > pivot) {
                big.push(num);
            } else if (num < pivot) {
                small.push(num);
            } else {
                equal.push(num);
            }
        }
        if (k <= big.length) {
            // 第 k 大元素在 big 中，递归划分
            return quickSelect(big, k);
        }
        if (nums.length - small.length < k) {
            // 第 k 大元素在 small 中，递归划分
            return quickSelect(small, k - nums.length + small.length);
        }
        // 第 k 大元素在 equal 中，直接返回 pivot
        return pivot;
    };

    return quickSelect(nums, k);
};
```

### 347.前K个高频元素

```javascript
let topKFrequent = function(nums, k) {
    let map = new Map(), arr = [... new Set(nums)];
    nums.map((num) => {
        if(map.has(num)){
            map.set(num, map.get(num)+1);
        }else{
            map.set(num, 1);
        }
    });
    arr.sort((a, b) => map.get(b) - map.get(a));
    return arr.slice(0, k);
}
```

### 121.买卖股票的最佳时机

```javascript
思路:找到买入价格最低的股票进行记录,再依次记录当前出现的最大利润,即为当前价格减去当前最低价格
var maxProfit = function(prices) {
    let maxProfit = 0;
    let minPrice = Infinity;
    
    for(let price of prices){
        minPrice = Math.min(price, minPrice);
        maxProfit = Math.max(maxProfit, price - minPrice);
    }
    return maxProfit;
};
```

### 55.跳跃游戏

如果到达位置>=数组长度,那么一定会经过末尾

如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点
可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新
如果可以一直跳到最后，就成功了

```javascript
var canJump = function(nums) {
    let maxReach = 0;//最大到达距离
    for(let i = 0; i < nums.length; i++){//每个起跳点做一个尝试
        if(i > maxReach) return false;//说明当前位置是到达不了的,比如前面位置的值都为0
        maxReach = Math.max(maxReach, i+nums[i]);//更新最大到达距离
        if(maxReach >= nums.length-1) return true;//如果达到末尾
    }
    return false;
}
```



### 45.跳跃游戏2

<img src="F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240323074438757.png" alt="image-20240323074438757" style="zoom:50%;" />

```javascript
var jump = function(nums) {
    let maxReach = 0;
    let step = 0;
    let startIdx = 0;
    //i代表从哪个位置开始起跳，nums.length - 1是终点，没必要再跳了，再跳就出界了
    for(let i = 0; i < nums.length; i++){
		maxReach = Math.max(maxReach, i+nums[i]);
        if(i === startIdx){
            startIdx = maxReach;
            step++;
        }
    }
    return step;
}
```

### 763.划分字母区间

```javascript
思路:
创建一个存储每个字符最后出现位置的字典
依次遍历s中每个字符,比较他们的出现次数与第一个字符的出现位置进行比较,大于就更新最后的索引
当记录的索引与遍历字符串的当前索引i相同时,说明后面没有重复的字符了,加到结果中
var partitionLabels = function (s) {
    let disc = {};
    for (let i = 0; i < s.length; i++) {
        disc[s[i]] = i;
    }
    let num = 0;
    let j = disc[s[0]];
    let result = [];
    for (let i = 0; i < s.length; i++) {
        num++;
        if (disc[s[i]] > j) {
            j = disc[s[i]];
        }
        if (i === j) {
            result.push(num);
            num = 0;
        }
    }
    return result;
};
```

### 70.爬楼梯

```javascript
var climbStairs = function(n) {
    let dp = [];
    dp = [0,1,2,3,4];
    for(let i = 3; i <= n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}; 
```



### 118.杨辉三角

```javascript
思路:
1.:在当前层的第一位时,值为上一层的第一位
2.:在当前层最后一位,值为上一层的最后一位
3.:在当前层的中间(第1和最后一位之间),假设在j位,值为上一层的j+(j-1)位之和
var generate = function(numRows) {
    let arr = [[1]];
    for(let i = 1; i < numRows; i++){
        arr.push([]);
        for(let j = 0; j <= i; j++){
            if(j == 0) arr[i].push(arr[i-1][j]);
            else if (j == i) arr[i].push(arr[i-1][j-1]);
            else arr[i].push(arr[i-1][j-1] + arr[i-1][j]);
        }
    }
    return arr;
};
```

### 198.打家劫舍

```
输入：[1,2,3,1]
输出：4

dp[i]实际上的意思为对数组中i-1位置及之前的判断,因为数组长度到length,往后进行递推
比如dp[2] = MAX(dp[1], dp[0] + nums[1]),搞清楚dp和nums,dp数组不是nums下标,是递推的最大值
dp[0]是0,dp[1]是nums[1]
dp[2]进行的操作是对数组第一位和第二位做比较取最大
想清楚最根本的,就是下面的
dp[k - 1] 表示不偷取第 k 个房间时，偷取 [0, k-1) 房间中的最大金额。
nums[k - 1] + dp[k - 2] 表示偷取第 k 个房间时，偷取 [0, k-2) 房间中的最大金额加上第 k 个房间的价值。
```

```javascript
dp[k - 1] 表示不偷取第 k 个房间时，偷取 [0, k-1) 房间中的最大金额。
nums[k - 1] + dp[k - 2] 表示偷取第 k 个房间时，偷取 [0, k-2) 房间中的最大金额加上第 k 个房间的价值。
var rob = function (nums) {
    if(nums.length == 0) return 0;
    let dp = [0, nums[0]];
    for(let i = 2; i <= nums.length; i++){
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
    }
    return dp[nums.length];
}
```

### 279.完全平方数

```javascript
var numSquares = function(n) {
    let dp = new Array(n + 1).fill(0);
    for(let i = 1; i <= n; i++){
        dp[i] = i;//默认为i个数组合,即全为1
        for(let j = 1; i - j*j >= 0; j++){//保证是由完全平方数组合
            dp[i] = Math.min(dp[i], dp[i - j*j] + 1);
            //取最小次数的组合,每次取的结果都是前面算出来的,比如如果为4,那么j为2时,[i-j*j]=0
            //再加一,表示如果为4只用了1次组合
        }
    }
    return dp[n];
};
```

### 322.零钱兑换

```javascript
var coinChange = function(coins, amount) {
    let dp = new Array(amount+1).fill(Infinity);
    dp[0] = 0;
    for(let i = 1; i <= amount; i++){//对应钱的数额进行递推
        for(let j = 0; j < coins.length; j++){
            if(i >= coins[j])
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
        }
    }
    //dp初始为Infinity,判断coins是否能够组合成amount,如coins为0就不行
    return dp[amount] > amount ? -1 : dp[amount];
};
```

### 139.单词拆分

```javascript
通过不断的对i和j的区间进行移动进行字符串与字典比较来进行匹配,如果匹配到了就将匹配末尾的设置为true
然后基于匹配到的位置与字典继续移动区间来比较,如果成功匹配dp数组中s长度的位置就为true
var wordBreak = function(s, wordDict) {
    const n = s.length;
    let dp = new Array(s+1).fill(false);
    dp[0] = true;
    for(let i = 0; i < n; i++){
		for(let j = i + 1; j <= n; j++){
            if(dp[i] && wordDict.includes(s.slice(i, j))) dp[j] = true;
        }
    }
    return dp[n];
}
```

### 300.最长递增子序列

```javascript
var lengthOfLIS = function(nums) {
    const n = nums.length;
    let dp = new Array(n + 1).fill(1);//每一个元素都可视为1个长度的递增子序列
    let res = 0;
    for(let i = 0; i < n; i++){
        for(let j = 0; j < i; j++){
			if(nums[j] < nums[i]){//对当前字符之前的每一个字符进行遍历,如果小于当前字符
                //即将最大子串长度+1
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        //对结果进行更新
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

### 152.乘积最大子数组

```javascript
var maxProduct = function(nums) {
    let n = nums.length;
    if(n === 0) return 0;
    let dpMax = nums[0];
    let dpMin = nums[0];
    let max = nums[0];
    for(let i = 1; i < n; i++){
        let preMax = dpMax;
        dpMax = Math.max(dpMax * nums[i], nums[i], dpMin * nums[i]);
        dpMin = Math.min(nums[i], preMax * nums[i], dpMin * nums[i]);
        max = Math.max(dpMax, max);
    }
    return max;
};
```

1. 对于 `dpMax` 的更新：

   ```
   dpMax = Math.max(dpMin * nums[i], Math.max(dpMax * nums[i], nums[i]));
   ```

   这一行代码的作用是更新当前乘积的最大值 `dpMax`。

   - `dpMin * nums[i]` 表示将当前数字 `nums[i]` 与之前的最小乘积 `dpMin` 相乘，可能会得到新的最大乘积。
   - `dpMax * nums[i]` 表示将当前数字 `nums[i]` 与之前的最大乘积 `dpMax` 相乘，可能会得到新的最大乘积。
   - `nums[i]` 表示只取当前数字 `nums[i]` 本身，这种情况下，当前乘积即为 `nums[i]`。

   我们使用 `Math.max()` 来比较这三种情况中的最大值，并将其更新为当前乘积的最大值 `dpMax`。

2. 对于 `dpMin` 的更新：

   ```
   dpMin = Math.min(dpMin * nums[i], Math.min(preMax * nums[i], nums[i]));
   ```

   这一行代码的作用是更新当前乘积的最小值 `dpMin`。

   - `dpMin * nums[i]` 表示将当前数字 `nums[i]` 与之前的最小乘积 `dpMin` 相乘，可能会得到新的最小乘积。
   - `preMax * nums[i]` 表示将当前数字 `nums[i]` 与上一个状态的最大乘积 `preMax` 相乘，因为 `dpMin` 的更新需要依赖上一个状态的最大乘积。
   - `nums[i]` 表示只取当前数字 `nums[i]` 本身，这种情况下，当前乘积即为 `nums[i]`。

   我们使用 `Math.min()` 来比较这三种情况中的最小值，并将其更新为当前乘积的最小值 `dpMin`。

   题解:[152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/solutions/40745/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--36/)

### 416.分割等和子集

给 `dp[nums[0]]` 设置为 `true` 的目的是考虑到第一个元素 `nums[0]`，如果它的值小于等于目标和的一半 `target`，那么它可以单独作为一个子集，这样就能满足题目要求。

如果 `nums[0]` 小于等于 `target`，我们将 `dp[nums[0]]` 设置为 `true`，表示可以通过选择第一个元素得到和为 `nums[0]` 的子集。这种情况在后续的动态规划状态转移中会被考虑到，并对结果产生影响。

1. `let sum = 0; for (let num of nums) sum += num;`：计算数组 `nums` 的所有元素之和，并将结果保存在变量 `sum` 中。
2. `if (sum % 2) return false;`：检查数组元素之和是否为奇数，如果是奇数，则无法将其分割成两个和相等的子集，直接返回 `false`。
3. `let dp = new Array(nums.length + 1).fill(false); dp[0] = true;`：初始化一个长度为 `nums.length + 1` 的动态规划数组 `dp`，并将第一个元素 `dp[0]` 设置为 `true`，表示目标和为 `0` 可以达成。
4. `let target = sum / 2;`：计算目标和 `target`，即数组元素之和的一半，因为我们希望将数组分割成两个和相等的子集。
5. `if (nums[0] <= target) dp[nums[0]] = true;`：检查第一个数组元素 `nums[0]` 是否小于等于目标和 `target`，如果是，则将 `dp[nums[0]]` 设置为 `true`，表示存在一种分割方案使得和为 `nums[0]`。
6. `for (let i = 1; i < nums.length; i++) { for (let j = target; j >= nums[i]; j--) { ... } }`：双重循环遍历数组 `nums` 的所有元素，以及可能的目标和。内层循环从目标和开始递减，以便更新动态规划数组 `dp`。
7. `if (dp[target]) return true;`：在内层循环中，如果发现 `dp[target]` 已经为 `true`，表示已经找到一种分割方案使得和为 `target`，直接返回 `true`。
8. `dp[j] = dp[j] || dp[j - nums[i]];`：在内层循环中，更新动态规划数组 `dp`。如果当前元素 `nums[i]` 小于等于目标和 `j`，则判断是否可以使用当前元素 `nums[i]` 来达到目标和 `j`，如果可以，则将 `dp[j]` 设置为 `true`。
9. 最后，如果不存在满足条件的分割方案，返回 `dp[target]`，表示是否存在和为 `target` 的子集。
10. ``如果是奇数不可能被分为两部分``

```javascript
var canPartition = function (nums) {
    let sum = 0;
    for(let num of nums) sum += nums;
    if(sum % 2) return false;
    let taget = sum / 2;
    let dp = new Array(target + 1).fill(false);
    dp[0] = true;
    if(nums[0] <= target) nums[0] = true;
    for(let i = 1; i < nums.length; i++){
		for(let j = target; j >= nums[i]; j--){
			if(dp[target]) return true;
            dp[j] = dp[j] || dp[j - nums[i]];
        }
    }
}
```

### 62.不同路径

1. 外层循环 `for (int i = 1; i < m;i++)`：这个循环用于遍历从第二行到第 `m` 行的每一行，表示当前位置的行号。
2. 内层循环 `for (int j = 1; j < n; j++)`：这个循环用于遍历当前行的每个位置，表示当前位置的列号。
3. `cur[j] += cur[j-1]`：这行代码是动态规划的核心部分。它表示当前位置 `(i, j)` 的路径数量等于上一行同一位置 `(i-1, j)` 的路径数量 `cur[j]` 加上当前位置上一列 `(i, j-1)` 的路径数量 `cur[j-1]`。这是因为从起点 `(0, 0)` 到当前位置 `(i, j)` 的路径数量等于从起点到 `(i-1, j)` 的路径数量加上从起点到 `(i, j-1)` 的路径数量。
4. 通过不断更新 `cur[j]`，内层循环结束后，`cur[j]` 中保存的是当前行每个位置的路径数量。
5. 外层循环每执行一次，相当于计算了一行的路径数量。因此，外层循环结束后，`cur[n-1]` 中保存的是终点 `(m-1, n-1)` 的路径数量。

这种方法利用了动态规划的思想，通过不断累加上一行的路径数量来得到当前行的路径数量。在内层循环中，由于我们只需要上一行的路径数量信息，因此只需要使用一个一维数组 `cur`，而不需要使用二维数组。这样可以节省空间，并且提高了效率。

跟杨辉三角是一样的,第一行和第一列只有一条路所以都为1

```javascript
matrix[i][j] = matrix[i-1][j] + matrix[i][j-1],用一维数组更节省空间
```

```javascript
var uniquePaths = function(m, n) {
    let dp = new Array(n).fill(1);
    for(let i = 1; i < m; i++){
        for(let j = 1; j < n; j++){
            dp[j] += dp[j-1];
        }
    }
    return dp[n-1];
};
```

### 64.最小路径和

```javascript
题目要求，只能向右或向下走，换句话说，当前单元格 (i,j)(i,j)(i,j) 只能从左方单元格 (i−1,j)(i-1,j)(i−1,j) 或上方单元格 (i,j−1)(i,j-1)(i,j−1) 走到，因此只需要考虑矩阵左边界和上边界。

走到当前单元格 (i,j)(i,j)(i,j) 的最小路径和 === “从左方单元格 (i−1,j)(i-1,j)(i−1,j) 与 从上方单元格 (i,j−1)(i,j-1)(i,j−1) 走来的 两个最小路径和中较小的 ” +++ 当前单元格值 grid[i][j]grid[i][j]grid[i][j] 。具体分为以下 444 种情况：
当左边和上边都不是矩阵边界时： 即当i≠0i \not= 0i

=0, j≠0j \not= 0j

=0时，dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j] ；
当只有左边是矩阵边界时： 只能从上面来，即当i=0,j≠0i = 0, j \not= 0i=0,j

=0时， dp[i][j]=dp[i][j−1]+grid[i][j]dp[i][j] = dp[i][j - 1] + grid[i][j]dp[i][j]=dp[i][j−1]+grid[i][j] ；
当只有上边是矩阵边界时： 只能从左面来，即当i≠0,j=0i \not= 0, j = 0i

=0,j=0时， dp[i][j]=dp[i−1][j]+grid[i][j]dp[i][j] = dp[i - 1][j] + grid[i][j]dp[i][j]=dp[i−1][j]+grid[i][j] ；
当左边和上边都是矩阵边界时： 即当i=0,j=0i = 0, j = 0i=0,j=0时，其实就是起点， dp[i][j]=grid[i][j]dp[i][j] = grid[i][j]dp[i][j]=grid[i][j]；

初始状态：

dpdpdp 初始化即可，不需要修改初始 000 值。
返回值：

返回 dpdpdp 矩阵右下角值，即走到终点的最小路径和。
其实我们完全不需要建立 dpdpdp 矩阵浪费额外空间，直接遍历 grid[i][j]grid[i][j]grid[i][j] 修改即可。这是因为：grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] ；原 gridgridgrid 矩阵元素中被覆盖为 dpdpdp 元素后（都处于当前遍历点的左上方），不会再被使用到。

```

```javascript
var minPathSum = function(grid) {
    for(let i = 0; i < grid.length; i++){
        for(let j = 0; j < grid[0].length; j++){
            if(i === 0 && j === 0) continue;
            else if(i === 0) grid[i][j] += grid[i][j-1];
            else if(j === 0) grid[i][j] += grid[i-1][j];
            else grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);
        }
    }
    return grid[grid.length-1][grid[0].length-1]
};
```

### 5.最长回文子串

<img src="F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240324133231754.png" alt="image-20240324133231754" style="zoom:33%;" />

```javascript
var longestPalindrome = function(s) {
    if(s === null || s.length === 0) return "";
    let left = 0;//中心扩散左边界
    let right = 0;//中心扩散右边界
    let len = 1;//当前回文串长度
    let maxStart = 0;//最长回文的左边界下标
    let maxLen = 0;//最长回文长度

    for(let i = 0; i < s.length - (maxLen >> 1); i++){
        left = i - 1;
        right = i + 1;

        while(left >= 0 && s.charAt(left) === s.charAt(i)){
            left--;
            len++;
        }
        while(right < s.length && s.charAt(right) === s.charAt(i)){
            right++;
            len++;
        }
        while(left >= 0 && right < s.length && s.charAt(left) === s.charAt(right)){
            len += 2;
            left--;
            right++;
        }
        if(len > maxLen){
            maxLen = len;
            maxStart = left;
        }
        len = 1;
    }
    return s.substring(maxStart + 1, maxStart + maxLen + 1);
};
```

### 1143.最长公共子序列

```javascript
初始化变量：

M 和 N 表示分别表示 text1 和 text2 的长度。
创建一个大小为 (M + 1) x (N + 1) 的二维数组 dp。该数组将存储 text1 和 text2 子串的最长公共子序列的长度。
嵌套循环：

外部循环遍历 text1 的字符。
内部循环遍历 text2 的字符。
动态规划逻辑：

在每次迭代时，代码比较 text1 和 text2 的当前字符。
如果字符相等（text1.charAt(i - 1) == text2.charAt(j - 1)），则表示我们找到了两个字符串共同的一个新字符。在这种情况下，将最长公共子序列的长度增加 1，即加上不包含这些字符的子串的最长公共子序列的长度（dp[i - 1][j - 1]）。
如果字符不相等，则取两种情况的最大值：
排除 text1 的当前字符，考虑到达当前位置时 text2 的所有字符的最长公共子序列的长度（dp[i - 1][j]）。
排除 text2 的当前字符，考虑到达当前位置时 text1 的所有字符的最长公共子序列的长度（dp[i][j - 1]）。
将这个最大值存储在 dp 数组的当前单元格中。
完成循环后，返回 dp[M][N] 单元格的值，这就是 text1 和 text2 的最长公共子序列的长度。

这段代码采用了动态规划的方法，利用二维数组 dp 来存储子问题的解，通过不断更新这些解来得到最终的结果。

var longestCommonSubsequence = function (text1, text2) {
    let M = text1.length;
    let N = text2.length;
    let dp = new Array(M + 1).fill(0).map(() => new Array(N + 1).fill(0));
    for (let i = 1; i <= M; i++) {
        for (let j = 1; j <= N; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;//对应i,j的下标从1开始
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[M][N];
};
```

### 72.编辑距离

```javascript
讲一下我自己对状态转移方程的理解,麻烦大家看看我说得对不对有没有道理:
(一)、当word1[i]==word2[j]时,由于遍历到了i和j,说明word1的0~i-1和word2的0~j-1的匹配结果已经生成,
由于当前两个字符相同,因此无需做任何操作,dp[i][j]=dp[i-1][j-1]
(二)、当word1[i]!=word2[j]时,可以进行的操作有3个:
      ① 替换操作:可能word1的0~i-1位置与word2的0~j-1位置的字符都相同,
           只是当前位置的字符不匹配,进行替换操作后两者变得相同,
           所以此时dp[i][j]=dp[i-1][j-1]+1(这个加1代表执行替换操作)
      ②删除操作:若此时word1的0~i-1位置与word2的0~j位置已经匹配了,
         此时多出了word1的i位置字符,应把它删除掉,才能使此时word1的0~i(这个i是执行了删除操作后新的i)
         和word2的0~j位置匹配,因此此时dp[i][j]=dp[i-1][j]+1(这个加1代表执行删除操作)
      ③插入操作:若此时word1的0~i位置只是和word2的0~j-1位置匹配,
          此时只需要在原来的i位置后面插入一个和word2的j位置相同的字符使得
          此时的word1的0~i(这个i是执行了插入操作后新的i)和word2的0~j匹配得上,
          所以此时dp[i][j]=dp[i][j-1]+1(这个加1代表执行插入操作)
      ④由于题目所要求的是要最少的操作数:所以当word1[i] != word2[j] 时,
          需要在这三个操作中选取一个最小的值赋格当前的dp[i][j]

var minDistance = function(word1, word2) {
    let M = word1.length;
    let N = word2.length;
	let dp = new Array(M + 1).fill(0).map(()=> new Array(N + 1).fill(0));
    //搞清楚下面的M和N
    //第一行，是 word1 为空变成 word2 最少步数，就是插入操作
	//第一列，是 word2 为空，需要的最少步数，就是删除操作
    for(let i = 1; i <= N; i++) dp[0][i] = dp[0][i-1] + 1;//第一行,一共N列,所以N为边界
    
    for(let i = 1; i <= M; i++) dp[i][0] = dp[i-1][0] + 1;//第一列,一共M行
    
    for(let i = 1; i <= M; i++){
        for(let j = 1; j <= N; j++){
            if(word1.charAt(i-1) === word2.charAt(j-1)){
                dp[i][j] = dp[i-1][j-1];
            }else{
                dp[i][j] = Math.min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1);
            }
        }
    }
    return dp[M][N];
}
```

### 136.只出现一次的数字

`异或`

```javascript
var singleNumber = function(nums) {
    let result = 0;
    for(let num of nums) result ^= num;
    return result;
}
异或运算的一个重要特性是：任何数与0异或都等于本身，任何数与自身异或都等于0，且异或运算是可交换和结合的。
```

`Set`

`````javascript
var singleNumber = function(nums) {
    let set = new Set();
    for(let num of nums){
        if(set.has(num)){
            set.delete(num);
        }else{
            set.add(num);
        }
    }
    return [...set][0]
}
`````

### 169.多数元素

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

```javascript
投票算法
var majorityElement = function(nums) {
    let count = 0;
    let candidate = null;
    for(let num of nums){
        if(count === 0) candidate = num;
        count += (candidate === num ? 1 : -1);
    }
    return candidate;
}
```

### 49.字母异位词分组

```javascript
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    //new Object和new Object()和{}都是一样的
    const map = new Object;
    for(let str of strs){
        let arr = new Array(26).fill(0);
        for(let s of str){
            arr[s.charCodeAt() - 'a'.charCodeAt()]++;
        }
        //数组直接作为对象的键时会被转换为字符串形式（例如，数组 [1,2,3] 被转换为字符串 "1,2,3"），
        //这允许我们将拥有相同字符频率统计的字符串分组到同一个数组中。
        //如果键arr对应的数组尚不存在于映射对象map中，则初始化一个新数组，并将字符串str作为数组的首个元素。否则，将str追加到现有数组中。这一模式确保每个键都映射到一个数组，而不是单一值。
        map[arr] ? map[arr].push(str) : map[arr] = [str];
    }
    //Object.values(map) 从对象 map 中获取所有的值（即分组好的字符串数组）
    return Object.values(map);
};
```


在这行代码 `map[count] ? map[count].push(s) : map[count] = [s];` 中，使用`push(s)`而非`push([s])`的原因在于我们希望直接将字符串 `s` 添加到数组中，而不是添加一个包含字符串 `s` 的新数组。

`map[count]` 是一个数组，用来存储所有具有相同字符频率统计的字符串。如果用 `push([s])`，则每个字符串都会被封装成一个独立的数组再被添加到 `map[count]` 中，这会导致 `map[count]` 成为一个数组的数组（例如，`[['str1'], ['str2'], ...]`），这不符合题目的要求。题目要求的输出是将所有相同频率的字符串直接存储在同一个数组中（例如，`['str1', 'str2', ...]`）。

### 128.最长连续序列

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  const set = new Set();
  let longestStreak = 0;
  for (let i of nums) {//加入set,自动去重
    set.add(i);
  }
  for(let i of nums){
    if(!set.has(i - 1)){//没有比它小的,说明是起始数
      let n = i;
      let long = 1;
      while(set.has(n + 1)){//看最大连续长度
        n++;
        long++;
      }
      longestStreak = Math.max(longestStreak, long);//更新
    }
  }
  return longestStreak;
}
```

### 283.移动零

```javascript
var moveZeroes = function(nums) {
    let j = 0;
    for(let i = 0; i < nums.length; i++){
        if(nums[i] != 0){
            let tmp = nums[i];
            nums[i] = nums[j];
            nums[j++] = tmp;
        }
    }
};
```

![283_2.gif](assets/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

### 盛水最多的容器

设两指针 iii , jjj ，指向的水槽板高度分别为 h[i]h[i]h[i] , h[j]h[j]h[j] ，此状态下水槽面积为 S(i,j)S(i, j)S(i,j) 。由于可容纳水的高度由两板中的 短板 决定，因此可得如下 面积公式 ：

S(i,j)=min(h[i],h[j])×(j−i)S(i, j) = min(h[i], h[j]) × (j - i)
S(i,j)=min(h[i],h[j])×(j−i)

<img src="assets/1628780627-VtSmcP-Picture0.png" alt="Picture0.png" style="zoom:67%;" />

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1-1−1 变短：

若向内 移动短板 ，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 可能变大，因此下个水槽的面积 可能增大 。
若向内 移动长板 ，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 不变或变小，因此下个水槽的面积 一定变小 。
因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

算法流程：
初始化： 双指针 iii , jjj 分列水槽左右两端；
循环收窄： 直至双指针相遇时跳出；
更新面积最大值res ；
选定两板高度中的短板，向中间收窄一格；
返回值： 返回面积最大值 resresres 即可；



```javascript
var maxArea = function(height) {
    let l = 0;
    let r = height.length - 1;
    let area = 0;
    while(l < r){
        if(height[l] < height[r]){
            area = Math.max(area, height[l] * (r - l))
            l++
        } else {
            area = Math.max(area, height[r] * (r - l))
            r--
        }
    }
    return area;
};
```

### 三数之和

```javascript
var threeSum = function (nums) {
  if(!nums || nums.length < 3) return []
  let res = []
  let len = nums.length
  //a-b为升序,sort改变原数组
  nums.sort((a ,b) => a - b)
  for(let i = 0; i < nums.length; i++){
    if(nums[i] > 0) break
    let l = i + 1
    let r = len - 1
    if(i > 0 && nums[i] === nums[i - 1]) continue
    while(l < r){
      let sum = nums[i] + nums[l] + nums[r]
      if(sum === 0){
        res.push([nums[i], nums[l], nums[r]])
        while(l < r && nums[l] === nums[l + 1]) l++
        while(l < r && nums[r] === nums[r - 1]) r--
        l++
        r--
      }
      else if(sum > 0) r--
      else if(sum < 0) l++
    }
  }
  return res
};
console.log(threeSum([-1,0,1,2,-1,-4]))
```

if(i > 0 && nums[i] == nums[i - 1]) continue为什么加上这一句就可以去重了

是的，内部的`while`循环确实包含了去重的逻辑，但是这同外部的去重起着不同的作用。具体来说：

#### 内部`while`循环的去重

在内部`while`循环中，将指针移动到重复元素的最后一个元素之后，这是为了避免在给定的一次外层循环中（固定一个`nums[i]`），找到重复的组合。例如，如果`nums[l]`与`nums[l+1]`相同，那么在找到一个成功的组合后，我们需要将`l`前进至最后一个重复元素的下一个位置，来防止生成重复的解。

#### 外部`for`循环的去重

外部的去重是为了确保当我们固定第一个数`nums[i]`时，如果有多个相同的`nums[i]`存在，我们只计算一次。即为了防止在整个数组级别上处理重复的数所带来的全部可能重复的组合。

#### 两者之间的差别与必要性

- **内部去重**：处理第二个和第三个数的重复，确保在给定第一个数以后，后面两个数不会形成重复的组组合。
- **外部去重**：处理第一个数的重复，避免对整个数组中连续出现的相同数多次执行相同的寻找逻辑，导致输出重复的结果。

举一个例子来说明这两层去重的必要性： 假设有数组`[1, 1, -2, -2]`已经被排序：

- 如果没有外部循环的去重，以每个`1`为起点，内部循环都可能找到相同的三元组`[1, 1, -2]`。
- 设第一个`1`确定后，内部循环中，找到了`[1, -2, -2]`的组合，接下来内部循环的去重将跳过相同的`-2`，避免再次组合相同的三元组。

总结：

- **内部去重**避免在特定的一次固定基数的查找中生成重复组合；
- **外部去重**避免对于数组中相同的起点数重复执行查找，节省时间并防止结果重复。

因此，两个去重逻辑都是必要的，它们一起协作保证了程序的正确性和效率。

### 接雨水

```javascript
var trap = function(height) {
    let sum = 0;
    const stack = []; // 用来存放下标，形成一个单调栈结构
    let current = 0;
    
    while(current < height.length) {
        // 当前高度大于栈顶高度（栈不空且形成低洼）
        while(stack.length !== 0 && height[current] > height[stack[stack.length - 1]]) 		   {
            let h = height[stack.pop()]; // 弹出栈顶，并获得该位置的高度（低点）
            if(stack.length === 0) break; // 如果栈空了，就没有左边界了，结束当前循环
            
            let width = current - stack[stack.length - 1] - 1; // 正确计算宽度
            // 得到左右边界的最小高度
            let min = Math.min(height[current], height[stack[stack.length - 1]]); 
            sum += width * (min - h); // 计算当前低洼处的积水并加到总和中
        }
        stack.push(current); // 将当前位置加入栈中
        current++; // 移动到下一个位置
    }
    
    return sum;
};
```

当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。

如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。

### 和为k的子数组

```javascript
var subarraySum = function (nums, k) {
    const map = new Map()
    map.set(0, 1)
    let count = 0, pre = 0
    for(let n of nums){
        pre += n
        if(map.has(pre - k)){
            count += map.get(pre - k)
        }
        if(map.has(pre)){
            map.set(pre, map.get(pre) + 1)
        }else{
            map.set(pre, 1)
        }
    }
    return count
}
```

#### 思路和算法

我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。

我们定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：

pre[i]=pre[i−1]+nums[i]
那么「[j..i] 这个子数组和为 k 」这个条件我们可以转化为

pre[i]−pre[j−1]==k
简单移项可得符合条件的下标 j 需要满足

pre[j−1]==pre[i]−k
所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。

需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。



在这段代码中，`map.set(0, 1)` 是一步关键的初始化过程，这是为了正确地处理那些从数组第一个元素开始的子数组，其元素之和正好等于 `k` 的情况。

函数 `subarraySum(nums, k)` 的目标是计算数组 `nums` 中，所有元素之和等于 `k` 的连续子数组的数量。为了实现这一目标，代码使用了一个哈希表 `map`（在 JavaScript 中具体实现为 `Map` 对象），以存储前缀和以及每个前缀和出现的次数。

#### 解释 `map.set(0, 1)` 的作用：

- **前缀和（`pre`）**：在遍历数组的过程中，`pre` 用于不断累加从第一个元素到当前元素的总和。
- **如何使用前缀和**：对于任何位置 `i`，若存在一个 `j`（其中 `j < i`），使得从元素 `nums[j+1]` 到 `nums[i]` 的和等于 `k`，则 `pre[i] - pre[j]` 应等于 `k`。这可以通过验证 `pre[j]` 是否等于 `pre[i] - k` 来寻找。

#### 初始化 `map.set(0, 1)` 的原因：

- 当子数组从数组的开始到某个位置 `i` 正好等于 `k` 时，这意味着 `pre[i]`（即从 `nums[0]` 到 `nums[i]` 的和）等于 `k`。为了覆盖这种情况，你需要检查 `map` 是否含有键 `pre[i] - k`。当 `pre[i]` 正好等于 `k` 时，`pre[i] - k` 就是 `0`。
- 通过初始化 `map.set(0, 1)`，你实际上是在说：“在遍历开始之前，有一个和为 `0` 的子数组（实际上是一个空数组），并且这种情况出现了 1 次。”这样一来，每当你遇到一个 `pre[i]` 等于 `k` 的情况时，你就可以正确地增加计数器 `count`，因为 `map.get(0)` 会返回 `1`，表明已经存在一个有效的以数组开头的子数组，其和为 `k`。

不进行这一初始化将导致遗漏那些从数组开头开始并且和为 `k` 的子数组的情况，因此在计算符合条件的子数组数量时将得到错误的结果。
