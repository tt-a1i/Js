## 盒子模型

一个盒子由四个部分组成：`content`、`padding`、`border`、`margin`

`CSS`中，盒子模型可以分成：

- W3C 标准盒子模型
- IE 怪异盒子模型
- 默认情况下，盒子模型为`W3C` 标准盒子模型

1. **标准盒模型：**
   - 在标准盒模型中，元素的宽度和高度（width 和 height）属性值只包括内容区域的大小，不包括内边距（padding）、边框（border）和外边距（margin）。
   - `即元素的实际宽度和高度是由内容区域的大小加上内边距、边框和外边距的总和确定的。`
   - 这种盒模型是 CSS 标准规定的默认行为，也是现代浏览器的默认行为。
2. **怪异盒模型：**
   - 在怪异盒模型中，元素的宽度和高度（width 和 height）属性值包括内容区域、内边距和边框的大小，但不包括外边距。
   - `即元素的实际宽度和高度是由内容区域的大小加上内边距和边框的总和确定的。`
   - 怪异盒模型通常在老版本的浏览器（如 IE6 及以下）中存在，是这些浏览器的默认行为。当页面处于怪异模式（Quirks Mode）时，浏览器会采用怪异盒模型。

width部分不同,标准盒模型是content,怪异盒模型是content + border + padding

比如在怪异盒模型下，你设置width之后在设置padding，总的宽度是不变的，而是会挤压内容区

## css选择器

`css`属性选择器常用的有：

- id选择器（#box），选择id为box的元素
- 类选择器（.one），选择类名为one的所有元素
- 标签选择器（div），选择标签为div的所有元素
- 后代选择器（#box div），选择id为box元素内部所有的div元素
- 子选择器（.one>one_1），选择父元素为.one的所有.one_1的元素
- 相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素
- 群组选择器（div,p），选择div、p的所有元素

#### 优先级

`内联` >` ID选择器` > `类选择器` > `标签选择器`

如果外部样式需要覆盖内联样式，就需要使用`!important`

#### 继承属性

- 字体系列属性

```javascript
font:组合字体
font-family:规定元素的字体系列
font-weight:设置字体的粗细
font-size:设置字体的尺寸
font-style:定义字体的风格
font-variant:偏大或偏小的字体
```

- 文本系列属性

```javascript
text-indent：文本缩进
text-align：文本水平对刘
line-height：行高
word-spacing：增加或减少单词间的空白
letter-spacing：增加或减少字符间的空白
text-transform：控制文本大小写
direction：规定文本的书写方向
color：文本颜色
```

- 元素可见性

```javascript
visibility
```

- 表格布局属性

```css
caption-side：定位表格标题位置
border-collapse：合并表格边框
border-spacing：设置相邻单元格的边框间的距离
empty-cells：单元格的边框的出现与消失
table-layout：表格的宽度由什么决定
```

- 列表属性

```javascript
list-style-type：文字前面的小点点样式
list-style-position：小点点位置
list-style：以上的属性可通过这属性集合
```

- 引用

```css
quotes：设置嵌套引用的引号类型
```

- 光标属性

```css
cursor：箭头可以变成需要的形状
```

继承中比较`特殊`的几点：

- `a 标签`的`字体颜色`不能被继承
- `h1-h6`标签字体的大小也是不能被继承的

#### 无继承的属性

- display
- 文本属性：vertical-align、text-decoration
- 盒子模型的属性：宽度、高度、内外边距、边框等
- 背景属性：背景图片、颜色、位置等
- 定位属性：浮动、清除浮动、定位position等
- 生成内容属性：content、counter-reset、counter-increment
- 轮廓样式属性：outline-style、outline-width、outline-color、outline
- 页面样式属性：size、page-break-before、page-break-after

## em/px/rem/vh/vw区别

1. **px（像素）：**
   - 像素是`相对于显示器屏幕的最小点`的单位，是最基本的长度单位。
   - px 是`固定单位`，`不随着浏览器缩放而变化`，适合于固定布局。
2. **em：**
   - em 是`相对于元素自身字体`大小的单位。
   - 如果一个元素的字体大小为 16px，1em 等于 16px；如果字体大小为 20px，1em 等于 20px。
   - em 单位`可以继承父元素的字体大小`，适合于响应式设计和动态布局。
3. **rem：**
   - `rem 是相对于根元素（html）`的字体大小的单位。
   - rem 单位`不受继承影响`，始终是相对于根元素的字体大小。
   - rem 单位适用于需要整个页面的布局，更容易控制页面的整体样式。
4. **vh（视窗高度单位）：**
   - `vh 表示视口高度的百分比`，1vh 等于视口高度的 1%。
   - vh 单位可以用于制作响应式的布局，使元素的大小随着视口高度的变化而变化。
5. **vw（视窗宽度单位）：**
   - `vw 表示视口宽度的百分比`，1vw 等于视口宽度的 1%。
   - vw 单位可以用于制作响应式的布局，使元素的大小随着视口宽度的变化而变化。

总的来说，px 是最基本的单位，`em 和 rem 适用于动态布局和响应式设计`，`vh 和 vw 适用于制作响应式布局和实现相对于视口大小的元素尺寸`。选择合适的单位取决于设计需求和布局目标。

## 设备像素、css像素、设备独立像素、dpr、ppi 之间的区别

1. **设备像素（Device Pixel）：**
   - 设备像素是屏幕的物理像素，它是显示设备（如手机、电脑显示器）中最小的物理单元。
   - 设备像素是屏幕显示图像的基本单位，显示器上的每个点都由一个设备像素表示。
2. **CSS像素（CSS Pixel）：**
   - CSS 像素是浏览器中用于渲染网页的抽象单位，它是网页布局和样式表的基本单位。
   - CSS 像素通常是相对单位，它的大小会根据显示设备的像素密度而变化。
3. **设备独立像素（Device-Independent Pixel，dp 或 dip）：**
   - 设备独立像素是一种抽象单位，它是一种相对于屏幕物理特性的长度单位，通常被用于移动设备上。
   - 设备独立像素通常与密度无关的屏幕尺寸相关联，它与实际显示设备的物理像素之间有一个固定的关系。
4. **设备像素比（Device Pixel Ratio，DPR）：**
   - 设备像素比是设备像素与 CSS 像素之间的比率，用于衡量设备的像素密度。
   - 设备像素比可以通过设备的物理像素数除以 CSS 像素数来计算得到。
5. **每英寸像素（Pixels Per Inch，PPI）：**
   - 每英寸像素是指在一英寸长度内的设备像素数，用于衡量显示设备的像素密度。
   - PPI 越高，显示器的像素密度就越高，图像显示得就越清晰。

总的来说，设备像素是屏幕的物理像素，CSS 像素是浏览器中用于渲染的抽象单位，设备独立像素是相对于屏幕特性的抽象单位，DPR 是设备像素与 CSS 像素的比率，PPI 是每英寸的像素数。它们之间的关系涉及到屏幕分辨率、像素密度和网页布局等方面的概念。

## css中，有哪些方式可以隐藏页面元素？区别

1. **display: none;**
   - 使用 `display: none;` 可以完全隐藏页面元素，使其不占据任何空间。
   - 元素使用该属性后，将不会显示在页面中，并且不会占据任何空间，相当于元素从文档流中移除。
2. **visibility: hidden;**
   - 使用 `visibility: hidden;` 可以隐藏页面元素，但是元素仍然会占据空间。
   - 元素使用该属性后，仍然会保留其原本的大小和位置，只是不可见而已。
3. **opacity: 0;**
   - 使用 `opacity: 0;` 可以使页面元素完全透明，但元素仍然会占据空间。
   - 元素使用该属性后，保留原有的大小和位置，只是完全透明不可见。
4. **visibility: collapse;** (仅适用于表格元素)
   - 使用 `visibility: collapse;` 可以将表格的行或列隐藏，但是该属性只适用于表格元素。
   - 元素使用该属性后，会隐藏并且不占据任何空间。
5. **position: absolute; left: -9999px;**
   - 使用绝对定位和移动元素到屏幕外部，通常搭配 `position: absolute; left: -9999px;` 来实现。
   - 元素会被移动到屏幕外部，不会显示在页面上，但仍然会占据空间。

这些方式在实际应用中根据具体需求选择，如果需要完全隐藏元素并释放其占据的空间，可以使用 `display: none;`；如果需要隐藏元素但保留其占据的空间，可以使用 `visibility: hidden;` 或者 `opacity: 0;`。

## 谈谈你对BFC的理解？

BFC（块级格式化上下文）是 CSS 中的一种布局模式，用于定义块级盒子的布局及其内部元素如何相互排布和相互影响

1. **概念：**
   - BFC 是指一个独立的渲染区域，内部的块级盒子布局与外部无关，是一个独立的容器。
2. **特点：**
   - 内部的`块级盒子垂直方向上的布局是从上到下`的，两个块级盒子会`一个接一个地排列`。
   - 属于同一个 BFC 的`两个相邻的块级盒子的外边距会发生折叠`。
   - BFC 内部的元素`不会影响外部元素`，反之亦然。
3. **触发条件：**
   - 根元素（html）
   - 浮动元素（`float不为none`）
   - 绝对定位元素（`position`为`absolute`或`fixed`）
   - 行内块元素（`display`为`inline-block`）
   - `overflow`属性`不为visible`的块级元素
4. **应用场景：**
   - 清除浮动：将包含浮动元素的父元素设为 BFC，可以清除浮动。
   - 阻止外边距折叠：可以避免外边距折叠的影响。
   - 自适应两栏布局：使用 BFC 可以实现左右两栏布局，使得两栏高度相等且不会影响其他元素。

## 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？

实现元素水平垂直居中的方式：

1. 利用定位+margin:auto
   - 设置父元素为相对定位， 子元素移动自身50%实现水平垂直居中		

1. 利用定位+margin:负值
2. 利用定位+transform
3. table布局
4. flex布局
5. grid布局

## 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢

#### 两栏布局

- 使用 float 左浮左边栏
- 右边模块使用 margin-left 撑出内容块做内容展示
- 为父级元素添加BFC，防止下方元素飞到上方内容



`flex`可以说是最好的方案了，代码少，使用简单

注意的是，`flex`容器的一个默认属性值:`align-items: stretch;`

这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: `align-items: flex-start`

#### 三栏布局

- 两边使用 float，中间使用 margin
- 两边使用 absolute，中间使用 margin
- 两边使用 float 和负 margin
- display: table 实现
- flex实现
- grid网格布

## flexbox（弹性盒布局模型）,以及适用场景

Flexbox（弹性盒布局模型）是 CSS3 中的一种布局模式，用于在容器中对子元素进行灵活的排列和对齐。它通过在父元素上设置一些灵活的属性来控制子元素的布局，适用于各种不同的布局需求。

#### **特点：**

1. **灵活的布局：** Flexbox 可以让子元素在容器内以弹性的方式布局，根据容器的大小和子元素的特性自动调整布局。
2. **一维布局：** Flexbox 是针对一维布局（主轴和交叉轴）设计的，主要用于解决水平或垂直方向上的布局问题。
3. **对齐和排列：** Flexbox 提供了多种属性来控制子元素在主轴和交叉轴上的对齐和排列方式，包括主轴上的对齐方式（justify-content）、交叉轴上的对齐方式（align-items）、以及单个子元素的对齐方式（align-self）等。
4. **弹性伸缩：** Flexbox 允许子元素根据自身的特性和父容器的大小进行伸缩，可以设置子元素的伸缩比例（flex-grow）、收缩比例（flex-shrink）、以及基准大小（flex-basis）等。
5. **自适应布局：** Flexbox 可以适应不同尺寸的屏幕和设备，实现响应式布局效果，提高页面的适应性和可用性。

#### **适用场景：**

1. **水平和垂直居中：** 使用 Flexbox 可以轻松实现水平和垂直居中的效果，适用于各种布局场景。
2. **等高布局：** Flexbox 可以实现等高列布局，即使子元素的高度不同也可以保持同一行的高度相等。
3. **弹性布局：** Flexbox 可以实现弹性伸缩的布局效果，根据内容和空间的变化自动调整布局，适用于动态内容和可变尺寸的页面。
4. **响应式布局：** Flexbox 可以实现简单且有效的响应式布局，适应不同尺寸的屏幕和设备，提高页面的适应性和可用性。

## Grid（网格布局）

CSS Grid（网格布局）是 CSS3 中的一种布局模式，它提供了一种强大且灵活的方式来创建二维布局，可以将页面划分为行和列，并在这些行和列中放置元素。以下是 CSS Grid 的主要特点和适用场景：

**特点：**

1. **二维布局：** CSS Grid 是一种二维布局模式，可以同时控制行和列，以创建复杂的布局结构。
2. **自动调整：** Grid 布局可以根据网格容器的大小和子元素的特性自动调整布局，适应不同尺寸的屏幕和设备。
3. **强大的对齐方式：** Grid 提供了多种属性来控制子元素在网格中的对齐方式，包括对齐到网格线、对齐到网格区域等。
4. **网格线和网格轨道：** Grid 使用网格线（grid lines）和网格轨道（grid tracks）来定义布局，可以通过设置网格线的位置和间距来实现灵活的布局效果。
5. **网格区域：** Grid 允许将多个网格单元格组合成一个网格区域，可以通过命名网格区域来更方便地管理布局。

**适用场景：**

1. **复杂布局：** Grid 布局适用于创建复杂的布局结构，例如多栏布局、网格瀑布流布局等。
2. **等高布局：** Grid 布局可以实现等高列布局，即使子元素的高度不同也可以保持同一行的高度相等。
3. **响应式布局：** Grid 布局可以实现简单且有效的响应式布局，适应不同尺寸的屏幕和设备。
4. **项目布局：** Grid 布局适用于项目管理和布局，可以使用网格区域来更清晰地定义和管理页面的结构。

## CSS3新增了哪些新特性

1. **选择器的增强：** CSS3 引入了许多新的选择器，如属性选择器（Attribute Selectors）、伪类选择器（Pseudo-classes）、伪元素选择器（Pseudo-elements）等，使得样式的选择更加灵活和强大。
2. **盒模型的增强：** CSS3 引入了新的盒模型属性，如 box-sizing 属性，可以控制盒模型的尺寸计算方式，使得开发者可以更方便地进行布局设计。
3. **布局模块的增强：** CSS3 引入了弹性盒子布局（Flexbox）、网格布局（Grid Layout）等新的布局模块，可以更方便地实现复杂的页面布局效果。
4. **字体样式的增强：** CSS3 引入了新的字体属性，如 @font-face 规则、字体阴影（text-shadow）等，使得文字样式的设置更加丰富和灵活。
5. **渐变效果：** CSS3 引入了渐变效果（Gradient），包括线性渐变和径向渐变，可以在元素背景、边框等位置实现丰富多彩的渐变效果。
6. **过渡和动画：** CSS3 引入了过渡效果（Transition）和动画效果（Animation），可以实现元素的平滑过渡和动画效果，使得页面更加生动和具有交互性。
7. **多列布局：** CSS3 引入了多列布局（Multi-column Layout），可以实现多列文本布局，提高页面的可读性和排版效果。
8. **响应式布局：** CSS3 提供了媒体查询（Media Queries）和弹性图片（Flexible Images）等技术，可以实现响应式布局，使得页面可以在不同设备上呈现出最佳的布局效果。
9. **阴影和边框效果：** CSS3 引入了新的阴影效果（Box-shadow）和边框效果（Border-radius），可以实现丰富多彩的阴影和边框样式。
10. **3D转换和变换：** CSS3 引入了 3D 转换（Transform）和变换（Transform）效果，可以实现元素的三维旋转、缩放、平移等效果，增强页面的视觉效果。

## css3动画有哪些

- transition 实现渐变动画
- transform 转变动画
- animation 实现自定义动画

## 回流跟重绘

#### 重绘与重排区别

```javascript
    重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。

    重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,叫做重绘。表现为某些元素的外观被改变

『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。

如何触发重排和重绘？

    添加、删除、更新DOM节点

    通过display: none隐藏一个DOM节点-触发重排和重绘
display: none; 样式会立即隐藏元素，并触发回流和重绘，但是它不会占据页面布局空间，也无法接收用户交互事件。
    通过visibility: hidden隐藏一个DOM节点-只触发重绘

    移动或者给页面中的DOM节点添加动画

    添加一个样式表，调整样式属性

    用户行为，例如调整窗口大小，改变字号，或者滚动。

如何避免重绘或者重排？

    集中改变样式，不要一条一条地修改 DOM 的样式。

    不要把 DOM 结点的属性值放在循环里当成循环里的变量。

    尽量只修改position：absolute或fixed元素，对其他元素影响不大

    提升为合成层

    优点：
        合成层的位图，会交由 GPU 合成，比 CPU 处理要快
        当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
        对于 transform 和 opacity 效果，不会触发 layout 和 paint

方式：是使用 CSS 的 will-change 属性
```

## 行内元素、块级元素、空元素

| 类型         | 元素                                                         |
| :----------- | :----------------------------------------------------------- |
| 块级元素     | `<div>`, `<p>`, `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, `<h6>`, `<ol>`, `<ul>`, `<li>`, `<table>`, `<form>`, `<header>`, `<footer>`, `<section>`, `<article>`, `<nav>`, `<aside>` |
| 行内元素     | `<span>`, `<a>`, `<strong>`, `<b>`, `<em>`, `<i>`, `<u>`, `<sub>`, `<sup>`, `<img>`, `<label>`, `<textarea>`, `<input>`（部分情况除外）, `<button>`（部分情况除外） |
| 行内块级元素 | `<img>`, `<input>`, `<label>`, `<button>`                    |

### 块级元素（Block-level elements）

- **布局特性**：通常会占据调用它的容器的整个宽度，并且其后的元素会在新的一行显示。
- **常见用途**：用于创建文档或应用的结构布局。

### 行内元素（Inline elements）

- **布局特性**：不会独占一行，其宽度仅包围其内容。
- **常见用途**：用于标记文本，可以在段落内部或其他块级元素内部使用，而不会引起文本换行。

### 行内块级元素（Inline-block elements）

- **布局特性**：类似于行内元素，不会导致换行；同时具有块级元素的某些特性，如设置宽度和高度。
- **常见用途**：适合在需求同时需要行内布局和宽高控制的场景。

请注意，这个表格中的分类是基于元素的默认显示类型，但CSS可以修改这些元素的默认行为（例如，使用`display:block`，`display:inline`或`display:inline-block`等CSS属性）。

## Css预编语言

CSS预处理器是一种将类似于编程语言的特性引入CSS的工具，它们使得CSS`更具有可维护性`、可扩展性和重用性。常见的CSS预处理器包括Sass、Less和Stylus等,预处理是`Css`的超集

1. **特性**：
   - CSS 预处理器引入了类似于编程语言的特性，如变量、嵌套规则、混合（mixin）、继承（extend）等，使得样式代码更加模块化和易于维护。
   - 原生CSS没有这些特性，编写复杂的样式时可能会导致代码冗长和重复。
2. **变量**：
   - 预处理器允许定义变量来存储颜色、尺寸等样式信息，提高了样式的可重用性和维护性。
   - 原生CSS没有变量的概念，样式信息需要在多个地方重复编写。
3. **嵌套规则**：
   - 预处理器支持将样式规则嵌套在父选择器内，更加清晰地表示样式之间的层级关系。
   - 原生CSS不支持嵌套，需要在样式表中重复写选择器，增加了代码的冗余度。
4. **混合（Mixin）**：
   - 预处理器允许定义可重用的样式块，称为混合（Mixin），可以在需要的地方引用。
   - 原生CSS中实现相同效果需要使用类似于类的方式来实现，代码会变得冗长。
5. **继承（Extend）**：
   - 预处理器支持通过继承来共享样式规则，提高了样式的复用性和可维护性。
   - 原生CSS中没有继承的概念，样式需要在多个地方重复编写。
6. **代码压缩和优化**：
   - 预处理器通常提供了代码压缩和优化的功能，可以将编写的样式文件编译为精简的CSS文件，减少页面加载时间。
   - 原生CSS没有这样的功能，需要手动进行代码压缩和优化

## SCSS

SCSS（Sassy CSS）是一种 CSS 预处理语言，它扩展了 CSS 的功能并且提供了更多程序化的特性。SCSS 通过 Sass（Syntactically Awesome Style Sheets）来处理，Sass 是一个成熟、稳定、且强大的 CSS 扩展语言。SCSS 让你可以使用变量、嵌套规则、混入（mixins）、继承以及更多有助于编写可维护和重用的样式表的功能。

### 主要特性

#### 1. 变量

你可以存储一些经常使用的样式值，如颜色、字体或任何 CSS 值，并且通过一个方便的名称来重用它们。这让你的 CSS 代码更容易维护和更新。

```scss
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
```

#### 2. 嵌套

SCSS 允许你使用嵌套语法，让 CSS 规则的结构更清晰和更紧凑。这样的方式使得继承父选择器的制定更为直观。

```scss
nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
```

#### 3. 混入

混入允许你创建可复用的代码块，并且可以包含全部的 CSS 属性。

```scss
@mixin border-radius($radius) {
  -webkit-border-radius: $radius;
     -moz-border-radius: $radius;
      -ms-border-radius: $radius;
          border-radius: $radius;
}

.box { @include border-radius(10px); }
```

#### 4. 导入

SCSS 提供了一个更加强大的 `@import` 规则，它允许你导入其他样式表文件，这有助于你组织和模块化你的样式代码。

#### 5. 继承

使用 `@extend`，你可以让一个选择器继承另一个选择器的样式。这是一个简单强大的方式来避免重复代码，并保持样式表的整洁和可读性。

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}

.seriousError {
  @extend .error;
  border-width: 3px;
}
```

#### 6. 控制指令

SCSS 提供了一些编程结构如条件语句和循环，这些可以用来动态生成样式。

```scss
@for $i from 1 through 10 {
  .border-#{$i} { border-width: #{$i}px; }
}
```

## SVG的属性

###  核心属性

- **id:** 定义唯一标识符。
- **class:** 指定应用一个或多个类。
- **style:** 用于指定CSS样式。

### 2. 图形属性

- **fill:** 定义图形的`填充颜色`。
- **stroke:** 定义图形`轮廓的颜色`。
- **stroke-width:** 定义`轮廓的宽度`。

### 3. 位置与尺寸属性

- **x, y:** 用于定义元素的`位置`。
- **width, height:** 用来`定义元素的宽度和高度`。
- **cx, cy:** 对于圆形元素，`定义圆心位置`。
- **r:** 对于圆形元素，`定义半径`。
- **d:** 用于`<path>`元素，`定义路径`。

### 4. 变换属性

- **transform:** 应用于元素的变换，如平移（`translate`）、缩放（`scale`）、旋转(`rotate`)、斜切(`skewX`, `skewY`)。

### 5. 文本属性

- **text-anchor:** 定义文本的对齐方式（如`start`, `middle`, `end`）。
- **font-size, font-family, font-weight:** 分别设置字体大小、字体族和字体粗细。

### 6. 视图控制属性

- **viewBox:** 定义要从SVG图像中显示的部分。
- **preserveAspectRatio:** 控制SVG图形在不同视口尺寸下的缩放和对齐方式。

### 7. 颜色和样式

- **opacity:** 定义`透明度`。
- **fill-opacity, stroke-opacity:** 分别设置填充和描边的透明度。

### 8. 动画属性

- **animate, animateTransform, animateMotion:** 用于定义动画效果。

### 9. 链接属性

- **href (或 xlink:href):** 用于在SVG元素中`创建链接`。

### 10. 事件属性

SVG支持绑定常见的事件如：

- **onclick, onmouseover, onmouseout, onload,** 等