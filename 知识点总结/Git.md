## git操作问题，如果想把2次修改合并成一个提交，可以怎么做

在Git中，如果你想将两次修改合并为一个提交，你可以使用交互式变基（interactive rebase）来实现。步骤如下：

1. **确保工作树干净**：在进行交互式变基之前，确保你的工作树没有未提交的更改。这可以通过以下命令查看：
   ```bash
   git status
   ```

2. **启动交互式变基**：
   假设你要合并最近的两个提交，可以使用以下命令启动交互式变基：
   ```bash
   git rebase -i HEAD~2
   ```
   这会打开一个文本编辑器，显示最近两个提交的列表。

3. **编辑提交列表**：
   在文本编辑器中，你会看到类似这样的内容：
   ```
   pick abcd123 Commit message 1
   pick efgh456 Commit message 2
   ```
   将第二个提交的"pick"更改为"squash"（或缩写为"s"）：
   ```
   pick abcd123 Commit message 1
   squash efgh456 Commit message 2
   ```
   这会将第二个提交压缩到第一个提交中。

4. **保存并退出编辑器**：
   保存更改并退出编辑器。在Vim中，可以按`Esc`，然后输入`:wq`并按`Enter`退出。

5. **编辑提交信息**：
   在此之后，Git会再次打开编辑器，让你编辑合并后的提交信息。你可以根据需要修改提交信息。

6. **完成变基**：
   保存并退出编辑器以完成变基过程。

7. **处理冲突（如果有）**：
   如果在变基过程中出现冲突，Git会提示你解决冲突。解决冲突后，使用以下命令继续变基：
   ```bash
   git rebase --continue
   ```

请注意，如果你已经将这些提交推送到了公共仓库，执行以上操作之后，需要使用强制推送来更新远程分支：
```bash
git push origin branch-name --force
```
但要小心，因为强制推送可能会覆盖他人的更改，因此确保你在一个安全的环境下进行此操作。

## git运行机制

Git 是一个分布式版本控制系统，它通过一系列机制高效地管理代码历史记录、分支和合并操作。了解 Git 的运行机制有助于更好地理解其功能和使用它进行版本控制。以下是 Git 的核心运行机制：

### 1. 基本对象模型

Git 的内部数据存储基于四种类型的对象：
- **Blob（Binary Large Object）**：存储文件内容，包含文件的二进制数据和元数据。
- **Tree（树）**：存储目录结构，包含指向 blob 和其他 tree 对象的引用。
- **Commit（提交）**：存储元数据和指向一个 tree 对象的引用，表示一次提交。
- **Tag（标签）**：存储对特定 commit 的引用，通常用于打版本标签。

这些对象通过 SHA-1（Secure Hash Algorithm）哈希值进行引用，确保内容不可变且独一无二。

### 2. Git 仓库

一个 Git 仓库主要包括以下部分：
- **工作目录（Working Directory）**：用户当前正在操作的文件及其目录。
- **暂存区（Staging Area或Index）**：一个隐藏的区域，用于保存下次提交的快照。
- **本地仓库（Local Repository）**：包含所有提交对象的仓库，在 `.git` 目录中。

### 3. 基本操作流程

#### 1. 文件保存
- **`git add`**：将文件添加到暂存区中。
  在使用 `git add` 命令后，文件的快照会被保存到暂存区中，以备下次提交。

- **`git commit`**：将暂存区的内容提交到本地仓库。
  这一步会创建一个新的 commit 对象，并将其保存到本地仓库中。

#### 2. 分支管理
- **`git branch`**：列出、创建或删除分支。
  Git 通过分支指针（branch pointer）和提交对象（commit object）实现分支管理。

- **`git checkout`**：切换分支或检出特定的提交。
  通过该命令，你可以切换到不同的分支，使工作目录内容与分支指向的提交一致。

- **`git merge`**：合并分支。
  `git merge` 会将两个分支的内容合并并生成一个新的 commit 对象，解决冲突后保存合并结果。

#### 3. 远程仓库
- **`git clone`**：克隆远程仓库。
  将远程仓库的所有内容复制到本地新建的目录中。

- **`git fetch`**：获取远程仓库的更新。
  将远程仓库的新提交和分支信息拉取到本地，但不合并到当前分支。

- **`git pull`**：拉取并合并远程仓库的更新。
  相当于 `git fetch` 和 `git merge` 的组合，将远程更新拉取后合并到当前分支。

- **`git push`**：将本地提交推送到远程仓库。
  将本地的提交对象推送到远程仓库，以便其他团队成员共享。

### 4. 提交与回滚

- **提交**：每次 `git commit` 都会生成一个新的 commit 对象，包含本次提交的变更快照和元信息（如作者、时间、提交信息等），以及指向上一个 commit 的引用。

- **回滚**：
  - **`git reset`**：根据需要重置工作目录和暂存区。常用于回滚最近的变更或取消暂存区中的内容。
  - **`git revert`**：生成一个新的 commit 用来撤销指定的提交，不会影响后续提交记录。
  - **`git checkout`**：可以还原单个文件或切换到特定 commit。

### 5. 哈希和完整性

Git 使用 SHA-1 哈希值对所有对象（commit、tree、blob、tag）进行标识。由于哈希值是基于内容生成的，每个对象都有唯一性，这保证了内容的完整性和唯一性。如果内容发生变化，其哈希值也将发生改变。

### 6. 分布式特性

Git 是分布式的，这意味着：
- 每个开发者都拥有一个完整的代码库副本。
- 大部分操作（如提交、分支切换、合并等）都在本地完成，无需访问远程仓库。
- 开发者可以在离线状态下进行版本控制工作，当网络环境允许时，通过 `git fetch`、`git pull` 和 `git push` 与远程仓库同步。

### 7. 冲突解决

当多个开发者对同一基准的代码进行并行更改并提交时，可能会发生冲突。主要通过以下步骤解决冲突：
- **检测冲突**：在合并或拉取操作后，Git 会自动检测文件内容冲突。
- **手动解决**：手动编辑冲突文件，解决与标记冲突内容，确认并测试代码。
- **提交解决方案**：将解决后的文件重新暂存并提交。

### 示意流程

1. **添加/暂存变更**：
   ```sh
   git add <file>
   git add .
   ```

2. **提交暂存区内容**：
   ```sh
   git commit -m "Commit message"
   ```

3. **推送到远程仓库**：
   ```sh
   git push origin <branch>
   ```

4. **拉取远程分支并合并**：
   ```sh
   git pull origin <branch>
   ```

5. **创建并切换分支**：
   ```sh
   git branch <new-branch>
   git checkout <new-branch>
   or 
   git checkout -b <new-branch>  # create and switch in one command
   ```

6. **合并分支**：
   ```sh
   git checkout <target-branch>
   git merge <source-branch>
   ```

通过上述示例和详细解释，相信你可以更好地了解 Git 的运行机制及其核心功能。这不仅有助于日常版本控制和协作开发，也为深入理解和优化 Git 使用提供了基础。

## merge与rebase区别

`git merge` 和 `git rebase` 是 Git 中两种合并代码历史的方式，但它们的工作方式和用途略有不同。理解这两者的区别和使用场景对管理代码历史非常重要。

### git merge

#### 功能：
`git merge` 用来将两个分支的历史合并在一起。它通过创建一个新的合并提交 (merge commit)，在一个分支上引入另一个分支的内容，同时保留两个分支的历史记录。

#### 工作方式：
假设你在 `main` 分支工作，并想将 `feature` 分支合并到 `main` 分支上。执行 `git merge feature` 后，Git 会创建一个新的合并提交，该提交有两个父提交，一个来自 `main`，一个来自 `feature`。

#### 优点：
- **保持历史一致性**：两条分支的开发历史完整保留。
- **清晰的提交历史**：可以轻松追踪每次合并的具体内容。

#### 缺点：
- **提交历史可能变得复杂**：随着时间推移，尤其是在多个分支反复合并后，提交历史可能变得较为复杂，特别是在大规模团队协作中。

#### 使用场景：
- 团队开发时，定期将开发分支合并到主要分支。
- 保留开发历史，确保变更可追溯。

#### 示例：
```sh
# 切换到主分支
git checkout main

# 合并 feature 分支到主分支
git merge feature
```

### git rebase

#### 功能：
`git rebase` 通过将一个分支的提交重新应用到另一个分支的顶端，来重塑提交历史。它不会创建新的合并提交，而是将每个提交“前移”（相当于重新应用）到目标分支上。

#### 工作方式：
假设你在 `feature` 分支工作，并想基于 `main` 分支的最新提交继续开发。执行 `git rebase main` 后，Git 会先临时保存 `feature` 分支上的提交，将 `feature` 分支重置到 `main` 分支，然后将这些临时保存的提交依次应用到 `main` 的最新提交之后。

#### 优点：
- **提交历史更简洁**：提交历史线性化，让提交记录更简洁。
- **便于代码审查**：线性历史便于审查每个提交的内容。

#### 缺点：
- **历史重写问题**：需要注意，rebase 会重写提交历史，这可能影响已经共享的提交。因此在公共分支或已推送到远程仓库的分支上使用 rebase 时需格外小心。

#### 使用场景：
- 在团队成员互不干扰的前提下进行个人开发时。
- 在将分支推送到共享仓库之前，整理互相关联的提交记录。

#### 示例：
```sh
# 切换到 feature 分支
git checkout feature

# 将 feature 分支的提交重写到 main 分支的顶端
git rebase main
```

### 具体区别

1. **提交历史**：
    - **Merge**：保留原有分支的提交历史，并生成一个合并提交。
    - **Rebase**：把原有分支的提交一一重新应用到目标分支之上，提交历史变为线性。

2. **使用场景**：
    - **Merge**：适合在需要保留分支开发历史的情况下使用，尤其是在团队协作中。
    - **Rebase**：适合在个人或小团队开发中，目的是保持提交历史的整洁和线性化。

3. **冲突解决**：
    - **Merge**：每次合并时只需要解决一次冲突，通常在合并提交时解决。
    - **Rebase**：每次重新应用提交时都可能会遇到冲突，需要逐一解决。

### 合并和快进

值得一提的是，`git merge` 在某些情况下可以进行“快进合并”（Fast-forward merge），这是一种特殊的合并方式，适用于目标分支包含源分支的所有提交。在这种情况下，Git 不会创建新的合并提交，而是直接将分支指针向前移动。

#### 示例：
```sh
# 切换到主分支
git checkout main

# 如果 main 目前是符合快进条件的，可以执行快进合并
git merge feature
```

使用 `git rebase` 或 `git merge` 要根据具体情况和团队约定进行选择，熟练掌握两者的区别和用法可以更好地管理代码历史，确保项目的健康发展。

## git撤回commit

在使用 Git 进行版本控制的过程中，有时候我们可能会需要撤回一个已经提交的 commit。Git 提供了多种方法来撤回 commit，具体选择哪种方法取决于你的具体需求以及仓库的状态。以下是常见的撤回 commit 的方法：

### 1. 使用 `git reset`

`git reset` 命令可以用于撤回最近的 commit。

#### 撤回最近一次提交但保留更改
```bash
git reset --soft HEAD~1
```
这个命令将撤回最近一次的提交，但保留源文件的更改（这些更改将处于未暂存状态）。

#### 撤回最近一次提交并删除更改
```bash
git reset --hard HEAD~1
```
这个命令将完全撤回最近一次的提交，并删除在这次提交中的所有更改。

### 2. 使用 `git revert`

`git revert` 命令适用于已经推送到共享仓库的提交，因为它会创建一个新的 commit 来撤销指定的 commit，而不会改变 commit 历史。

#### 撤回指定的提交
```bash
git revert <commit-id>
```
这个命令会创建一个新的 commit 来反转指定的 commit（使用 `<commit-id>` 可以指定需要撤回的 commit）。

### 3. 使用 `git checkout`

如果只是想撤回对文件的更改，而不是某个提交，可以使用 `git checkout`。

#### 撤回对文件的更改
```bash
git checkout -- <file>
```
这个命令会将指定文件恢复到最后一次提交的状态。

### 4. 交互式重写历史：使用 `git rebase -i`

此方法通常用于撤回多个提交或者重写历史。

#### 交互式 rebase
```bash
git rebase -i HEAD~n
```
`n` 是回退的提交数目。这将打开一个编辑器窗口，其中列出了从最近到较早的 `n` 个提交。你可以在这里通过改变关键词（如 `pick` 改为 `drop`）来删除某个提交，或者进行其他修改。

### 5. 使用 `git stash`

如果你仅仅希望撤销当前工作区的修改，可以使用 `git stash`。

#### 将当前修改保存到 stash
```bash
git stash
```

#### 恢复到最近一次提交状态
```bash
git stash drop
```
这个命令会删除刚刚保存到 stash 的修改。

### 结合使用
有时候你可能希望结合使用多个命令。例如，先进行 `stash` 保存当前工作区的修改，然后进行 `reset`。

#### 保存当前工作区更改，然后撤回最近的 commit
```bash
git stash
git reset --hard HEAD~1
git stash apply
```
这种方法可以确保你可以撤回 commit 的同时保存当前的修改。

### 注意事项
- **操作历史**: `git reset --hard` 这些会重写历史的操作应慎重使用，特别是在已经推送到远端的提交。通常情况下，如果你需要修改已经共享的历史，最好使用 `git revert`。
- **备份**: 在进行这些操作前，建议先进行备份或确认操作的安全性，特别是 `--hard` 选项，因为它会移除所有未保存的更改。

通过这些方法，你可以选择最适合当前情况的方法来撤回 commit。记得在团队协作中，合理使用这些命令，以避免给其他团队成员带来困扰。

## Git Reset 

`git reset` 是一个强大的工具，可以用来修改提交历史。它通过移动分支指针到指定提交来实现。

**三种模式：**

* `--soft`:  只移动分支指针，不改变工作目录和暂存区。
* `--mixed` (默认): 移动分支指针，重置暂存区到指定提交，但保留工作目录的修改。
* `--hard`:  移动分支指针，重置暂存区和工作目录到指定提交。

**常用场景：**

**1. 撤销提交**:

* 撤销最后一次提交，保留修改：`git reset --soft HEAD~1`
* 撤销最后一次提交，丢弃修改：`git reset --hard HEAD~1`

**2. 重置暂存区**:

* 放弃所有暂存区的修改：`git reset` 或 `git reset HEAD`
* 放弃某个文件的暂存区修改：`git reset HEAD <file>`

**3. 创建新的提交点**:

* 将最近三次提交合并为一次新的提交：
  1. `git reset --soft HEAD~3`
  2. `git commit -m "New commit message"`

**4. 回滚到之前的某个提交**:

* 首先找到目标提交的哈希值 (可以用 `git log` 查看)
* 然后执行 `git reset --hard <commit_hash>`

**注意事项：**

* `git reset` 操作会改变历史记录，谨慎使用！
* 如果修改已经被推送到远程仓库，则需要强制推送 (`git push -f`)，但这可能会覆盖其他人的修改，所以需要谨慎操作。
* 在执行 `git reset --hard` 之前，最好先备份你的工作目录。

**其他用法：**

* `git reset --merge`:  用于解决合并冲突。
* `git reset --keep`:  保留工作目录的修改，但只更新与指定提交有差异的文件。

**总结：**

`git reset` 是一个强大的工具，可以帮助你灵活地管理提交历史。但在使用之前，请务必理解它的工作原理和潜在风险。

## Git Revert 指南

`git revert` 是一个安全的撤销提交的命令。与 `git reset` 不同，`git revert` 不会改变现有的提交历史，而是创建一个新的提交来撤销目标提交的修改。

**主要作用：**

* **安全地撤销提交:**  在不修改历史记录的情况下撤销某个提交的影响。
* **协同开发:**  由于 `git revert` 不会修改历史记录，因此更适合团队合作，避免冲突和代码丢失。

**使用方法：**

```
git revert <commit-id>
```

`<commit-id>` 是指需要撤销的提交的哈希值。

**工作原理：**

1. `git revert` 会创建一个新的提交，该提交包含了与目标提交相反的修改。
2. 新的提交会被添加到当前分支的末尾。

**示例：**

* 撤销上一次提交: `git revert HEAD`
* 撤销指定的提交: `git revert a1b2c3d` (其中 `a1b2c3d` 是目标提交的哈希值)

**revert 多个提交:**

* 可以通过 `git revert -n <commit1>..<commit2>` 来撤销一个范围内的提交，但不包括 `commit1`。
  * 例如：`git revert -n HEAD~3..HEAD` 会撤销最近的两次提交。
* 执行完上面的命令后，还需要进行一次提交操作，将撤销操作记录下来。

**注意事项：**

* `git revert` 只能撤销已经提交到版本库的修改，对于未提交的修改无效。
* 如果目标提交已经被合并到其他分支，`git revert` 会提示冲突，需要手动解决。
* 为了避免代码库历史混乱，建议在执行 `git revert` 之前与团队成员沟通。

**总结：**

`git revert` 提供了一种安全的撤销提交的方式，它不会改变历史记录，更适合团队合作。建议优先使用 `git revert` 来撤销提交，除非你确定需要彻底删除某个提交。

## Git Rebase 指南

`git rebase` 是一个强大的命令，用于对提交历史进行修改。它可以改变一系列提交发生的位置，并将其应用到新的基底提交上。 这就像是在说：“我希望这串提交看起来像是从这里开始的，而不是从那里开始的。”

**主要作用：**

* **整理提交历史：** 合并多个提交、编辑提交信息、删除或重排提交。
* **合并分支：**  将一个分支的修改整合到另一个分支，并保持线性历史记录。
* **改变基底分支：**  将一系列提交应用到不同的父分支上。

**工作原理：**

1. `git rebase` 会找到一系列提交的共同祖先提交。
2. 从共同祖先开始，`git rebase` 会将每个提交的差异以补丁的形式保存下来。
3. 然后，`git rebase` 会将分支切换到新的基底提交。
4. 最后，`git rebase` 会将之前保存的补丁依次应用到新的基底分支上，生成新的提交。

**常用命令：**

* **`git rebase <base>`:** 将当前分支rebase到 `<base>` 分支上。
* **`git rebase -i <base>`:** 交互式 rebase，允许对提交进行更精细的操作，例如编辑、删除、合并提交等。
* **`git rebase --abort`:** 终止正在进行的 rebase 操作，并将分支恢复到 rebase 之前的状态。
* **`git rebase --continue`:** 解决冲突后，继续 rebase 操作。

**示例：**

**1. 合并多个提交:**

```
git rebase -i HEAD~3
```

这将打开一个交互式编辑器，列出最近的三个提交。你可以选择 `squash` 选项将多个提交合并成一个。

**2.  将一个分支的修改合并到另一个分支：**

```
git checkout feature
git rebase develop
```

这会将 `feature` 分支的修改 rebase 到 `develop` 分支上，保持线性的历史记录。

**3.  改变基底分支:**

```
git rebase --onto new-feature master~5
```

这会将当前分支从 `master` 分支的第五个祖先提交开始 rebase 到 `new-feature` 分支上。

**注意事项：**

*  **不要 rebase 已经推送到远程仓库的分支！** 这会覆盖远程分支的历史记录，导致与其他协作者的代码冲突。
*  `git rebase` 会改变提交历史，请谨慎使用。
*  在执行 `git rebase` 之前，最好先备份你的工作目录。
*  如果 rebase 过程中出现冲突，需要手动解决冲突，然后使用 `git add` 标记解决，最后使用 `git rebase --continue` 继续 rebase。

**总结:**

`git rebase` 是一个强大的工具，可以用于清理提交历史、合并分支和改变基底分支。但是，它也可能会改变历史记录，因此请谨慎使用，并确保在执行之前已备份你的工作目录。

## git fetch和git pull什么区别

`git fetch` 和 `git pull` 都是用于从远程仓库获取更新的命令，但它们的工作方式和效果有所不同。

**简单来说：**

* **`git fetch`**  是 **只下载**  远程仓库的更新到本地，**不合并** 到你的当前工作分支。
* **`git pull`**  是 **下载** 远程仓库的更新，**并自动合并** 到你的当前工作分支。


**详细解释：**

**1. git fetch**

* **作用:**  从远程仓库下载最新的分支和提交信息到本地，但不会改变你本地仓库的内容。
* **结果:** 你会得到远程仓库的最新状态，但你的工作目录和分支不会有任何改变。你需要手动合并远程分支到你的本地分支。
* **命令:**
  * `git fetch <remote>`:  从指定的远程仓库获取所有分支的更新。
  * `git fetch <remote> <branch>`:  从指定的远程仓库获取指定分支的更新。
* **优点:**
  * 更安全，因为它不会自动修改你的本地分支。
  * 允许你在合并之前先查看远程分支的变化。

**2. git pull**

* **作用:**  相当于 `git fetch` + `git merge`。它会先从远程仓库下载更新，然后自动尝试将远程分支合并到你的当前工作分支。
* **结果:**  你的本地分支会被更新到远程分支的最新状态。
* **命令:**
  * `git pull <remote> <branch>`:  从指定的远程仓库获取指定分支的更新，并合并到当前分支。
* **优点:** 
  *  操作简单，一步完成更新和合并。

**使用场景：**

* **git fetch:**
  *  当你想要查看远程仓库的更新，但不想立即合并到你的工作目录时。
  *  当你想要在合并之前先审查远程分支的修改时。
* **git pull:**
  * 当你想要快速更新你的本地分支到远程分支的最新状态时。

**总结：**

`git fetch`  更加安全和可控，因为它不会自动修改你的本地分支。 `git pull`  更加方便快捷，但可能会导致冲突，需要手动解决。 建议根据你的实际情况选择合适的命令。 

希望这个解释能够帮助你理解 `git fetch` 和 `git pull` 的区别！

##  Git Rebase 介绍及使用场景 

**1. 什么是 Git Rebase?**

`git rebase` 是一个强大的 Git 命令，用于改变提交的基底。它可以将一系列提交移动到一个新的基底提交上，从而改变提交历史的线性顺序。

**2.  Rebase vs. Merge**

*  **Merge:** 合并分支时保留所有分支的完整历史，会在目标分支上创建一个新的合并提交。
*  **Rebase:**  将你的分支上的提交“重新播放”到目标分支的最新提交之上，形成一个线性的提交历史。

**3. 如何使用 Git Rebase？**

```bash
# 将 feature 分支 rebase 到 master 分支
git checkout feature 
git rebase master 
```

**4. Rebase 的常见用法：**

* **整理本地提交历史:**  在将代码推送到远程仓库之前，可以使用 `git rebase`  合并、拆分、修改或重新排序本地提交，使提交历史更加清晰易懂。
* **将分支合并到主分支:** 可以使用 `git rebase`  将一个分支的修改合并到主分支上，形成一个线性的历史记录，避免出现过多的合并提交。
* **解决冲突:** 在 rebase 过程中可能会出现代码冲突，需要手动解决冲突后再继续 rebase 操作。

**5.  Rebase 的使用场景:**

* **保持主分支历史记录的整洁:**  当你开发一个新功能，并希望将代码合并到主分支时，使用 rebase 可以使主分支的历史记录更加清晰。
* **简化代码审查:**  线性的提交历史更容易进行代码审查，因为审阅者可以清晰地看到每次提交所做的更改。
* **与他人合作开发时:** 当你在一个共享分支上工作时，使用 rebase 可以避免出现过多的合并提交，使团队成员更容易理解代码的历史记录。

**6.  使用 Rebase 的注意事项：**

* **不要在已经推送到远程仓库的提交上使用 rebase。** 
    * Rebase 会重写提交历史，如果你的提交已经被其他人拉取，那么 rebase 会导致代码库的历史不一致。
* **谨慎使用 rebase，确保你理解其工作原理。** 
    *  不当使用 rebase 可能会导致代码丢失或其他问题。
* **在 rebase 之前，最好先备份你的分支。**

**7.  总结：**

`git rebase`  是一个强大的工具，可以帮助你创建更加清晰、易于理解的 Git 提交历史。当你需要清理本地提交历史、将分支合并到主分支或与他人合作开发时，可以考虑使用 rebase。 但是，在使用 rebase 之前，请务必理解其工作原理，并谨慎操作。

## Git rebase和git revert区别

`git rebase` 和 `git revert` 是 Git 中用于管理和修改提交历史的两个不同命令。它们有不同的用途和效果，以下是它们的主要区别：

### `git rebase`

1. **用途**：
   - `git rebase` 主要用于在合并分支或更新分支时重新应用提交。它可以用来将某个分支的提交移动到另一个基础上，从而保持提交历史的线性和清晰。

2. **工作原理**：
   - `git rebase` 会将分支中的提交“一一提取”（应用于补丁），然后“放到”目标分支上。这可能会引入冲突，需要手动解决。

3. **影响**：
   - 修改提交历史：它会改变目标分支上提交的哈希，因此通常不建议对已推送的共享分支进行重排。
   - 提交历史变得线性：消除了不必要的分叉，清理了提交历史。

4. **常见场景**：
   - 在合并功能分支之前，先用 `git rebase` 更新分支，以获得最新的主分支变更。
   - 清理提交历史，使其更加线性和易读。

### `git revert`

1. **用途**：
   - `git revert` 用于撤销某个或某些特定提交的变化。与 `git reset` 不同，它不会删除或修改提交历史，而是创建一个新的提交，将指定提交的更改反向应用。

2. **工作原理**：
   - `git revert` 创建新的提交，这些提交包含将之前提交的更改反向应用的操作。这意味着以前不想要的更改会被撤销，但所有提交记录仍然完整保留。

3. **影响**：
   - 不修改提交历史：它通过新提交的形式来“撤消”更改。
   - 保持历史完整：适用于已推送到共享分支的变更，因为不会更改提交历史，只添加新提交。

4. **常见场景**：
   - 撤销在错误开发路径上所做的不当提交，而不影响历史。
   - 回滚某个特定功能或修复由于某个提交引发的问题。

### 总结

- 使用 `git rebase` 可以重整和整理提交历史，是一种更具侵略性的变更方式，适用于团队协作前的历史清理。
- 使用 `git revert` 可以保持提交历史的完整性，适用于需要撤销变更但不能破坏现有提交历史的情景。

在选择使用哪一个时，请考虑团队的协作方式和代码历史的重要性。通常在公共分支上推荐使用 `git revert`，而在个人开发分支上可以使用 `git rebase`。