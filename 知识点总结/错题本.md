## 输出题

<img src="assets/4A47A0DB6E60853DEDFCFDF08A5CA249.png" alt="4A47A0DB6E60853DEDFCFDF08A5CA249" style="zoom:67%;" />

### 总结

```javascript
getName()
var getName = () => console.log(4);
function getName() {
	console.log(5);
}
getName()
//5
//4
```



函数声明会被变量声明覆盖，因为`var`声明的变量在编译阶段会提升到文件顶部。

`var` 声明的变量和函数声明发生冲突时，`var` 声明的变量会覆盖函数声明（但在**提升阶段函数声明具有高优先级**）

### 1解答

当然可以！这段代码涉及到JavaScript的函数、变量声明和重载的概念。让我们逐行分析代码以及每次调用时会发生什么。

```javascript
function Func() {
    getName = () => console.log(1)
    return this;
}
Func.getName = () => console.log(2);
Func.prototype.getName = () => console.log(3);

var getName = () => console.log(4);
function getName() {
    console.log(5);
}
```

### 分析：

1. **Func 定义**: 
   - `Func`是一个函数，通过其原型（`Func.prototype`）和它本身（`Func`对象）可以分别添加属性和方法。

2. **Func.getName = () => console.log(2)**:
   - 这行代码在`Func`函数对象上添加了一个静态方法`getName`，即`Func.getName()`会输出`2`。

3. **Func.prototype.getName = () => console.log(3)**:
   - 这行代码在`Func`的原型上定义了`getName`方法。这将影响到所有`Func`的实例，但不影响`Func`本身。

4. **var getName = () => console.log(4);**:
   - 这里定义了一个变量`getName`，它指向一个箭头函数，输出`4`。
   - **注意:** 下面`function getName()`函数声明会被变量声明覆盖，因为`var`声明的变量在编译阶段会提升到文件顶部。

5. **function getName() { console.log(5); }**:
   - 这个函数在本地作用域被`var getName`覆盖，所以不会被调用。

### 执行调用结果：

1. **Func.getName()**:
   - 直接调用`Func`对象上的`getName`方法，输出`2`。

2. **getName()**:
   - 由于`var getName = () => console.log(4);`覆盖了`function getName()`声明，因此这里调用的是变量`getName`中的箭头函数，输出`4`。

3. **Func().getName()**:
   - 执行`Func()`，它将一个没有用`var`、`let`、或`const`关键字定义的`getName`设为`console.log(1)`，实际改变了全局环境中的`getName`。
   - 紧接着`Func()`返回了`this`，在全局上下文中`this`是`window`（或`global`对象在Node.js中），所以这里尝试在全局上下文中调用`getName()`。
   - **最后**：这次调用实际上是在改变全局上下文的`getName`变量，输出`1`。

4. **getName()**:
   - 经过先前调用`Func()`的赋值操作，全局的`getName`已经被重新定义为`console.log(1)`。因此，第4次输出是`1`。

结合以上分析，最终的输出顺序是：2、4、1、1。

### 2解答

当然可以！我们可以逐行查看这段代码，并解释每行输出背后的原因。

先分析一下所有的代码：

```javascript
function Func() {
	getName = () => console.log(1)
	return this;
}
Func.getName = () => console.log(2);
Func.prototype.getName = () => console.log(3);

var getName = () => console.log(4);
function getName() {
	console.log(5);
}
Func.getName()
getName()
Func().getName()
getName()
```

1. 先声明了函数 `Func`，在函数内部定义了一个箭头函数 `getName`，并将其赋值为打印1的函数。同时返回了 `this`。

2. 接着定义了 `Func` 的一个静态方法（也被称为类方法）， `Func.getName`，它会打印2。

3. 然后在 `Func` 的原型上添加了一个方法 `getName`，它会打印3。

4. 声明了一个变量 `getName`，它是一个箭头函数，打印4。

5. 接下来声明了一个同名函数 `getName()`，打印5。但是要注意，在 `var` 声明的变量和函数声明发生冲突时，`var` 声明的变量会覆盖函数声明（但在提升阶段函数声明具有高优先级）。

然后是两种情况分别调用这些函数：

```javascript
Func.getName()
```

这里调用的是 `Func` 的静态方法，所以会打印2。

```javascript
getName()
```

`getName` 有两个定义：一个是作为函数的声明，另一个是作为变量的箭头函数。在变量声明之前，函数声明会生效；但在变量声明之后，变量赋值会覆盖函数声明。因此输出4。

```javascript
Func().getName()
```

调用 `Func()` 会执行 `Func` 函数体中的代码，这会将全局的 `getName` 改为 `() => console.log(1)`。 然后返回 `this` (在浏览器环境中，顶层的 `this` 是 `window`)，接下来调用 `window.getName()`，这里的 `getName` 已经被赋值为打印1的函数，所以会打印1。

```javascript
getName()
```

此时的 `getName` 已经被 `Func()` 调用时的那个赋值操作影响，因此再次调用时输出还是1。

总结一下输出顺序：

1. `Func.getName()` 打印2
2. `getName()` 打印4
3. `Func().getName()` 打印1
4. `getName()` 打印1

所以最终的输出结果是：

```
2
4
1
1
```

## 为什么执行Func()后,全局的getName函数会变成Func内部的这个箭头函数

这是因为在`Func`函数内部，你没有使用`var`、`let`或`const`关键字来声明`getName`，而直接使用`getName = () => console.log(1);`这样的赋值语句。在JavaScript中，当你在函数内这样赋值一个变量且未在函数中用`var`、`let`或`const`声明时，该变量会被隐式地添加到全局对象（浏览器中的`window`对象或Node.js中的`global`对象）上。

具体过程是这样的：

1. **`Func()`函数执行**: 当你调用`Func()`时，JavaScript引擎会在函数内部找到`getName = () => console.log(1);`这行代码。

2. **检查变量声明**: JavaScript会检查当前的作用域（这里是`Func()`内）有没有局部变量`getName`。
   - 如果使用`var`、`let`或`const`声明了`getName`，那`getName`会是一个局部变量。
   - 但这里没有使用这些关键字，所以没有在本地作用域中找到声明。

3. **作用到全局对象**: 因此，JavaScript解释器会将`getName`绑定到全局对象上。
   - 可以把这个过程想象成`window.getName = () => console.log(1);`（在浏览器环境下）。

这就是为什么全局`getName`变成了`Func`内部定义的箭头函数结果的原因。这种行为是JavaScript的一个常见陷阱，它可能会引发意外的全局变量定义，也被称作“隐式全局”，一般建议在严格模式（`'use strict';`）下编写代码来避免此类问题。严格模式下，这样的赋值会导致错误，从而避免将变量意外地提升到全局作用域。