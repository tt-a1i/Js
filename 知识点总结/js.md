## 了解ts吗,ts的特点,比js好在哪里

TypeScript是由Microsoft开发的一种开源的、面向对象的编程语言，是JavaScript的一个超集，设计目标是为了解决JavaScript在大型应用程序开发中的局限性，尤其是类型系统的缺失。

1. **`静态类型系统`**： TypeScript引入了`静态类型检查机制`，这意味着`在编译阶段就能捕获类型错误`，而非等到运行时才发现问题。开发者在编写代码时就需要声明变量、函数参数和返回值的类型，从而提前发现潜在的问题，增加代码的健壮性。
2. **`类型推断`**： TypeScript不仅要求显式声明类型，还支持类型推断，可以`根据上下文自动推导`出变量的类型，减轻了开发者的负担。
3. **`面向对象编程特性`**： TypeScript引入了`类`（Class）、`接口`（Interface）、``泛型``（Generics）等面向对象编程的关键特性，使得构建复杂的应用架构更加方便和直观。
4. **`模块系统`**： TypeScript`支持ES6的模块化系统`，`允许将代码组织成可重用的模块`，这对于大型项目来说尤其重要，有助于提升代码的可维护性和扩展性。
5. **工具友好**： TypeScript的编译器能够生成清晰易读的JavaScript代码，并与许多流行的IDE和编辑器集成良好，提供丰富的代码补全、类型检查以及导航功能，极大地提升了开发效率和代码质量。
6. **未来前瞻**： TypeScript支持并鼓励使用最新的和即将发布的JavaScript特性，让开发者能够在稳定版本发布之前就能够尝试和利用这些新特性。
7. **适合大型项目**： TypeScript的`类型安全性非常适合大型和长期维护的项目`，通过强制类型约束，可以更好地管理软件复杂度，使得重构更容易、bug更少，而且随着项目规模的增长，维护成本相对较低。

## 说说var、let、const之间的区别

1. **作用域：**
   - `var`：`var` 声明的变量具有`函数作用域`（function scope），`即在声明它的函数内部有效`。如果在`函数内`部使用 `var` 声明的变量，则在`函数外部无法访问`。
   - `let` 和 `const`：`let` 和 `const` 声明的变量具有`块级作用域`（block scope），即在声明它的块（如 `{}`）内部有效。`块级作用域可以是函数、循环、条件语句等`任意代码块。
2. **变量提升（hoisting）：**
   - `var`：`var` 声明的变量存在变量提升，即在`代码执行之前`会被`提升`到`函数或全局作用域`的`顶部`。这意味着可以在声明之前访问 `var` 声明的变量，但其值为 `undefined`。
   - `let` 和 `const`：`let` 和 `const` 声明的变量`也存在变量提升`，`但它们不会被初始化`，因此在声明之前访问会导致 ReferenceError,`暂时性死区`。
3. **重复声明：**
   - `var`：可以`重复声明`同名的变量，不会报错，而且后面的声明会`覆盖前面的声明`。
   - `let` 和 `const`：`不允许`在同一作用域内重复声明同名的变量，否则会报错。
4. **可变性：**
   - `var` 和 `let`：声明的变量是`可变的`（mutable），可以重新赋值。
   - `const`：声明的变量是`不可变的`（immutable），一旦被赋值就不能再修改其值。但对于`复合类型（如对象和数组）`，其`内部的属性或元素是可变`的。
5. **声明时机：**
   - `var`：在` ES5` 中引入，是旧的声明变量的方式。
   - `let` 和 `const`：在 `ES6`（ES2015）中引入，是新的声明变量的方式，提供了更好的作用域控制和变量声明方式。

## ES6中数组新增了哪些扩展？

1. **Array.from() 方法：** `Array.from()` 方法可以`将类数组对象或可迭代对象转换为真正的数组`。它接受一个类数组对象或可迭代对象作为参数，并`返回一个新的数组`。

   ```javascript
   const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
   const newArray = Array.from(arrayLike); // ['a', 'b', 'c']
   ```

2. **Array.of() 方法：** `Array.of()` 方法用于`创建一个新数组`，它接受任意数量的参数，并将这些参数作为数组的元素，`返回一个新的数组`。

   ```javascript
   const newArray = Array.of(1, 2, 3); // [1, 2, 3]
   ```

3. **Array.prototype.find() 和 Array.prototype.findIndex() 方法：** `find()` 方法用于查找数组中满足条件的第一个元素，`findIndex()` 方法用于查找数组中满足条件的第一个元素的索引。

   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const found = numbers.find(num => num > 3); // 4
   const foundIndex = numbers.findIndex(num => num > 3); // 3
   ```

4. **Array.prototype.fill() 方法：** `fill()` 方法用于`填充`数组的所有元素，可以指定起始位置和结束位置。

   ```javascript
   const array = [1, 2, 3, 4, 5];
   array.fill(0, 2, 4); // [1, 2, 0, 0, 5]
   ```

5. **Array.prototype.includes() 方法：** `includes()` 方法用于检查数组中是否包含指定的元素，返回`布尔值。`

   ```javascript
   const array = [1, 2, 3, 4, 5];
   const isIncluded = array.includes(3); // true
   ```

6. **扩展运算符（Spread Operator）：** 扩展运算符 `...` 可以在`数组字面量中用来展开数组`，或者在`函数`调用时用来`传递参数`。

   ```javascript
   const array1 = [1, 2, 3];
   const array2 = [...array1, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]
   
   function sum(a, b, c) {
       return a + b + c;
   }
   
   const numbers = [1, 2, 3];
   const result = sum(...numbers); // 6
   ```

#### entries()，keys()，values()

`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

## 对象新增了哪些扩展？

1. **对象属性的简洁表示法：**如果对象的属性和变量名相同，可以省略属性名。
2. **计算属性名：** 在对象字面量中，属性名可以使用表达式来定义。
3. **对象方法的简写语法：**定义对象的方法时可以省略 function 关键字。
4. **Object.assign() 方法：** 用于将所有可枚举的属性从一个或多个源对象复制到目标对象，并返回目标对象。
5. `this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的`关键字super`，指向当前对象的原型对象
6. 解构赋值,`解构赋值必须是最后一个参数`，否则会报错,解构赋值是`浅拷贝`

```javascript
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
```

##### Object.is()

严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身

## ES6中函数新增了哪些扩展

`ES6`允许为函数的参数设置默认值

```javascript
function log(x, y = 'World') {
  console.log(x, y);
}
```

函数的形参是默认声明的，不能使用`let`或`const`再次声明

```js
function foo(x = 5) {
    let x = 1; // error
    const x = 2; // error
}
```

参数默认值可以与解构赋值的默认值结合起来使用

```js
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```

##### **箭头函数中的 this：** 

箭头函数没有自己的 `this`，它们的 `this` 值继承自外围作用域。

##### 严格模式

只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

## Set和Map

`Set`是一种叫做`集合`的数据结构，`Map`是一种叫做`字典`的数据结构

#### 什么是集合？什么又是字典？

- `集合`
  是由一堆无序的、相关联的，且`不重复`的内存结构【数学中称为元素】组成的组合
- `字典`
  是一些元素的集合。`每个元素有一个称作key 的域`，`不同元素的key 各不相同`

#### 区别？

- `共同点`：集合、字典`都可以存储不重复的值`
- `不同点`：`集合是以[值，值]`的形式存储元素，`字典是以[键，值]`的形式存储

#### `Set`的实例关于增删改查的方法：

- add()
- delete()
- has()
- clear()

#### `Map` 结构的实例针对增删改查有以下属性和操作方法：

- size 属性
- set()
- get()
- has()
- delete()
- clear()

#### 都有的遍历方法

- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回所有成员的遍历器
- forEach()：遍历 Map 的所有成员

#### `WeakSet` 和 `WeakMap`

`WeakSet` 和 `WeakMap` 主要用于`存储对象的弱引用`，`适用于`需要`临时存储对象`，且不希望妨碍这些对象被垃圾回收的场景。

共同特点:

- **只能使用对象作为键：** 的键必须是对象，不能是原始值。
- **弱引用：** 键是弱引用的，当键对象被垃圾回收时，相应的键值对会自动从 中删除。
- **不可迭代：**不支持迭代方法（如 `forEach`），因此不能遍历其中的键值对。
- **无法知道大小：** 没有 `size` 属性，也没有类似 `size` 的方法，因此无法知道其中包含的键值对数量。

## Promise

异步编程的一种解决方案，主要用于`解决回调地狱`（callback hell）和提供`更优雅的异步编程`解决方案。比传统的解决方案（回调函数）更加合理和更加强大

`promise`解决异步操作的优点：

- 链式操作减低了编码难度
- 代码可读性明显增强

#### Promise 的特点：

1. **状态（State）：** `Promise` 对象有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。
2. **状态转换：** `Promise` 对象的状态一旦改变，就会凝固，不会再改变。只有异步操作的结果可以决定状态的转变。
3. **链式调用：** `Promise` 支持链式调用，可以将多个异步操作按照顺序串联起来，避免回调地狱，使代码更加清晰和易于维护。
4. **错误处理：** `Promise` 允许通过 `.catch()` 方法捕获异步操作中的错误，并进行统一的错误处理。
5. **多个异步操作的并行和串行：** `Promise.all()` 方法可以将多个异步操作并行执行，直到所有操作完成；`Promise.race()` 方法可以将多个异步操作串行执行，只要有一个操作完成就返回结果。

#### 使用场景

将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化

## async和await

`async` 和 `await` 并不是直接的语法糖，而是`建立在 Promise 和 Generator 的基础上的语法糖`

`async` 和 `await` 是 ES8（也称为 ES2017）引入的新特性，用于更方便地处理异步操作，使得异步代码的编写和理解更加简洁和直观。

`async` 函数是用来定义异步函数的关键字，它可以将函数声明为异步函数，使得函数内部可以使用 `await` 来等待异步操作的结果。

- `async` 函数内部使用 `return` 返回的值会被包装成一个 Promise 对象，并且 `async` 函数总是返回一个 Promise 对象。
- 在 `async` 函数内部可以使用 `await` 关键字来等待 Promise 对象的完成，并且 `await` 只能在 `async` 函数内部使用。

------

`await` 是用于等待异步操作完成的关键字，它只能在 `async` 函数内部使用。当 `await` 后面跟着一个 Promise 对象时，它会暂停函数的执行，直到该 Promise 对象状态变为 resolved（完成）或 rejected（失败）。

- `await` 表达式会暂停异步函数的执行，直到 `await` 后面的 Promise 对象返回结果。
- 如果 `await` 后面的 Promise 对象状态为 resolved，则 `await` 表达式返回 Promise 对象的 resolved 值。
- 如果 `await` 后面的 Promise 对象状态为 rejected，则 `await` 表达式会抛出错误，可以使用 `try...catch` 来捕获错误。

使用场景

- **简化异步操作：** `async` 和 `await` 可以简化异步操作的编写，使得异步代码更加清晰和易于理解，避免了回调地狱。
- **错误处理：** `await` 可以与 `try...catch` 结合使用来捕获异步操作中的错误，使得错误处理更加方便。
- **串行/并行操作：** `await` 可以按照顺序执行异步操作，也可以使用 `Promise.all()` 来并行执行多个异步操作。

## ES6中的Proxy

`Proxy` 是一种用于`创建代理对象`的特殊对象，它可以`拦截并定义基本操作的自定义行为`，例如属性查找、赋值、删除等操作。`Proxy` 可以用来`拦截对目标对象的访问`，并在必要时`修改目标对象的行为`。

#### Proxy 的特点：

1. **拦截操作：** `Proxy` 可以拦截目标对象的各种操作，包括属性的读取（get）、属性的设置（set）、属性的删除（deleteProperty）、属性的枚举（enumerate）、函数调用（apply）等。
2. **自定义行为：** 通过在代理对象上设置拦截器（handler），可以定义对应操作的自定义行为，使得可以对目标对象的操作进行定制化处理。
3. **可扩展性：** `Proxy` 提供了一种灵活且可扩展的方式来操作和定制对象的行为，使得可以实现更加复杂的逻辑和功能。

#### 使用场景：

1. **属性验证和过滤：** 可以使用 `Proxy` 对象拦截属性的赋值操作，在`赋值之前进行验证和过滤`，以确保属性的合法性。
2. **数据绑定和响应式编程：** 可以使用 `Proxy` 对象`实现数据的双向绑定和响应式编程`，`监听`目标对象的`变化`并`自动更新相关的视图`。
3. **拦截操作和记录日志：** 可以使用 `Proxy` 对象`拦截目标对象的各种操作`，并在拦截器中`记录日志`、统计调用次数等信息。
4. **性能优化：** 可以使用 `Proxy` 对象拦截目标对象的访问，并对访问进行`缓存或优化`，以提高程序的性能和效率。`缓存`某些计算结果或`重复访问的数据`,`延迟加载数据`，只在`真正需要访问时`才进行加载和`初始化`
5. **权限控制：** 可以使用 `Proxy` 对象实现对目标对象的访问权限控制，限制用户对特定属性或方法的访问权限。限制某些属性只读或只写，或者禁止对某些属性的访问

## ES6中Module

模块（Module）是一种用于`组织和管理 `JavaScript 代码的方式，它提供了一种`模块化的编程风格`，使得代码可以`更加清晰、可维护和可重用`。

#### 模块的特点：

1. **独立性：** `每个模块都是独立的作用域`，模块内部的变量、函数和类默认不会暴露到全局作用域，需要通过 `export` 导出才能被其他模块使用。
2. **导入导出：** 模块可以通过 `export` 关键字导出变量、函数、类等，使得这些成员可以被其他模块使用；同时，可以使用 `import` 关键字导入其他模块导出的成员，使得模块之间可以相互调用和引用。
3. **静态解析：** 模块系统是静态的，即在代码执行之前就确定了模块之间的依赖关系和引用关系，使得代码的依赖关系更加清晰和可靠。
4. **可重用性：** 模块化的编程风格使得代码可以`更容易地被重用和组合`，从而提高了代码的可维护性和可扩展性。

#### 使用场景：

1. **项目组织：** 可以使用`模块来组织项目的代码结构`，将代码分`割成独立的模块`，使得每个模块只关注于特定的功能或责任，提高了代码的可维护性和可读性。
2. **代码复用：** 可以`将通用的功能封装成模块`，并在`需要的地方导入和使用`，避免了重复编写相似的代码，提高了代码的复用性和效率。
3. **依赖管理：** 模块系统提供了依赖管理的机制，可以明确地`声明和管理模块之间的依赖关系`，使得项目的依赖关系更加清晰和可控。
4. **库和插件：** 可以`将自己编写的功能模块封装成库或插件`，并在其他项目中引入和使用，从而`实现功能的共享和扩展`。

## ES6中的 Decorator 

- 代码可读性变强了，装饰器命名相当于一个注释
- 在不改变原有代码情况下，对原来功能进行扩展

#### 装饰器的特点：

1. **语法糖：** 装饰器提供了一种更简洁、更直观的语法来实现对类和类成员的装饰，使得`代码更加清晰`和易于理解。
2. **可组合性：** 装饰器`可以串联使用`，多个装饰器可以按照顺序应用到同一个目标上，从而实现更复杂的装饰逻辑。
3. **动态修改：** 装饰器可以在运行时动态地修改类和类成员的行为，使得可以根据需要进行灵活的定制和调整。
4. **可重用性：** 装饰器本身是一种函数，可以定义为独立的函数，从而可以在`多个地方重复使用`。

#### 使用场景：

1. **日志记录：** 可以使用装饰器来实现`方法调用的日志记录`，记录方法的调用时间、参数、返回值等信息。
2. **性能监控：** 可以使用装饰器来实现方法调用的`性能监控`，`统计`方法的`执行时间`、调用次数等信息。
3. **权限控制：** 可以使用装饰器来实现对方法或属性的`访问权限控制`，限制只有特定角色或权限的用户才能访问。
4. **参数校验：** 可以使用装饰器来对方法的参数进行`校验和验证`，确保参数的合法性和正确性。
5. **缓存优化：** 可以使用装饰器来实现方法调用的`结果缓存`，`避免重复计算或请求`，提高程序的性能和效率。

## JavaScript中的数据类型

- 原始类型
- 引用类型

两种类型的主要区别是：`存储位置`不同

#### 原始类型（Primitive Types）：

1. **Number（数字）：** 用于表示数值，可以是整数或浮点数。
2. **String（字符串）：** 用于表示文本数据，可以包含任意字符序列。
3. **Boolean（布尔值）：** 用于表示逻辑值，可以是 `true` 或 `false`。
4. **Undefined（未定义）：** 表示未初始化的变量或缺少值的情况。
5. **Null（空值）：** 表示空值或无效值。
6. **Symbol（符号）：** 用于创建唯一的标识符。

#### 引用类型（Reference Types）：

1. **Object（对象）：** 用于表示复杂数据结构，可以包含多个属性和方法。
2. **Array（数组）：** 特殊的对象，用于表示有序的集合数据。
3. **Function（函数）：** 特殊的对象，用于执行特定的任务或操作。
4. **Date（日期）：** 用于表示日期和时间。
5. **RegExp（正则表达式）：** 用于处理字符串的模式匹配。
6. **Map、Set：** ES6 新增的数据结构，用于存储键值对集合或唯一值集合。

#### 存储上的差别：

1. **原始类型：** 存储在`栈`内存（Stack）中，`数据直接存储在变量访问的位置`，因此访问速度较快，但大小固定且较小。
2. **引用类型：** 存储在`堆`内存（Heap）中，`变量存储的是对象的引用（地址）`，实际的数据存储在堆内存中，因此访问速度较慢，但大小可变且较大。

## 数组的常用方法

1. |     方法      | 修改原数组？ | 功能                                                         |
   | :-----------: | :----------: | ------------------------------------------------------------ |
   |    push()     |      是      | 向数组末尾添加一个或多个元素，返回数组的最新长度             |
   |     pop()     |      是      | 删除并返回数组的最后一个元素，返回被删除的项                 |
   |   unshift()   |      是      | 向数组开头添加一个或多个元素，然后返回新的数组长度           |
   |    shift()    |      是      | 删除并返回数组的第一个元素，返回被删除的项                   |
   |   concat()    |      否      | 合并两个或多个数组为一个新数组,返回新数组                    |
   |    join()     |      否      | 将数组中所有元素连接成一个字符串                             |
   |    slice()    |      否      | 返回数组的一部分，不修改原数组                               |
   |   splice()    |      是      | 添加或删除数组的元素，同时修改原数组，返回包含删除元素的数组 |
   |   indexOf()   |      否      | 返回指定元素在数组中的第一个匹配项的索引                     |
   | lastIndexOf() |      否      | 返回指定元素在数组中的最后一个匹配项的索引                   |
   |   forEach()   |      否      | 遍历数组，对每个元素执行指定操作                             |
   |     map()     |      否      | 遍历数组，对每个元素执行指定操作，并返回结果数组             |
   |   filter()    |      否      | 遍历数组，根据指定条件筛选元素                               |
   |   reduce()    |      否      | 遍历数组，将数组元素归纳为单个值                             |
   | reduceRight() |      否      | 与 reduce() 方法类似，但从右向左遍历数组                     |
   |    find()     |      否      | 返回数组中满足条件的第一个元素                               |
   |  findIndex()  |      否      | 返回数组中满足条件的第一个元素的索引                         |
   |    every()    |      否      | 检查数组中的所有元素是否满足条件                             |
   |    some()     |      否      | 检查数组中是否存在满足条件的元素                             |
   |    sort()     |      是      | 对数组元素进行排序，修改原数组                               |
   |   reverse()   |      是      | 颠倒数组中元素的顺序，修改原数组                             |

## JavaScript字符串的常用方法

1. **length：** 返回字符串的长度。
2. **charAt()：** 返回指定位置的字符。
3. **charCodeAt()：** 返回指定位置字符的 Unicode 编码。
4. **concat()：** 连接两个或多个字符串，并返回新字符串。
5. **indexOf()：** 返回指定子字符串首次出现的位置。
6. **lastIndexOf()：** 返回指定子字符串最后一次出现的位置。
7. **startsWith()：** 检查字符串是否以指定子字符串开头。
8. **endsWith()：** 检查字符串是否以指定子字符串结尾。
9. **includes()：** 检查字符串是否包含指定子字符串。
10. **substring()：** 返回指定位置之间的子字符串。
11. **slice()：** 提取字符串的一部分，并返回新字符串。
12. **substr()：** 从指定位置开始，返回指定长度的子字符串。
13. **replace()：** 替换字符串中的匹配子字符串。
14. **toUpperCase()：** 将字符串转换为大写。
15. **toLowerCase()：** 将字符串转换为小写。
16. **trim()：** 移除字符串两端的空白字符。
17. **split()：** 将字符串分割为字符串数组。
18. **match()：** 在字符串中检索指定值，返回匹配的子字符串数组。
19. **search()：** 在字符串中搜索指定值，返回匹配的位置。
20. **repeat()：** 返回包含指定字符串的指定数量副本的新字符串。

##  JavaScript 中的类型转换机制

`隐式类型转换`和`显式类型转换`

#### 隐式类型转换

- **字符串拼接**：当一个字符串与其他类型的值进行加法运算时，其他值会被自动转换为字符串。

```javascript
console.log("5" + 2); // 输出 "52"
```

- **算术运算：** 当一个非字符串值与字符串进行算术运算时，非字符串值会被自动转换为数字。

```javascript
console.log("5" - 2); // 输出 3
```

- **逻辑运算：** 当非布尔值参与逻辑运算时，会将其转换为布尔值。

```javascript
if (1) {  console.log("true"); }// 输出 "true"
```

#### 显式类型转换

- **转换为字符串：** 使用 `String()` 函数或字符串模板。
- **转换为数字：** 使用 `Number()` 函数或 `+` 操作符。
- **转换为布尔值：** 使用 `Boolean()` 函数。
- **parseInt() 和 parseFloat()：** 将字符串转换为整数或浮点数。

## == 和 ===区别，分别在什么情况使用

用于比较两个值是否相等。它们的`区别`主要在于`类型转换的方式和严格性`。

#### `==` （相等运算符，Equality Operator）：

- **类型转换：** 在进行比较之前，`会进行类型转换`，使得两个值的类型相同。
- **松散比较：** `只比较值`是否相等，`不考虑数据类型`。
- **隐式类型转换：** 可能会触发`隐式类型转换`。

#### `===` （严格相等运算符，Strict Equality Operator）：

- **类型与值都要相等：** `不会进行类型转换`，只有在类型和值都相等时才返回 true。
- **严格比较：** `区分数据类型`。
- **不触发隐式类型转换：** 不会进行隐式类型转换，`必须类型和值都相等才返回 true`。

比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符

其他情况建议一律使用全等操作符

这是因为 `null` 和 `undefined` 在`相等比较中被认为是相等的`，而`不会触发类型转换`。这种情况下，两者之间的比较会返回 `true`。

## 深拷贝浅拷贝的区别？如何实现一个深拷贝

`基本类型`数据保存在在`栈`内存中

`引用类型`数据保存在`堆`内存中，引用数据类型的变量是一个`指向堆内存中实际对象的引用`，`存在栈中`

#### 深拷贝（Deep Copy）：

深拷贝是将原始数据结构中的所有嵌套对象或数组都复制一份，而不仅仅是复制其引用。这意味着`修改拷贝后的数据结构不会影响到原始数据结构`，它们之间是相互独立的。

常见的深拷贝方式有：

- _.cloneDeep()
- jQuery.extend()
- JSON.stringify()
- 手写循环递归

#### 浅拷贝（Shallow Copy）：

浅拷贝`只是复制原始数据结构中的基本数据类型`（如数字、字符串、布尔值等）`和引用类型的引用`（即地址），`而不是复制引用类型的内容`。这意味着拷贝后的数据结构中的嵌套对象或数组仍然与原始数据结构共享相同的嵌套对象或数组，如果修改了拷贝后的数据结构中的嵌套对象或数组，原始数据结构中的对应嵌套对象或数组也会受到影响。

存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

## 闭包

1. **函数嵌套：** 闭包通常是在函数内部定义的函数，形成了函数的嵌套结构。
2. **词法作用域：** 闭包可以访问其外部函数的词法作用域中的变量，即使外部函数已经执行完毕，闭包仍然可以访问这些变量。
3. **持有外部状态：** 闭包持有了外部函数作用域中的变量的引用，使得这些变量的生命周期得以延续，即使外部函数已经执行完毕。

#### 闭包的使用场景：

**封装私有变量和函数：** 闭包可以用来创建私有变量和函数，从而隐藏实现细节，提供了一种封装数据的方式。

```javascript
function counter() {
    let count = 0;
    return function() {
        return ++count;
    };
}
let increment = counter();
console.log(increment()); // 输出 1
console.log(increment()); // 输出 2

```

**模块化开发：** 闭包可以实现模块化开发，将相关功能封装在一个函数内部，并暴露出需要对外提供的接口。

```javascript
let module = (function() {
    let privateVar = "私有变量";
    function privateFunc() {
        console.log("私有函数");
    }
    return {
        publicFunc: function() {
            console.log(privateVar);
            privateFunc();
        }
    };
})();
module.publicFunc();
```

**保存状态：** 闭包可以保存状态，比如在事件处理函数中访问到循环中的变量

```javascript
for (let i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i); // 输出 0, 1, 2, 3, 4
    }, 1000);
}
```

**实现柯里化：** 闭包可以用来实现柯里化（Currying），将`多参数函数转换成一系列单参数函数`的过程。

```javascript
function add(x) {
    return function(y) {
        return x + y;
    };
}
let add5 = add(5);
console.log(add5(3)); // 输出 8
```

## 作用域链

作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合

换句话说，作用域决定了代码区块中变量和其他资源的可见性

一般将作用域分成：

- `全局作用域`:不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
- 函数作用域
- 块级作用域

当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在`当前作用域`下去寻找该变量，如果没找到，再到它的`上层作用域`寻找，以此类推`直到找到`该变量`或是已经到了全局作用域`,如果最终仍然没有找到变量，则会抛出 `ReferenceError`。

#### 作用域链的形成过程：

1. **函数创建时：** 在 JavaScript 中，每当创建一个函数时，会同时创建一个闭包（Closure），闭包保存了函数定义时的作用域链。这个作用域链是一个指向所有父级作用域的指针列表，包括全局作用域和函数的外部作用域。
2. **函数执行时：** 当函数执行时，会创建一个活动对象（Activation Object，也称作执行上下文），其中保存了函数内部定义的所有变量和函数。同时，JavaScript 引擎会创建一个作用域链，该链包括函数的活动对象和函数定义时的作用域链。
3. **变量查找：** 当需要访问一个变量时，JavaScript 引擎会首先在当前作用域的活动对象中查找，如果找不到，则会沿着作用域链向上查找，直到找到对应的变量或到达全局作用域为止。如果最终仍然没有找到变量，则会抛出 ReferenceError。

#### 作用域链的特点：

1. **词法作用域：** `作用域链是由代码中函数的定义位置决定`的，`而不是函数被调用的位置`。这种作用域链形成方式称为`词法作用域`（Lexical Scope）。
2. **闭包的作用：**` 闭包使得函数可以访问其定义时的作用域链上的变量`，即使函数在定义时和执行时所处的上下文不同，也能够访问外部函数的变量。

## JavaScript原型，原型链

`用于实现对象之间的继承关系。`用于实现属性查找和方法继承

`每个对象拥有一个原型对象`

访问一个对象的属性时，它不仅仅在该对象上搜寻，还会`搜寻该对象的原型`，以及该对象的原型的原型，依次`层层向上搜索`，直到找到一个名字匹配的属性或到达原型链的末尾

`__proto__`作为`不同对象之间的桥梁`，用来`指向创建它的构造函数的原型对象`,

对象的原型可以通过 `__proto__` 属性来访问。

原型链的顶端是 `Object.prototype`，它是所有对象的根原型。`Object.prototype` 的 `__proto__` 属性指向 `null`，表示它是原型链的终端节点。

#### 特点：

1. **原型共享：** `JavaScript 中的原型是可以共享的`，即`多个对象可以共享同一个原型对象`。这意味着我们可以在原型上定义属性和方法，所有通过该原型创建的对象都可以访问到这些属性和方法。
2. **继承机制：** 原型链实现了 JavaScript 中的继承机制。`子对象通过原型链继承父对象的属性和方法`，从而实现了代码的重用和组合。
3. **动态性：** JavaScript 中的`原型链是动态的`，即我们`可以随时修改原型对象`，新的属性和方法会立即对通过该原型创建的对象生效。

## Javascript如何实现继承

- 继承的优点

继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码

#### 原型链继承：

通过让子类的原型指向父类的实例来实现继承。

#### 构造函数继承：

通过在子类构造函数内部调用父类构造函数来实现继承。（借助 call）

#### 组合继承：

结合原型链继承和构造函数继承的方式来实现继承。

## 谈谈this对象的理解

  表`当前执行代码的上下文对象`，具体指向的对象取决于函数调用的方式。

#### **函数调用方式决定 `this` 的指向：**

 `this` 的值是在函数调用时确定的，而不是在函数声明时确定的。它取决于函数的调用方式，可以是函数调用、方法调用、构造函数调用或者通过 `apply` 和 `call` 显式地指定。

#### **全局上下文中的 `this`：** 

在全局执行上下文中，`this` 指向全局对象，在浏览器环境中通常是 `window` 对象，在 Node.js 中是 `global` 对象。

#### **函数内部的 `this`：** 

在函数内部，`this` 的值取决于函数的调用方式。如果`函数被作为普通函数调用，this 指向全局对象`；如果函数被作为对象的方法调用，`this` 指向调用该方法的对象；如果函数被用作构造函数，`this` 指向新创建的实例对象；如果函数被用作事件处理函数，`this` 指向触发事件的元素。

#### **箭头函数中的 `this`：** 

箭头函数的 `this` 绑定在它定义时所在的上下文中，而不是在运行时确定。因此，箭头函数中的 `this` 与普通函数不同，它没有自己的 `this`，它继承了外部函数的 `this`。

#### **严格模式下的 `this`：** 

在严格模式下，全局执行上下文中的 `this` 是 `undefined`，而不是全局对象。这样做是为了防止意外的全局变量创建。

## JavaScript中执行上下文和执行栈

#### 执行上下文（Execution Context）：

执行上下文是 `JavaScript 代码执行时的环境`，包括了`当前代码的作用域、变量对象、this 指向等信息`。每当 `JavaScript 代码执行时`，都会`创建一个执行上下文`，`并将其压入执行栈中`。执行上下文可以分为全局执行上下文和函数执行上下文两种类型。

- **全局执行上下文：** 在 JavaScript 代码开始执行时，首先创建全局执行上下文。全局执行上下文是整个程序的最顶层执行上下文，它包含了全局作用域中的所有变量、函数声明和 this 指向。
- **函数执行上下文：** 每当函数被调用时，都会创建一个函数执行上下文。函数执行上下文包含了函数作用域中的所有变量、函数声明和 this 指向。

#### 执行栈（Execution Stack）：

执行栈是`用来存储执行上下文的栈结构`，也被称为`调用栈`（Call Stack）。当 JavaScript 代码`开始执行时`，首先`创建全局执行上下文`，并将其`压入执行栈中`。当`函数被调用时`，会`创建一个新的函数执行上下文`，并将其`压入执行栈的顶部`。当函数`执行完毕`时，对应的执行上下文会从执行栈中`弹出`，`控制权交给下一个`执行上下文。

执行栈遵循`先进后出（FILO）的原则`，也就是说最后进入的执行上下文会最先执行完成并从执行栈中弹出，直到执行栈为空，整个 JavaScript 代码的执行过程结束。

## 说说JavaScript中的事件模型

JavaScript 中的事件模型指的是`浏览器中的事件处理机制`，它`允许开发者在文档中的元素上注册各种类型的事件`，并定义事件发生时应该执行的代码。JavaScript 中的事件模型`基于 DOM（文档对象模型）`

#### **事件类型：** 

事件类型定义了浏览器中可能发生的各种事件，例如`点击事件、鼠标移动事件、键盘事件等`。

#### **事件目标：** 

事件目标是事件发生的对象，也就是触发事件的元素。可以`在文档中的任何元素上注册事件监听器`，当事件发生时，浏览器`会将事件传递给对应的事件目标`，并`执行相应的事件处理函数`。

#### **事件监听器**：

事件监听器是用于处理特定事件的函数，也称为事件处理函数。可以通过 DOM API（如 `addEventListener`）或者 HTML 属性（如 `onclick`）来注册事件监听器，当事件发生时，浏览器会调用相应的事件处理函数。

#### **事件流：** 

事件流描述了事件从事件目标传播到文档根节点的过程。事件流分为`捕获阶段`、`目标阶段`和`冒泡阶段`。在`捕获阶段，事件从文档根节点向事件目标传播`；在`目标阶段，事件在事件目标上触发`；在`冒泡阶段，事件从事件目标向文档根节点反向传播。`

#### 事件模型

可以分为三种：

##### 原始事件模型（DOM0级）

绑定速度快,`DOM0`级事件具有很好的跨浏览器优势

- 只支持冒泡，不支持捕获
- 同一个类型的事件只能绑定一次

##### 标准事件模型（DOM2级）

`监听器`,`冒泡`处理和`捕获`3个阶段

##### IE事件模型（基本不用）

## typeof 与 instanceof 区别

`typeof`与`instanceof`都是判断数据类型的方法，区别如下：

- `typeof`会返回一个变量的`基本类型`，`instanceof`返回的是一个`布尔值`,`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

  

- `instanceof` 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型

  - 而`typeof` 也存在弊端，检测`null`和`数组`返回都是`Object`, 它虽然可以判断基础数据类型（`null` 除外），但是引用数据类型中，除了`function` 类型以外，其他的也无法判断

如果需要通用检测数据类型，可以采用`Object.prototype.toString`，调用该方法，统一返回格式`“[object Xxx]”`的字符串

```javascript
function getType(obj){
    let type = typeof(obj);
    if(type !== 'object') return type;
    // return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');;
    return Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);
}
//typeof 特例
let a = new Number(1)
console.log(getType(new Number(1)));//Number
console.log(typeof(new Number(1)));//Object
```

## 事件代理和事件委托

事件代理和事件委托是同一个概念的不同表达方式，`指的是通过在父元素上注册事件监听器来处理子元素上的事件。`

1. 在父元素上注册事件监听器，监听特定类型的事件。
2. 当事件发生时，事件会在子元素上触发，并冒泡到父元素。
3. 父元素捕获事件，根据事件目标（即触发事件的子元素）来执行相应的处理逻辑。

#### 应用场景：

1. **动态添加元素：** 当页面中的元素是动态生成的，并且数量较多时，可以使用事件代理来简化事件处理逻辑。`只需将事件监听器绑定到父元素上`，而`不需要为每个子元素都添加事件监听器`。
2. **性能优化：** 在大型列表或表格中，如果为每个元素都添加事件监听器，可能会导致页面性能下降。使用事件代理可以`减少事件处理程序的数量`，提高页面的性能。
3. **元素重新渲染：** 在使用虚拟 DOM 技术或框架时，页面元素可能会经常重新渲染。如果直接在子元素上绑定事件监听器，每次重新渲染都需要重新绑定事件。而使用事件代理，`只需在父元素上绑定一次事件监听器，不受元素重新渲染的影响`。
4. **节省内存：** 在特定情况下，使用事件代理可以节省内存。因为`事件处理程序只需绑定到一个父元素上，而不是多个子元素上，减少了内存消耗`。

## new操作符具体干了什么

`new`操作符用于创建一个给定构造函数的实例对象

- 创建一个新的对象`obj`
- 将对象与构建函数通过原型链连接起来
- 将构建函数中的`this`绑定到新建的对象`obj`上
- 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理

## Ajax

即异步的`JavaScript` 和`XML`是一种创建交互式网页应用的网页开发技术，可以在`不重新加载`整个网页的情况下，与`服务器交换数据`，并且`更新部分网页`

`Ajax`的原理简单来说通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`JavaScript`来操作`DOM`而更新页面

浏览器可以发送`HTTP`请求后，接着做其他事情，等收到`XHR`返回来的数据再进行操作

**异步通信：** AJAX 使用 JavaScript 发起 HTTP 请求，并在后台与服务器进行异步通信，不会阻塞页面的加载和渲染。

**XMLHttpRequest 对象：** AJAX 使用 XMLHttpRequest 对象来实现与服务器的交互。这个对象允许客户端发送 HTTP 请求和接收服务器响应。

**事件驱动：** AJAX 通过事件驱动的方式处理服务器响应，当服务器响应返回时，会触发相应的事件（如 `onreadystatechange` 事件），从而执行相应的回调函数处理响应数据。

#### AJAX 的实现步骤：

1. **创建 XMLHttpRequest 对象：** 在 JavaScript 中创建一个 XMLHttpRequest 对象，用于发起 HTTP 请求。

2. **设置回调函数：** 使用 `onreadystatechange` 属性设置一个回调函数，用于处理服务器响应。

3. **打开和发送请求：** 使用 `open` 方法设置请求方法（GET、POST 等）、请求地址和是否异步等参数，然后使用 `send` 方法发送请求。

4. **处理服务器响应：** 当接收到服务器响应时，会触发 `onreadystatechange` 事件，此时可以通过 `readyState` 和 `status` 属性来判断请求状态，通过 `responseText` 或 `responseXML` 属性来获取服务器响应数据，然后在回调函数中处理数据并更新页面。

5. ```javascript
   // 创建 XMLHttpRequest 对象
   var xhr = new XMLHttpRequest();
   
   // 设置回调函数
   xhr.onreadystatechange = function() {
       if (xhr.readyState === 4 && xhr.status === 200) {
           // 处理服务器响应数据
           console.log(xhr.responseText);
       }
   };
   
   // 打开和发送请求
   xhr.open('GET', 'https://api.example.com/data', true);
   xhr.send();
   
   ```

## bind、call、apply 区别

`bind`、`call` 和 `apply` 都是 JavaScript 中用于`改变函数执行上下文`的方法

- 三者都可以改变函数的`this`对象指向
- 三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`
- 三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入
- `bind`是返回绑定this之后的函数，`apply`、`call` 则是立即执行

##### 实现一个Bind

```javascript
Function.prototype.myBind = function (context) {
    var self = this; // 保存原函数的引用
    var args = Array.prototype.slice.call(arguments, 1); // 获取除 context 外的参数

    return function () { // 返回一个新函数
        var bindArgs = Array.prototype.slice.call(arguments); // 获取新函数的参数
        return self.apply(context, args.concat(bindArgs)); // 使用 apply 执行原函数，将 context 和参数合并传入
    };
};
```

## 正则表达式

在 `JavaScript`中，正则表达式也是对象

计思想是用一种描述性的语言定义一个规则

构建正则表达式有两种方式

- 字面量创建，其由包含在斜杠之间的模式组成

  ```javascript
  const re = /\d+/g;
  ```

- 调用`RegExp`对象的构造函数

  ```javascript
  const re = new RegExp("\\d+","g");
  
  const rul = "\\d+"
  const re1 = new RegExp(rul,"g");
  ```

#### 特点

1. **灵活性：** 正则表达式可以描述各种复杂的字符串模式，包括字符、数字、特殊符号等。
2. **强大的匹配能力：** 正则表达式可以匹配多种字符组合，包括连续字符、单词、数字等。
3. **通用性：** 正则表达式是跨平台、跨语言的，几乎所有的编程语言都支持正则表达式。

#### 应用场景：

1. **字符串匹配：** 可以用于搜索文本中特定模式的字符串。
2. **数据验证：** 可以用于验证用户输入的数据格式是否符合要求，例如邮箱、电话号码等。
3. **字符串替换：** 可以用于将文本中特定模式的字符串替换为其他内容。
4. **文本提取：** 可以用于从文本中提取特定格式的信息，例如从网页中提取链接、标题等。
5. **日志分析：** 可以用于分析日志文件中特定格式的信息。

## 事件循环

事件循环（Event Loop）是 `JavaScript 运行时环境中的一种机制`，用于`处理异步任务和事件处理`,`实现单线程非阻塞`。在 JavaScript 中，单线程的执行模型意味着所有的代码都是按顺序执行的，不能同时处理多个任务。但是，`JavaScript 又支持异步编程`，例如通过`定时器`、`事件监听`、`Promise` 等方式`实现的异步操作`。`事件循环机制就是用来管理和调度这些异步任务的执行顺序`。

`同步任务`进入`主线程`，即`主执行栈`，`异步任务`进入`任务队列`，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环

#### 异步任务还可以细分为微任务与宏任务

- 宏列队: 用来保存待执行的`宏任务`(回调), 比如: `定时器回调`/`DOM 事件回调`/`ajax 回调`
- 微列队: 用来保存待执行的`微任务`( 回调), 比如:` promise` 的回调/`MutationObserver` 的回调

*JS 执行时会区别这2 个队列*

　　*JS 引擎`首先必须先执行`所有的`初始化同步任务代码`*

　　每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出**执行**

**promise是微任务优先于定时器执行**



常见的宏任务有：

- script (可以理解为外层同步代码)
- setTimeout/setInterval
- UI rendering/UI事件
- postMessage、MessageChannel
- setImmediate、I/O（Node.js）



`async`是用来声明一个异步方法，而 `await`是用来等待异步方法执行, `async`函数返回一个`promise`对象

不管`await`后面跟着的是什么，`await`都会阻塞后面的代码

##### 示例

```javascript
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('settimeout')
})
async1()
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')
```

最后的结果是：`script start`、`async1 start`、`async2`、`promise1`、`script end`、`async1 end`、`promise2`、`settimeout`

```javascript
async function fn1 (){
    console.log(1)
    await fn2()
    console.log(2) // 阻塞
}

async function fn2 (){
    console.log('fn2')
}

fn1()
console.log(3)
```

执行结果: `1` `fn2` `3` `2`

## 常见Dom操作

#### 什么是dom

DOM（Document Object Model，`文档对象模型`）是一种`用于表示和操作网页文档的编程接口`。它`将整个 HTML 或 XML 文档表示为一个树状结构`，其中`每个节点都是文档中的一个元素、属性或文本`。通过 DOM，可以使用编程方式访问、操作和修改网页的内容、结构和样式

#### 主要特点：

1. **树状结构：** DOM 将文档表示为一个`树状结构`，由多个节点组成，包括元素节点、文本节点、属性节点等。
2. **对象模型：** DOM 将文档中的`每个部分都表示为一个对象`，通过操作这些对象可以实现对文档内容、结构和样式的控制。
3. **平台和语言无关：** DOM 是`与平台和语言无关的标准`，因此`可以在各种编程语言和平台上使用`，例如 JavaScript、Python、Java 等。
4. **动态性：** 由于 DOM 可以通过编程方式修改，因此`可以实现动态地更新页面内容、结构和样式`。

#### 常见的 DOM 操作

1. **获取元素：**
   - `document.getElementById()`: 根据元素的 id 获取元素对象。
   - `document.getElementsByClassName()`: 根据类名获取元素对象集合。
   - `document.getElementsByTagName()`: 根据标签名获取元素对象集合。
   - `document.querySelector()`: 根据 CSS 选择器获取第一个匹配的元素对象。
   - `document.querySelectorAll()`: 根据 CSS 选择器获取所有匹配的元素对象集合。
2. **创建元素：**
   - `document.createElement()`: 创建新的元素节点。
   - `document.createTextNode()`: 创建新的文本节点。
3. **插入、删除和替换元素：**
   - `parentNode.appendChild()`: 将一个新的子节点添加到指定节点的子节点列表的末尾。
   - `parentNode.removeChild()`: 从父节点中移除一个子节点。
   - `parentNode.replaceChild()`: 用一个新的节点替换父节点中的一个子节点。
   - `parentNode.insertBefore()`: 在指定的已有子节点之前插入新的子节点。
4. **修改元素的属性和样式：**
   - `element.setAttribute()`: 设置元素的属性值。
   - `element.getAttribute()`: 获取元素的属性值。
   - `element.style.property`: 直接设置元素的 CSS 样式。
   - `element.classList.add()`: 添加一个类名到元素的类列表中。
   - `element.classList.remove()`: 从元素的类列表中移除一个类名。
   - `element.classList.toggle()`: 如果元素的类列表中存在指定的类名，则删除它；如果不存在，则添加它。
5. **事件处理：**
   - `element.addEventListener()`: 绑定事件监听器。
   - `element.removeEventListener()`: 移除事件监听器。
   - `element.onclick`: 直接设置元素的点击事件处理函数。
6. **获取和修改元素内容：**
   - `element.innerHTML`: 获取或设置元素的 HTML 内容。
   - `element.innerText`: 获取或设置元素的文本内容。
   - `element.textContent`: 获取或设置元素的纯文本内容。

## BOM

#### 什么是BOM

BOM（Browser Object Model，`浏览器对象模型`）是 `JavaScript 中`用于`操作浏览器窗口和浏览器本身的一组对象`。它`提供了一系列的对象和方法`，`用于获取和控制浏览器窗口`、`导航`、历史记录、屏幕信息等。

`Bom`的核心对象是`window`，它表示浏览器的一个实例

浏览器中，`window`对象有双重角色，即是浏览器窗口的一个接口，又是全局对象

因此所有在全局作用域中声明的变量、函数都会变成`window`对象的属性和方法

#### 常见的 BOM 对象：

1. **window 对象：** 代表浏览器窗口，是 BOM 中的核心对象，包含了很多属性和方法，例如 `window.location`、`window.document`、`window.alert()` 等。
2. **navigator 对象：** 包含有关浏览器的信息，例如浏览器类型、版本、操作系统等，常用属性有 `navigator.userAgent`、`navigator.platform`。
3. **screen 对象：** 包含有关用户屏幕的信息，例如屏幕宽度、高度、像素深度等，常用属性有 `screen.width`、`screen.height`、`screen.availWidth` 等。
4. **history 对象：** 用于操作浏览器的历史记录，可以前进、后退、跳转到指定页面等，常用方法有 `history.back()`、`history.forward()`、`history.go()`。
5. **location 对象：** 包含有关当前 URL 的信息，可以用于获取和修改浏览器的当前地址，常用属性有 `location.href`、`location.pathname`、`location.search`、`location.hash` 等。
6. **document 对象：** 代表当前网页的文档，可以用于操作网页中的元素、样式、内容等，常用方法有 `document.getElementById()`、`document.createElement()`、`document.querySelector()` 等。
7. **event 对象：** 包含有关当前事件的信息，例如事件的类型、目标元素等，常用属性有 `event.type`、`event.target`。
8. **XMLHttpRequest 对象：** 用于在后台与服务器交换数据，可以实现异步加载数据，常用于 AJAX 请求。

## JavaScript 中内存泄漏的几种情况

JavaScript 中的内存泄漏指的是程序中`不再需要的内存仍然被占用`，`无法被及时释放`，`最终导致内存占用过高或者持续增长`，影响程序性能和稳定性。

Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，`执行环境会负责管理代码执行过程中使用的内存`

两种方式:

- 标记清理
- 引用计数

#### 常见的引起内存泄漏的情况

1. **未释放的引用：** `当一个对象不再被使用，但仍然被其他对象持有引用`，导致对象无法被垃圾回收器识别和释放。这种情况通常发生在循环引用、闭包、事件绑定等场景中。
2. **定时器未清理：** 如果定时器未被正确清理或者重复设置，会导致定时器中的回调函数一直存在引用，即使不再需要，也无法被垃圾回收器回收。
3. **DOM 节点未移除：** 当页面上的 DOM 节点被移除或者替换时，如果没有及时清理相关的事件监听器、数据绑定等，会导致 DOM 节点及其相关的对象无法被释放。
4. **全局变量未销毁：** 如果全局变量不再需要但没有被及时销毁，会一直存在于内存中，无法被回收。
5. **闭包：** 闭包中的变量在函数执行完毕后依然存在于内存中，如果闭包中引用了大量的外部变量或者其他对象，可能导致内存泄漏。
6. **缓存：** `缓存数据未被正确管理`，如果缓存过多或者缓存时间过长，会占用大量内存，导致内存泄漏。

## Javascript本地存储的方式有哪些？区别及应用场景？

- cookie
- sessionStorage
- localStorage
- indexedDB

#### cookie

为了解决 `HTTP`无状态导致的问题

- **特点：** Cookie 是一小段数据，由服务器发送到浏览器并保存在本地，`每次请求时都会被发送`到服务器。Cookie `可以设置过期时间`，`可以跨域名访问`，但每个 Cookie 的大小通常受到限制。
- **应用场景：** 适合存储小量的`用户信息`、`会话标识`等，例`如用户登录状态`、`用户偏好设置`等。

#### **Web Storage（LocalStorage 和 SessionStorage）**

- 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的
- 存储的信息在同一域中是共享的
- 当本页操作（新增、修改、删除）了`localStorage`的时候，本页面不会触发`storage`事件,但是别的页面会触发`storage`事件。
- 大小：`5M（跟浏览器厂商有关系）`
- `localStorage`本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
- 受同源策略的限制
- 存储在 Session 对象中的变量将不会丢失，而是`在整个用户会话中一直存在下去`
- 作用范围不同，`Cookie 保存在客户端`（浏览器），`Session 保存在服务器端`
- 存取方式的不同，`Cookie 只能保存 ASCII`，`Session 可以存任意数据类型`，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- `Cookie 只能保存 ASCII`，`Session 可以存任意数据类型`

**应用场景：** 适合`存储大量的用户数据`、`本地缓存`、`Web 应用的状态`等，例`如用户偏好`设置、`表单数据`、缓存的页面内容等。

**两个缺点：**

- `无法`像`Cookie`一样`设置过期时间`
- `只能存入字符串`，`无法直接存对象`

SessionStorage 数据`只在当前会话有效`，`页面关闭后就会被清除`。

#### indexedDB

- **特点：** IndexedDB 是一个`浏览器提供的本地数据库`，`允许存储大量结构化数据`，并提供强大的查询和索引功能。IndexedDB 是`异步操作`，`可以在后台处理大量数据`。
- **应用场景：** `适合存储大量结构化的数据`，例如`离线应用数据`、`复杂的客户端缓存`、大规模数据的本地存储等。

## 函数式编程

函数式编程是一种"编程范式"（programming paradigm），一种编写程序的方法论

主要的编程范式有三种：`命令式编程`，`声明式编程`和`函数式编程`

函数式编程更加`强调程序执行的结果`而非执行的过程，

#### 命令式编程（Imperative Programming）：

- **特点：**
  - 通过编写一系列的命令和指令来描述程序的执行过程。
  - 程序员需要关注程序的具体实现细节，指定每一步的执行过程。
  - 强调如何实现某个目标，而不仅仅是描述目标是什么。
- **示例：** 典型的命令式编程语言包括 C、C++、Java 等，例如使用循环、条件语句、变量赋值等来控制程序流程。

#### 声明式编程（Declarative Programming）：

- **特点：**
  - 强调描述问题的解决方案，而不是解决问题的步骤。
  - 程序员关注需要实现的目标，而不是具体的执行过程。
  - 更关注问题的本质和解决方案的逻辑，而不是实现细节。
- **示例：** SQL 是声明式编程的一个典型例子，通过简单的 SQL 查询语句描述数据查询操作，而不需要指定具体的执行过程。

#### 函数式编程（Functional Programming）：

- **特点：**
  - 将计算视为数学函数的求值，强调使用纯函数和不可变数据结构来进行编程。
  - 函数是一等公民，可以作为参数传递、返回值返回，支持高阶函数和函数组合。
  - 避免了状态变量和可变数据，强调无副作用的函数调用。
- **示例：** 函数式编程语言如 Haskell、Scala、Clojure 等，以及在 JavaScript 中采用函数式编程范式编写的代码，例如使用 map、filter、reduce 等高阶函数进行数据处理。

#### 区别：

1. **实现方式：**` 命令式编程关注如何实现目标`，`以具体的步骤和指令描述程序执行过程`；`声明式编程`关注`描述目标的解决方案`，`以描述性的语句表达解决方案`；函数式编程则将计算视为函数的求值，避免了状态变量和可变数据。
2. **抽象程度：** 函数式编程是声明式编程的一种，它更强调抽象和高级概念，通过函数组合和高阶函数实现更高层次的抽象；而命令式编程更侧重于底层细节和具体实现。
3. **可变性：** 命令式编程和一些声明式编程方式（如部分的函数式编程）通常允许可变数据和状态变量，而函数式编程强调不可变性和纯函数的使用。

## 函数缓存

函数缓存，就是`将函数运算过的结果进行缓存`

本质上就是`用空间（缓存存储）换时间（计算过程）`

常用于缓存数据计算结果和缓存对象

实现函数缓存主要依靠`闭包、柯里化、高阶函数`



实现原理也很简单，把参数和对应的结果数据存在一个对象中，`调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结果`

```javascript
const memoize = function (func, content) {
  let cache = Object.create(null)
  content = content || this
  return (...key) => {
    if (!cache[key]) {
      cache[key] = func.apply(content, key)
    }
    return cache[key]
  }
}
const calc = memoize(add);
const num1 = calc(100,200)
const num2 = calc(100,200) // 缓存得到的结果
```

#### 应用场景

1. **计算密集型任务：** 对于需要进行复杂计算的函数，如果函数的输入参数相同，那么输出结果也是相同的，可以通过函数缓存来避免重复计算，提高性能。
2. **网络请求：** 对于需要从服务器获取数据的函数，如果请求参数相同，可以缓存服务器返回的结果，避免重复请求，提高响应速度。
3. **数据处理：** 对于数据处理函数，如果需要对大量数据进行处理，可以缓存处理过的数据，避免重复操作，提高效率。
4. **递归函数：** 对于递归函数，可以使用函数缓存来存储已经计算过的中间结果，避免重复计算，提高效率。

## Javascript 数字精度

JavaScript 中，数字精度丢失问题是由于采用` IEEE 754 标准的双精度浮点数表示法`所导致的

#### 解决方法：

1. **使用整数进行计算：** 将需要进行精确计算的小数转换为整数进行计算，计算完成后再转换回小数。
2. **使用精确计算库：** 可以使用第三方的精确计算库，如 BigNumber.js、decimal.js 等，这些库提供了精确的十进制数值运算，避免了浮点数的精度问题。
3. **四舍五入或截断处理：** 对于需要显示的小数结果，可以使用四舍五入或截断处理来控制小数点后的位数，避免显示过多的小数位数。
4. **避免直接比较：** 在进行数字比较时，避免直接使用等号判断两个浮点数是否相等，而是采用误差范围的方式进行比较。
5. **使用 ECMAScript 6 的新特性：** ECMAScript 6 引入了 BigInt 类型，用于表示任意精度的整数，可以避免大整数的精度问题。

```javascript
// 使用整数进行计算示例
function add(x, y) {
  const precision = Math.pow(10, 4); // 精度，此处为保留四位小数
  const result = Math.round((x * precision + y * precision) / precision);
  return result / precision;
}

console.log(add(0.1, 0.2)); // 输出 0.3
```

## 8种数据类型

1. Undefined（未定义）
2. Null（空值）
3. Boolean（布尔值）
4. Number（数字）
5. String（字符串）
6. Symbol（符号）
7. BigInt（大整数）
8. Object（对象）

## 防抖和节流

本质上是`优化高频率执行代码`的一种手段

如浏览器的 `resize`、`scroll`、`keypress`、`mousemove` 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 **防抖（debounce）** 和 **节流（throttle）** 的方式来减少调用频率

#### 防抖（Debouncing）：

防抖是指`在一段连续触发事件结束后，只执行一次函数`。`如果在指定的时间间隔内又触发了该事件`，则`重新开始计时`，`直到再次触发事件结束`。

#### 节流（Throttling）：

节流是指`在一段时间内，只执行一次函数`。如果在`指定的时间间隔内多次触发了该事件`，则`忽略后续的触发`，`直到时间间隔过去后再次触发`。

#### 区别：

- **执行时机不同：** `防抖是在事件结束后执行一次函数`，而`节流是在固定时间间隔内执行一次函数`。
- **执行频率不同：** `防抖可以确保函数只会执行一次`，而`节流可以控制函数在一定时间内的执行频率`。

#### 应用场景

##### 防抖在连续的事件，只需触发一次回调的场景有：

- **搜索框实时搜索**：当用户在搜索框中快速连续输入时，不需要在每次输入时立即发起搜索请求，而是等待用户停止输入一段短暂时间（比如300毫秒）后才发起请求，以减少对服务器的压力和带宽消耗。
- **窗口大小调整**（Window Resize）：当用户快速调整浏览器窗口大小时，如果不做防抖处理，resize事件会被频繁触发，这可能会导致大量不必要的计算和布局重排。通过防抖，可以确保在窗口大小稳定后才执行布局计算和渲染。
- **表单验证**：在用户连续修改表单字段时，不需要每次键入后都立即验证表单，而是等到用户停顿后再验证。

##### 节流应用场景

- **页面滚动事件（Scroll Event）**：在无限滚动加载的页面中，不需要每滚动一点点就触发加载更多数据的操作，而是设置一个时间间隔，例如每滚动停止500毫秒后才触发加载事件，既能及时响应用户的滚动行为，又能避免过于频繁的后台请求。
- **鼠标连续移动事件（MouseMove Event）**：在某些情况下，无需实时响应鼠标每一点微小的移动，只需要在一定时间间隔内（如每100毫秒）取最近一次移动事件坐标进行处理。

```javascript
// 防抖
function debounce(fn, delay) {
    let timer;
    return function(...args) {
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    }
}

// 节流
function throttle(fn, delay) {
    let timer = null;
    return function(...args) {
        if (!timer) {
            fn.apply(this, args);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    }
}
```



## 如何判断一个元素是否在可视区域中

1. 获取目标元素的位置和尺寸信息。
2. 获取窗口（视口）的滚动位置和尺寸信息。
3. 计算目标元素的位置是否在可视区域内。

## 大文件上传如何做断点续传

1. **分片：** 将大文件`分割成多个小文件块`（分片），每个文件块大小合适，一般为几百 KB 到几 MB。可以使用前端或后端分片，`前端分片可以减轻服务器压力`，`后端分片可以更好地控制上传进度`。
2. **上传：** 将`分割后的文件块依次上传到服务器`。可以采用多线程或并行上传提高上传速度，同时确保上传过程中的文件块顺序正确。
3. **记录上传进度：** 在上传过程中，记录每个文件块的上传状态（已上传或未上传）、上传位置（已上传的字节数）、上传时间等信息，以便在上传中断后恢复上传进度。
4. **断点续传：** 如果上传过程中发生中断，可以根据记录的上传进度信息，从中断处开始继续上传未完成的文件块，而不需要重新上传已上传的部分。可以在客户端或服务器端实现断点续传逻辑，客户端实现更灵活，但服务器端实现更可靠。
5. **合并文件：** 当所有文件块上传完成后，服务器端将所有文件块合并成完整的文件。在合并过程中，需要检查每个文件块的完整性和顺序，确保合并后的文件与原始文件一致。
6. **清理资源：** 上传完成后，清理临时文件和记录的上传进度信息，释放资源，确保系统稳定性和安全性。

- `网络环境较差`：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part
- `流式上传`：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在`视频监控`等行业应用中比较常见

## 单点登录？如何实现？

SSO的定义是在`多个应用系统中`，用户`只需要登录一次`就可以`访问所有相互信任的应用系统`

当一个系统成功登录以后，`passport`将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被`passport`授权以后，会`建立一个局部会话`，在一定时间内可以无需再次向`passport`发起认证

#### 实现步骤

1. **用户登录：** 用户在身份验证系统中进行登录，身份验证系统验证用户的凭据，并`生成一个令牌`。
2. **令牌颁发：** 身份验证系统将生成的令牌发送给用户的浏览器，或者将令牌存储在身份验证服务器中。
3. **令牌验证：** 用户`访问其他应用程序时，这些应用程序会发送身份验证请求到身份验证系统`，并提供之前生成的令牌。
4. **验证令牌：** 身份验证系统验证接收到的令牌的有效性，包括令牌是否过期、签名是否有效等。
5. **授权访问：** 如果令牌有效，身份验证系统根据令牌中的用户身份信息决定是否允许用户访问应用程序，如果允许，则向应用程序返回授权响应。
6. **访问应用程序：** 用户可以访问被授权的应用程序，应用程序可以根据令牌中的用户信息来提供个性化的服务或内容

## web常见的攻击方式有哪些？如何防御？

- **跨站脚本攻击（XSS）：** 攻击者注入恶意脚本到 Web 页面中，当用户浏览页面时执行这些脚本，从而盗取用户信息、会话标识或篡改页面内容。
- **SQL 注入攻击：** 攻击者通过在 Web 应用程序的输入字段中插入 SQL 查询语句，从而获得对数据库的未授权访问权限，可以窃取敏感数据或破坏数据库。
- **跨站请求伪造攻击（CSRF）：** 攻``击者伪造用户在 Web 应用程序上的请求``，以用户身份执行未经授权的操作，例如转账、更改密码等。
- **点击劫持攻击：** 攻击者将透明的、恶意的页面叠加在合法页面上，并诱使用户在不知情的情况下执行恶意操作，例如点击一个隐藏的按钮。
- **DDoS 攻击：** 分布式拒绝服务（DDoS）攻击旨在通过向目标系统发送大量的请求来耗尽其资源，使其无法响应正常用户的请求。
- **文件上传漏洞：** 攻击者利用文件上传功能上传恶意文件到 Web 服务器上，可能导致服务器受到攻击、文件泄露或恶意代码执行等问题。

为了防御这些攻击，可以采取以下措施：

1. **输入验证和过滤：** 对用户输入进行严格的验证和过滤，防止恶意输入注入到系统中。
2. **输出编码：** 在将用户输入显示到页面上之前，对其进行适当的编码，以防止 XSS 攻击。
3. **参数化查询：** 使用参数化查询或预编译语句来执行数据库查询，以防止 SQL 注入攻击。
4. **CSRF Token：** `在敏感操作中使用 CSRF Token 来防止跨站请求伪造攻击`。
5. **点击劫持防御：** 设置 X-Frame-Options 标头，以防止页面被嵌套到 iframe 中，从而防止点击劫持攻击。
6. **网络安全策略：** 配置网络安全策略（例如防火墙、入侵检测系统），及时检测和阻止 DDoS 攻击。
7. **文件上传限制：** 对用户上传的文件进行严格的类型和大小限制，并在服务器端对上传的文件进行安全扫描。
8. **定期安全审计和更新：** 定期进行安全审计，及时更新系统和库，修补已知漏洞，保持系统的安全性和稳定性。

## Session

session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，`session就是一个对象`，用于`存储信息`。 

## JS字符串和数组的区别

1. **字符串（String）**：
   - 字符串是一组由零个或多个字符组成的有序序列。
   - 字符串中的每个字符`可以通过索引来访问`，索引从0开始，例如 `str[0]` 表示字符串中的第一个字符。
   - `字符串是不可变的（immutable），即一旦创建，就不能修改其内容。任何对字符串的修改都会返回一个新的字符串。`
   - 字符串可以使用单引号、双引号或者模板字符串（反引号）来表示。
2. **数组（Array）**：
   - 数组是一组有序的数据集合，可以包含任意类型的数据，包括字符串、数字、对象等。
   - 数组中的每个元素可以通过索引来访问，索引从0开始，例如 `arr[0]` 表示数组中的第一个元素。
   - `数组是可变的（mutable）`，即可以通过添加、删除或修改元素来改变数组的内容。
   - 数组提供了丰富的方法和属性来操作和管理数据，如 `push()`、`pop()`、`splice()`、`concat()`、`slice()` 等。

## 网页出现卡顿,怎么排查怎么解决

1. **检查`网络和服务器`**：
   - 网络延迟或服务器响应时间过长可能会导致网页加载缓慢或卡顿。使用网络工具（如浏览器开发者工具的 Network 标签）检查网络请求和响应时间，并确保服务器性能良好。
2. **检查`代码质量`**：
   - 大量的`无效代码、冗余代码、重复代码、死循环`或者复杂的算法可能会导致网页运行缓慢。通过代码审查和性能分析工具（如Chrome DevTools的Performance标签）来检查和优化代码。
3. **优化`页面渲染`**：
   - 复杂的DOM结构、大量的DOM操作、频繁的重绘和重排可能会导致页面渲染性能下降。优化CSS样式，`减少不必要的DOM操作`，`使用 CSS 动画而不是 JavaScript 动画`，尽量减少频繁更新 DOM。
4. **`压缩和合并`资源**：
   - 优化网页加载速度，可以`压缩和合并 JavaScript、CSS、图片等静态资源`，减少网络请求次数，提高加载速度。
5. **使用`懒加载`**：
   - 对于大型网页或者包含大量图片的网页，可以使用懒加载技术，延迟加载图片或者其他资源，减少首次加载时的压力。
6. **使用`缓存`**：
   - `合理使用浏览器缓存和服务器缓存，减少不必要的重复请求，提高网页加载速度`。
7. **`处理大量数据`**：
   - 如果网页需要处理大量数据，可以`考虑使用分页、虚拟滚动`等技术，`减少一次性加载大量数据`导致的性能问题。
8. **浏览器`兼容性`**：
   - 不同浏览器可能对同一段代码的性能表现有所差异，需要进行跨浏览器测试，并针对性地进行优化。
9. **`硬件加速`**：
   - 对于一些复杂的动画或者渲染效果，可以考虑使用硬件加速，通过 CSS 属性 `transform` 或者 `opacity` 触发 `GPU 加速`，提高动画性能。
10. **使用`服务端渲染`（SSR）**：
    - 对于需要大量计算或者复杂逻辑的页面，可以考虑使用`服务端渲染来提高网页的性能`和加载速度。

## css包大怎么处理

1. **`代码优化`**：
   - 检查 CSS 代码，`删除不必要的样式和规则`，减少冗余和重复的代码。
   - 使用压缩工具（例如CSS压缩器）`对CSS文件进行压缩`，减少文件大小。
   - 将大型的`CSS文件拆分成多个小文件，按需加载`，减少单个文件的大小和加载时间。
2. **使用 `CSS 预处理器`**：
   - 使用 CSS 预处理器（如`Sass、Less`等）可以提高CSS代码的可维护性，并通过`使用变量、嵌套、混合等功能来减少重复代码量`。
   - 预处理器可以帮助你更好地组织和管理 CSS 代码，同时生成压缩的 CSS 输出。
3. **`图像优化`**：
   - 对于使用了大量图像的网页，可以使用`图像压缩工具`（如ImageOptim、TinyPNG等）来减少图像文件的大小，从而减少 CSS 包的大小。
   - 考虑使用 `CSS Sprites 技术将多个小图标合并成一张大图`，`减少 HTTP 请求`次数。
4. **使用`字体子集`**：
   - 如果网页中使用了自定义字体，可以考虑使用字体子集（Font Subset）来仅包含页面所需的字符，减少字体文件的大小。
5. **`模块化开发`**：
   - 使用模块化开发工具（如Webpack、Parcel等）来`对 CSS 进行模块化管理和打包`，`只打包页面所需的 CSS 文件`，减少冗余和不必要的代码。
6. **`CDN 加速`**：
   - 使用内容分发网络（CDN）来`加速 CSS 文件的加载`，提高网页的访问速度。
7. **`缓存和资源优化`**：
   - 合理设置缓存策略，利用`浏览器缓存和服务器缓存`来`减少重复加载 CSS 文件的次数`。
   - 将CSS文件放置在静态资源服务器上，通过优化服务器配置来提高文件的传输速度。

## 排序算法有哪些,时间复杂度多少

| 算法     | 最快时间复杂度 | 最慢时间复杂度 | 平均时间复杂度 | 空间复杂度 | 简单介绍                                                     |
| -------- | :------------: | :------------: | :------------: | :--------: | :----------------------------------------------------------- |
| 冒泡排序 |      O(n)      |     O(n^2)     |     O(n^2)     |    O(1)    | 通过比较相邻元素，将较大的元素逐步“冒泡”到数组的末尾。       |
| 选择排序 |     O(n^2)     |     O(n^2)     |     O(n^2)     |    O(1)    | 从未排序部分选择最小（或最大）元素并放入已排序部分。         |
| 插入排序 |      O(n)      |     O(n^2)     |     O(n^2)     |    O(1)    | 将元素逐个插入已排序的部分，以构建有序数组。                 |
| 快速排序 |    O(nlogn)    |     O(n^2)     |    O(nlogn)    |  O(logn)   | 使用分治法将数组划分为较小的子数组，然后递归地排序子数组。   |
| 归并排序 |    O(nlogn)    |    O(nlogn)    |    O(nlogn)    |    O(n)    | 将数组分成两半，递归地排序每一半，然后合并两个有序子数组。   |
| 堆排序   |    O(nlogn)    |    O(nlogn)    |    O(nlogn)    |    O(1)    | 使用堆数据结构，将数组视为完全二叉树，然后进行排序。         |
| 希尔排序 | 取决于步长选择 | 取决于步长选择 | 取决于步长选择 |    O(1)    | 通过多次插入排序，每次使用不同的步长，逐渐改进数组的有序性。 |
| 基数排序 |    O(logRB)    |    O(logRB)    |    O(logRB)    |   O(RB)    | 按照位数（个位、十位、百位等）对数字进行排序，从低位到高位。 |

## [HMR] Waiting for update signal from WDS...

1. **HMR**：全称为 Hot Module Replacement（热模块替换）。这是一种技术，允许开发者在应用运行时替换、添加或删除模块，而无需完全重新加载页面。这大大提高了开发效率，因为你可以实时看到更改的效果。
2. **WDS**：全称为 Webpack Dev Server（Webpack  开发服务器）。这是一个小型的 Express 服务器，它使用 webpack 与浏览器进行通信，并且利用 sockjs  提供实时重载功能。它主要用于在开发期间提供 assets（由 webpack 构建）。

![image-20240424150054247](D:\Js\assets\image-20240424150054247.png)
