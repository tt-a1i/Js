## 了解ts吗,ts的特点,比js好在哪里

TypeScript是由Microsoft开发的一种开源的、面向对象的编程语言，是JavaScript的一个超集，设计目标是为了解决JavaScript在大型应用程序开发中的局限性，尤其是类型系统的缺失。

1. **`静态类型系统`**： TypeScript引入了`静态类型检查机制`，这意味着`在编译阶段就能捕获类型错误`，而非等到运行时才发现问题。开发者在编写代码时就需要声明变量、函数参数和返回值的类型，从而提前发现潜在的问题，增加代码的健壮性。
2. **`类型推断`**： TypeScript不仅要求显式声明类型，还支持类型推断，可以`根据上下文自动推导`出变量的类型，减轻了开发者的负担。
3. **`面向对象编程特性`**： TypeScript引入了`类`（Class）、`接口`（Interface）、``泛型``（Generics）等面向对象编程的关键特性，使得构建复杂的应用架构更加方便和直观。
4. **`模块系统`**： TypeScript`支持ES6的模块化系统`，`允许将代码组织成可重用的模块`，这对于大型项目来说尤其重要，有助于提升代码的可维护性和扩展性。
5. **工具友好**： TypeScript的编译器能够生成清晰易读的JavaScript代码，并与许多流行的IDE和编辑器集成良好，提供丰富的代码补全、类型检查以及导航功能，极大地提升了开发效率和代码质量。
6. **未来前瞻**： TypeScript支持并鼓励使用最新的和即将发布的JavaScript特性，让开发者能够在稳定版本发布之前就能够尝试和利用这些新特性。
7. **适合大型项目**： TypeScript的`类型安全性非常适合大型和长期维护的项目`，通过强制类型约束，可以更好地管理软件复杂度，使得重构更容易、bug更少，而且随着项目规模的增长，维护成本相对较低。

## 说说var、let、const之间的区别

1. **作用域：**
   - `var`：`var` 声明的变量具有`函数作用域`（function scope），`即在声明它的函数内部有效`。如果在`函数内`部使用 `var` 声明的变量，则在`函数外部无法访问`。
   - `let` 和 `const`：`let` 和 `const` 声明的变量具有`块级作用域`（block scope），即在声明它的块（如 `{}`）内部有效。`块级作用域可以是函数、循环、条件语句等`任意代码块。
2. **变量提升（hoisting）：**
   - `var`：`var` 声明的变量存在变量提升，即在`代码执行之前`会被`提升`到`函数或全局作用域`的`顶部`。这意味着可以在声明之前访问 `var` 声明的变量，但其值为 `undefined`。
   - `let` 和 `const`：`let` 和 `const` 声明的变量`也存在变量提升`，`但它们不会被初始化`，因此在声明之前访问会导致 ReferenceError,`暂时性死区`。
3. **重复声明：**
   - `var`：可以`重复声明`同名的变量，不会报错，而且后面的声明会`覆盖前面的声明`。
   - `let` 和 `const`：`不允许`在同一作用域内重复声明同名的变量，否则会报错。
4. **可变性：**
   - `var` 和 `let`：声明的变量是`可变的`（mutable），可以重新赋值。
   - `const`：声明的变量是`不可变的`（immutable），一旦被赋值就不能再修改其值。但对于`复合类型（如对象和数组）`，其`内部的属性或元素是可变`的。
5. **声明时机：**
   - `var`：在` ES5` 中引入，是旧的声明变量的方式。
   - `let` 和 `const`：在 `ES6`（ES2015）中引入，是新的声明变量的方式，提供了更好的作用域控制和变量声明方式。

## ES6中数组新增了哪些扩展？

1. **Array.from() 方法：** `Array.from()` 方法可以`将类数组对象或可迭代对象转换为真正的数组`。它接受一个类数组对象或可迭代对象作为参数，并`返回一个新的数组`。

   ```javascript
   const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
   const newArray = Array.from(arrayLike); // ['a', 'b', 'c']
   ```

2. **Array.of() 方法：** `Array.of()` 方法用于`创建一个新数组`，它接受任意数量的参数，并将这些参数作为数组的元素，`返回一个新的数组`。

   ```javascript
   const newArray = Array.of(1, 2, 3); // [1, 2, 3]
   ```

3. **Array.prototype.find() 和 Array.prototype.findIndex() 方法：** `find()` 方法用于查找数组中满足条件的第一个元素，`findIndex()` 方法用于查找数组中满足条件的第一个元素的索引。

   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const found = numbers.find(num => num > 3); // 4
   const foundIndex = numbers.findIndex(num => num > 3); // 3
   ```

4. **Array.prototype.fill() 方法：** `fill()` 方法用于`填充`数组的所有元素，可以指定起始位置和结束位置。

   ```javascript
   const array = [1, 2, 3, 4, 5];
   array.fill(0, 2, 4); // [1, 2, 0, 0, 5]
   ```

5. **Array.prototype.includes() 方法：** `includes()` 方法用于检查数组中是否包含指定的元素，返回`布尔值。`

   ```javascript
   const array = [1, 2, 3, 4, 5];
   const isIncluded = array.includes(3); // true
   ```

6. **扩展运算符（Spread Operator）：** 扩展运算符 `...` 可以在`数组字面量中用来展开数组`，或者在`函数`调用时用来`传递参数`。

   ```javascript
   const array1 = [1, 2, 3];
   const array2 = [...array1, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]
   
   function sum(a, b, c) {
       return a + b + c;
   }
   
   const numbers = [1, 2, 3];
   const result = sum(...numbers); // 6
   ```

#### entries()，keys()，values()

`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

## 对象新增了哪些扩展？

1. **对象属性的简洁表示法：**如果对象的属性和变量名相同，可以省略属性名。
2. **计算属性名：** 在对象字面量中，属性名可以使用表达式来定义。
3. **对象方法的简写语法：**定义对象的方法时可以省略 function 关键字。
4. **Object.assign() 方法：** 用于将所有可枚举的属性从一个或多个源对象复制到目标对象，并返回目标对象。
5. `this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的`关键字super`，指向当前对象的原型对象
6. 解构赋值,`解构赋值必须是最后一个参数`，否则会报错,解构赋值是`浅拷贝`

```javascript
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
```

##### Object.is()

严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身

## ES6中函数新增了哪些扩展

`ES6`允许为函数的参数设置默认值

```javascript
function log(x, y = 'World') {
  console.log(x, y);
}
```

函数的形参是默认声明的，不能使用`let`或`const`再次声明

```js
function foo(x = 5) {
    let x = 1; // error
    const x = 2; // error
}
```

参数默认值可以与解构赋值的默认值结合起来使用

```js
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```

##### **箭头函数中的 this：** 

箭头函数没有自己的 `this`，它们的 `this` 值继承自外围作用域。

##### 严格模式

只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

## Set和Map

`Set`是一种叫做`集合`的数据结构，`Map`是一种叫做`字典`的数据结构

#### 什么是集合？什么又是字典？

- `集合`
  是由一堆无序的、相关联的，且`不重复`的内存结构【数学中称为元素】组成的组合
- `字典`
  是一些元素的集合。`每个元素有一个称作key 的域`，`不同元素的key 各不相同`

#### 区别？

- `共同点`：集合、字典`都可以存储不重复的值`
- `不同点`：`集合是以[值，值]`的形式存储元素，`字典是以[键，值]`的形式存储

#### `Set`的实例关于增删改查的方法：

- add()
- delete()
- has()
- clear()

#### `Map` 结构的实例针对增删改查有以下属性和操作方法：

- size 属性
- set()
- get()
- has()
- delete()
- clear()

#### 都有的遍历方法

- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回所有成员的遍历器
- forEach()：遍历 Map 的所有成员

#### `WeakSet` 和 `WeakMap`

`WeakSet` 和 `WeakMap` 主要用于`存储对象的弱引用`，`适用于`需要`临时存储对象`，且不希望妨碍这些对象被垃圾回收的场景。

共同特点:

- **只能使用对象作为键：** 的键必须是对象，不能是原始值。
- **弱引用：** 键是弱引用的，当键对象被垃圾回收时，相应的键值对会自动从 中删除。
- **不可迭代：**不支持迭代方法（如 `forEach`），因此不能遍历其中的键值对。
- **无法知道大小：** 没有 `size` 属性，也没有类似 `size` 的方法，因此无法知道其中包含的键值对数量。

## Promise

异步编程的一种解决方案，主要用于`解决回调地狱`（callback hell）和提供`更优雅的异步编程`解决方案。比传统的解决方案（回调函数）更加合理和更加强大

`promise`解决异步操作的优点：

- 链式操作减低了编码难度
- 代码可读性明显增强

#### Promise 的特点：

1. **状态（State）：** `Promise` 对象有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。
2. **状态转换：** `Promise` 对象的状态一旦改变，就会凝固，不会再改变。只有异步操作的结果可以决定状态的转变。
3. **链式调用：** `Promise` 支持链式调用，可以将多个异步操作按照顺序串联起来，避免回调地狱，使代码更加清晰和易于维护。
4. **错误处理：** `Promise` 允许通过 `.catch()` 方法捕获异步操作中的错误，并进行统一的错误处理。
5. **多个异步操作的并行和串行：** `Promise.all()` 方法可以将多个异步操作并行执行，直到所有操作完成；`Promise.race()` 方法可以将多个异步操作串行执行，只要有一个操作完成就返回结果。

#### 使用场景

将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化

## async和await

`async` 和 `await` 并不是直接的语法糖，而是`建立在 Promise 和 Generator 的基础上的语法糖`

`async` 和 `await` 是 ES8（也称为 ES2017）引入的新特性，用于更方便地处理异步操作，使得异步代码的编写和理解更加简洁和直观。

`async` 函数是用来定义异步函数的关键字，它可以将函数声明为异步函数，使得函数内部可以使用 `await` 来等待异步操作的结果。

- `async` 函数内部使用 `return` 返回的值会被包装成一个 Promise 对象，并且 `async` 函数总是返回一个 Promise 对象。
- 在 `async` 函数内部可以使用 `await` 关键字来等待 Promise 对象的完成，并且 `await` 只能在 `async` 函数内部使用。

------

`await` 是用于等待异步操作完成的关键字，它只能在 `async` 函数内部使用。当 `await` 后面跟着一个 Promise 对象时，它会暂停函数的执行，直到该 Promise 对象状态变为 resolved（完成）或 rejected（失败）。

- `await` 表达式会暂停异步函数的执行，直到 `await` 后面的 Promise 对象返回结果。
- 如果 `await` 后面的 Promise 对象状态为 resolved，则 `await` 表达式返回 Promise 对象的 resolved 值。
- 如果 `await` 后面的 Promise 对象状态为 rejected，则 `await` 表达式会抛出错误，可以使用 `try...catch` 来捕获错误。

使用场景

- **简化异步操作：** `async` 和 `await` 可以简化异步操作的编写，使得异步代码更加清晰和易于理解，避免了回调地狱。
- **错误处理：** `await` 可以与 `try...catch` 结合使用来捕获异步操作中的错误，使得错误处理更加方便。
- **串行/并行操作：** `await` 可以按照顺序执行异步操作，也可以使用 `Promise.all()` 来并行执行多个异步操作。

## ES6中的Proxy

`Proxy` 是一种用于`创建代理对象`的特殊对象，它可以`拦截并定义基本操作的自定义行为`，例如属性查找、赋值、删除等操作。`Proxy` 可以用来`拦截对目标对象的访问`，并在必要时`修改目标对象的行为`。

#### Proxy 的特点：

1. **拦截操作：** `Proxy` 可以拦截目标对象的各种操作，包括属性的读取（get）、属性的设置（set）、属性的删除（deleteProperty）、属性的枚举（enumerate）、函数调用（apply）等。
2. **自定义行为：** 通过在代理对象上设置拦截器（handler），可以定义对应操作的自定义行为，使得可以对目标对象的操作进行定制化处理。
3. **可扩展性：** `Proxy` 提供了一种灵活且可扩展的方式来操作和定制对象的行为，使得可以实现更加复杂的逻辑和功能。

#### 使用场景：

1. **属性验证和过滤：** 可以使用 `Proxy` 对象拦截属性的赋值操作，在`赋值之前进行验证和过滤`，以确保属性的合法性。
2. **数据绑定和响应式编程：** 可以使用 `Proxy` 对象`实现数据的双向绑定和响应式编程`，`监听`目标对象的`变化`并`自动更新相关的视图`。
3. **拦截操作和记录日志：** 可以使用 `Proxy` 对象`拦截目标对象的各种操作`，并在拦截器中`记录日志`、统计调用次数等信息。
4. **性能优化：** 可以使用 `Proxy` 对象拦截目标对象的访问，并对访问进行`缓存或优化`，以提高程序的性能和效率。`缓存`某些计算结果或`重复访问的数据`,`延迟加载数据`，只在`真正需要访问时`才进行加载和`初始化`
5. **权限控制：** 可以使用 `Proxy` 对象实现对目标对象的访问权限控制，限制用户对特定属性或方法的访问权限。限制某些属性只读或只写，或者禁止对某些属性的访问

## ES6中Module

模块（Module）是一种用于`组织和管理 `JavaScript 代码的方式，它提供了一种`模块化的编程风格`，使得代码可以`更加清晰、可维护和可重用`。

#### 模块的特点：

1. **独立性：** `每个模块都是独立的作用域`，模块内部的变量、函数和类默认不会暴露到全局作用域，需要通过 `export` 导出才能被其他模块使用。
2. **导入导出：** 模块可以通过 `export` 关键字导出变量、函数、类等，使得这些成员可以被其他模块使用；同时，可以使用 `import` 关键字导入其他模块导出的成员，使得模块之间可以相互调用和引用。
3. **静态解析：** 模块系统是静态的，即在代码执行之前就确定了模块之间的依赖关系和引用关系，使得代码的依赖关系更加清晰和可靠。
4. **可重用性：** 模块化的编程风格使得代码可以`更容易地被重用和组合`，从而提高了代码的可维护性和可扩展性。

#### 使用场景：

1. **项目组织：** 可以使用`模块来组织项目的代码结构`，将代码分`割成独立的模块`，使得每个模块只关注于特定的功能或责任，提高了代码的可维护性和可读性。
2. **代码复用：** 可以`将通用的功能封装成模块`，并在`需要的地方导入和使用`，避免了重复编写相似的代码，提高了代码的复用性和效率。
3. **依赖管理：** 模块系统提供了依赖管理的机制，可以明确地`声明和管理模块之间的依赖关系`，使得项目的依赖关系更加清晰和可控。
4. **库和插件：** 可以`将自己编写的功能模块封装成库或插件`，并在其他项目中引入和使用，从而`实现功能的共享和扩展`。

## ES6中的 Decorator 

- 代码可读性变强了，装饰器命名相当于一个注释
- 在不改变原有代码情况下，对原来功能进行扩展

#### 装饰器的特点：

1. **语法糖：** 装饰器提供了一种更简洁、更直观的语法来实现对类和类成员的装饰，使得`代码更加清晰`和易于理解。
2. **可组合性：** 装饰器`可以串联使用`，多个装饰器可以按照顺序应用到同一个目标上，从而实现更复杂的装饰逻辑。
3. **动态修改：** 装饰器可以在运行时动态地修改类和类成员的行为，使得可以根据需要进行灵活的定制和调整。
4. **可重用性：** 装饰器本身是一种函数，可以定义为独立的函数，从而可以在`多个地方重复使用`。

#### 使用场景：

1. **日志记录：** 可以使用装饰器来实现`方法调用的日志记录`，记录方法的调用时间、参数、返回值等信息。
2. **性能监控：** 可以使用装饰器来实现方法调用的`性能监控`，`统计`方法的`执行时间`、调用次数等信息。
3. **权限控制：** 可以使用装饰器来实现对方法或属性的`访问权限控制`，限制只有特定角色或权限的用户才能访问。
4. **参数校验：** 可以使用装饰器来对方法的参数进行`校验和验证`，确保参数的合法性和正确性。
5. **缓存优化：** 可以使用装饰器来实现方法调用的`结果缓存`，`避免重复计算或请求`，提高程序的性能和效率。

## JavaScript中的数据类型

- 原始类型
- 引用类型

两种类型的主要区别是：`存储位置`不同

#### 原始类型（Primitive Types）：

1. **Number（数字）：** 用于表示数值，可以是整数或浮点数。
2. **String（字符串）：** 用于表示文本数据，可以包含任意字符序列。
3. **Boolean（布尔值）：** 用于表示逻辑值，可以是 `true` 或 `false`。
4. **Undefined（未定义）：** 表示未初始化的变量或缺少值的情况。
5. **Null（空值）：** 表示空值或无效值。
6. **Symbol（符号）：** 用于创建唯一的标识符。

#### 引用类型（Reference Types）：

1. **Object（对象）：** 用于表示复杂数据结构，可以包含多个属性和方法。
2. **Array（数组）：** 特殊的对象，用于表示有序的集合数据。
3. **Function（函数）：** 特殊的对象，用于执行特定的任务或操作。
4. **Date（日期）：** 用于表示日期和时间。
5. **RegExp（正则表达式）：** 用于处理字符串的模式匹配。
6. **Map、Set：** ES6 新增的数据结构，用于存储键值对集合或唯一值集合。

#### 存储上的差别：

1. **原始类型：** 存储在`栈`内存（Stack）中，`数据直接存储在变量访问的位置`，因此访问速度较快，但大小固定且较小。
2. **引用类型：** 存储在`堆`内存（Heap）中，`变量存储的是对象的引用（地址）`，实际的数据存储在堆内存中，因此访问速度较慢，但大小可变且较大。

## 数组的常用方法

1. |     方法      | 修改原数组？ | 功能                                                         |
   | :-----------: | :----------: | ------------------------------------------------------------ |
   |    push()     |      是      | 向数组末尾添加一个或多个元素，返回数组的最新长度             |
   |     pop()     |      是      | 删除并返回数组的最后一个元素，返回被删除的项                 |
   |   unshift()   |      是      | 向数组开头添加一个或多个元素，然后返回新的数组长度           |
   |    shift()    |      是      | 删除并返回数组的第一个元素，返回被删除的项                   |
   |   concat()    |      否      | 合并两个或多个数组为一个新数组,返回新数组                    |
   |    join()     |      否      | 将数组中所有元素连接成一个字符串                             |
   |    slice()    |      否      | 返回数组的一部分，不修改原数组                               |
   |   splice()    |      是      | 添加或删除数组的元素，同时修改原数组，返回包含删除元素的数组 |
   |   indexOf()   |      否      | 返回指定元素在数组中的第一个匹配项的索引                     |
   | lastIndexOf() |      否      | 返回指定元素在数组中的最后一个匹配项的索引                   |
   |   forEach()   |      否      | 遍历数组，对每个元素执行指定操作                             |
   |     map()     |      否      | 遍历数组，对每个元素执行指定操作，并返回结果数组             |
   |   filter()    |      否      | 遍历数组，根据指定条件筛选元素                               |
   |   reduce()    |      否      | 遍历数组，将数组元素归纳为单个值                             |
   | reduceRight() |      否      | 与 reduce() 方法类似，但从右向左遍历数组                     |
   |    find()     |      否      | 返回数组中满足条件的第一个元素                               |
   |  findIndex()  |      否      | 返回数组中满足条件的第一个元素的索引                         |
   |    every()    |      否      | 检查数组中的所有元素是否满足条件                             |
   |    some()     |      否      | 检查数组中是否存在满足条件的元素                             |
   |    sort()     |      是      | 对数组元素进行排序，修改原数组                               |
   |   reverse()   |      是      | 颠倒数组中元素的顺序，修改原数组                             |

## JavaScript字符串的常用方法

1. **length：** 返回字符串的长度。
2. **charAt()：** 返回指定位置的字符。
3. **charCodeAt()：** 返回指定位置字符的 Unicode 编码。
4. **concat()：** 连接两个或多个字符串，并返回新字符串。
5. **indexOf()：** 返回指定子字符串首次出现的位置。
6. **lastIndexOf()：** 返回指定子字符串最后一次出现的位置。
7. **startsWith()：** 检查字符串是否以指定子字符串开头。
8. **endsWith()：** 检查字符串是否以指定子字符串结尾。
9. **includes()：** 检查字符串是否包含指定子字符串。
10. **substring()：** 返回指定位置之间的子字符串。
11. **slice()：** 提取字符串的一部分，并返回新字符串。
12. **substr()：** 从指定位置开始，返回指定长度的子字符串。
13. **replace()：** 替换字符串中的匹配子字符串。
14. **toUpperCase()：** 将字符串转换为大写。
15. **toLowerCase()：** 将字符串转换为小写。
16. **trim()：** 移除字符串两端的空白字符。
17. **split()：** 将字符串分割为字符串数组。
18. **match()：** 在字符串中检索指定值，返回匹配的子字符串数组。
19. **search()：** 在字符串中搜索指定值，返回匹配的位置。
20. **repeat()：** 返回包含指定字符串的指定数量副本的新字符串。

##  JavaScript 中的类型转换机制

`隐式类型转换`和`显式类型转换`

#### 隐式类型转换

- **字符串拼接**：当一个字符串与其他类型的值进行加法运算时，其他值会被自动转换为字符串。

```javascript
console.log("5" + 2); // 输出 "52"
```

- **算术运算：** 当一个非字符串值与字符串进行算术运算时，非字符串值会被自动转换为数字。

```javascript
console.log("5" - 2); // 输出 3
```

- **逻辑运算：** 当非布尔值参与逻辑运算时，会将其转换为布尔值。

```javascript
if (1) {  console.log("true"); }// 输出 "true"
```

#### 显式类型转换

- **转换为字符串：** 使用 `String()` 函数或字符串模板。
- **转换为数字：** 使用 `Number()` 函数或 `+` 操作符。
- **转换为布尔值：** 使用 `Boolean()` 函数。
- **parseInt() 和 parseFloat()：** 将字符串转换为整数或浮点数。

## == 和 ===区别，分别在什么情况使用

用于比较两个值是否相等。它们的`区别`主要在于`类型转换的方式和严格性`。

#### `==` （相等运算符，Equality Operator）：

- **类型转换：** 在进行比较之前，`会进行类型转换`，使得两个值的类型相同。
- **松散比较：** `只比较值`是否相等，`不考虑数据类型`。
- **隐式类型转换：** 可能会触发`隐式类型转换`。

#### `===` （严格相等运算符，Strict Equality Operator）：

- **类型与值都要相等：** `不会进行类型转换`，只有在类型和值都相等时才返回 true。
- **严格比较：** `区分数据类型`。
- **不触发隐式类型转换：** 不会进行隐式类型转换，`必须类型和值都相等才返回 true`。

比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符

其他情况建议一律使用全等操作符

这是因为 `null` 和 `undefined` 在`相等比较中被认为是相等的`，而`不会触发类型转换`。这种情况下，两者之间的比较会返回 `true`。

## 深拷贝浅拷贝的区别？如何实现一个深拷贝

`基本类型`数据保存在在`栈`内存中

`引用类型`数据保存在`堆`内存中，引用数据类型的变量是一个`指向堆内存中实际对象的引用`，`存在栈中`

#### 深拷贝（Deep Copy）：

深拷贝是将原始数据结构中的所有嵌套对象或数组都复制一份，而不仅仅是复制其引用。这意味着`修改拷贝后的数据结构不会影响到原始数据结构`，它们之间是相互独立的。

常见的深拷贝方式有：

- _.cloneDeep()
- jQuery.extend()
- JSON.stringify()
- 手写循环递归

#### 浅拷贝（Shallow Copy）：

浅拷贝`只是复制原始数据结构中的基本数据类型`（如数字、字符串、布尔值等）`和引用类型的引用`（即地址），`而不是复制引用类型的内容`。这意味着拷贝后的数据结构中的嵌套对象或数组仍然与原始数据结构共享相同的嵌套对象或数组，如果修改了拷贝后的数据结构中的嵌套对象或数组，原始数据结构中的对应嵌套对象或数组也会受到影响。

存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

在JavaScript中，浅拷贝（Shallow Copy）和深拷贝（Deep Copy）是两种不同的复制对象的方法，它们之间的主要区别在于如何处理嵌套的对象或数组。

1. 浅拷贝（Shallow Copy）:

浅拷贝会创建一个新对象，其属性值是原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。

特点：

- 只复制对象的第一层属性
- 如果属性是基本类型，拷贝其值
- 如果属性是引用类型，拷贝其内存地址（两个对象共享同一个内存地址）

实现浅拷贝的方法：

```javascript
// 使用Object.assign()
let obj = { a: 1, b: { c: 2 } };
let newObj = Object.assign({}, obj);

// 使用展开运算符
let newObj2 = { ...obj };

// 使用Array.slice() (用于数组)
let arr = [1, 2, [3, 4]];
let newArr = arr.slice();
```

1. 深拷贝（Deep Copy）:

深拷贝会递归复制所有层级的属性，创建一个完全独立的新对象，包括嵌套的对象和数组。

特点：

- 递归复制所有层级的属性
- 完全独立的新对象，修改新对象不会影响原对象
- 处理循环引用可能会导致栈溢出

实现深拷贝的方法：

```javascript
// 使用JSON.parse() 和 JSON.stringify() (有局限性，不能处理函数、undefined等)
let obj = { a: 1, b: { c: 2 } };
let newObj = JSON.parse(JSON.stringify(obj));

// 递归实现
function deepCopy(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  
  let newObj = Array.isArray(obj) ? [] : {};
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = deepCopy(obj[key]);
    }
  }
  
  return newObj;
}

// 使用第三方库如lodash
const _ = require('lodash');
let newObj = _.cloneDeep(obj);
```

总结：

- 浅拷贝只复制对象的第一层属性，而深拷贝递归复制所有层级的属性。
- 浅拷贝更快，但可能导致意外的副作用（当修改嵌套对象时）。
- 深拷贝创建完全独立的新对象，但可能较慢，且需要注意循环引用问题。
- 选择使用哪种方法取决于你的具体需求和对象结构。

## 闭包

1. **函数嵌套：** 闭包通常是在函数内部定义的函数，形成了函数的嵌套结构。
2. **词法作用域：** 闭包可以访问其外部函数的词法作用域中的变量，即使外部函数已经执行完毕，闭包仍然可以访问这些变量。
3. **持有外部状态：** 闭包持有了外部函数作用域中的变量的引用，使得这些变量的生命周期得以延续，即使外部函数已经执行完毕。

#### 闭包的使用场景：

**封装私有变量和函数：** 闭包可以用来创建私有变量和函数，从而隐藏实现细节，提供了一种封装数据的方式。

```javascript
function counter() {
    let count = 0;
    return function() {
        return ++count;
    };
}
let increment = counter();
console.log(increment()); // 输出 1
console.log(increment()); // 输出 2

```

**模块化开发：** 闭包可以实现模块化开发，将相关功能封装在一个函数内部，并暴露出需要对外提供的接口。

```javascript
let module = (function() {
    let privateVar = "私有变量";
    function privateFunc() {
        console.log("私有函数");
    }
    return {
        publicFunc: function() {
            console.log(privateVar);
            privateFunc();
        }
    };
})();
module.publicFunc();
```

**保存状态：** 闭包可以保存状态，比如在事件处理函数中访问到循环中的变量

```javascript
for (let i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i); // 输出 0, 1, 2, 3, 4
    }, 1000);
}
```

**实现柯里化：** 闭包可以用来实现柯里化（Currying），将`多参数函数转换成一系列单参数函数`的过程。

```javascript
function add(x) {
    return function(y) {
        return x + y;
    };
}
let add5 = add(5);
console.log(add5(3)); // 输出 8
```

## 作用域链

作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合

换句话说，作用域决定了代码区块中变量和其他资源的可见性

一般将作用域分成：

- `全局作用域`:不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
- 函数作用域
- 块级作用域

当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在`当前作用域`下去寻找该变量，如果没找到，再到它的`上层作用域`寻找，以此类推`直到找到`该变量`或是已经到了全局作用域`,如果最终仍然没有找到变量，则会抛出 `ReferenceError`。

#### 作用域链的形成过程：

1. **函数创建时：** 在 JavaScript 中，每当创建一个函数时，会同时创建一个闭包（Closure），闭包保存了函数定义时的作用域链。这个作用域链是一个指向所有父级作用域的指针列表，包括全局作用域和函数的外部作用域。
2. **函数执行时：** 当函数执行时，会创建一个活动对象（Activation Object，也称作执行上下文），其中保存了函数内部定义的所有变量和函数。同时，JavaScript 引擎会创建一个作用域链，该链包括函数的活动对象和函数定义时的作用域链。
3. **变量查找：** 当需要访问一个变量时，JavaScript 引擎会首先在当前作用域的活动对象中查找，如果找不到，则会沿着作用域链向上查找，直到找到对应的变量或到达全局作用域为止。如果最终仍然没有找到变量，则会抛出 ReferenceError。

#### 作用域链的特点：

1. **词法作用域：** `作用域链是由代码中函数的定义位置决定`的，`而不是函数被调用的位置`。这种作用域链形成方式称为`词法作用域`（Lexical Scope）。
2. **闭包的作用：**` 闭包使得函数可以访问其定义时的作用域链上的变量`，即使函数在定义时和执行时所处的上下文不同，也能够访问外部函数的变量。

## JavaScript原型，原型链

`用于实现对象之间的继承关系。`用于实现属性查找和方法继承

`每个对象拥有一个原型对象`

访问一个对象的属性时，它不仅仅在该对象上搜寻，还会`搜寻该对象的原型`，以及该对象的原型的原型，依次`层层向上搜索`，直到找到一个名字匹配的属性或到达原型链的末尾

`__proto__`作为`不同对象之间的桥梁`，用来`指向创建它的构造函数的原型对象`,

对象的原型可以通过 `__proto__` 属性来访问。

原型链的顶端是 `Object.prototype`，它是所有对象的根原型。`Object.prototype` 的 `__proto__` 属性指向 `null`，表示它是原型链的终端节点。

#### 特点：

1. **原型共享：** `JavaScript 中的原型是可以共享的`，即`多个对象可以共享同一个原型对象`。这意味着我们可以在原型上定义属性和方法，所有通过该原型创建的对象都可以访问到这些属性和方法。
2. **继承机制：** 原型链实现了 JavaScript 中的继承机制。`子对象通过原型链继承父对象的属性和方法`，从而实现了代码的重用和组合。
3. **动态性：** JavaScript 中的`原型链是动态的`，即我们`可以随时修改原型对象`，新的属性和方法会立即对通过该原型创建的对象生效。

## Javascript如何实现继承

- 继承的优点

继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码

#### 原型链继承：

通过让子类的原型指向父类的实例来实现继承。

#### 构造函数继承：

通过在子类构造函数内部调用父类构造函数来实现继承。（借助 call）

#### 组合继承：

结合原型链继承和构造函数继承的方式来实现继承。

## 谈谈this对象的理解

  表`当前执行代码的上下文对象`，具体指向的对象取决于函数调用的方式。

#### **函数调用方式决定 `this` 的指向：**

 `this` 的值是在函数调用时确定的，而不是在函数声明时确定的。它取决于函数的调用方式，可以是函数调用、方法调用、构造函数调用或者通过 `apply` 和 `call` 显式地指定。

#### **全局上下文中的 `this`：** 

在全局执行上下文中，`this` 指向全局对象，在浏览器环境中通常是 `window` 对象，在 Node.js 中是 `global` 对象。

#### **函数内部的 `this`：** 

在函数内部，`this` 的值取决于函数的调用方式。如果`函数被作为普通函数调用，this 指向全局对象`；如果函数被作为对象的方法调用，`this` 指向调用该方法的对象；如果函数被用作构造函数，`this` 指向新创建的实例对象；如果函数被用作事件处理函数，`this` 指向触发事件的元素。

#### **箭头函数中的 `this`：** 

箭头函数的 `this` 绑定在它定义时所在的上下文中，而不是在运行时确定。因此，箭头函数中的 `this` 与普通函数不同，它没有自己的 `this`，它继承了外部函数的 `this`。

#### **严格模式下的 `this`：** 

在严格模式下，全局执行上下文中的 `this` 是 `undefined`，而不是全局对象。这样做是为了防止意外的全局变量创建。

## JavaScript中执行上下文和执行栈

#### 执行上下文（Execution Context）：

执行上下文是 `JavaScript 代码执行时的环境`，包括了`当前代码的作用域、变量对象、this 指向等信息`。每当 `JavaScript 代码执行时`，都会`创建一个执行上下文`，`并将其压入执行栈中`。执行上下文可以分为全局执行上下文和函数执行上下文两种类型。

- **全局执行上下文：** 在 JavaScript 代码开始执行时，首先创建全局执行上下文。全局执行上下文是整个程序的最顶层执行上下文，它包含了全局作用域中的所有变量、函数声明和 this 指向。
- **函数执行上下文：** 每当函数被调用时，都会创建一个函数执行上下文。函数执行上下文包含了函数作用域中的所有变量、函数声明和 this 指向。

#### 执行栈（Execution Stack）：

执行栈是`用来存储执行上下文的栈结构`，也被称为`调用栈`（Call Stack）。当 JavaScript 代码`开始执行时`，首先`创建全局执行上下文`，并将其`压入执行栈中`。当`函数被调用时`，会`创建一个新的函数执行上下文`，并将其`压入执行栈的顶部`。当函数`执行完毕`时，对应的执行上下文会从执行栈中`弹出`，`控制权交给下一个`执行上下文。

执行栈遵循`先进后出（FILO）的原则`，也就是说最后进入的执行上下文会最先执行完成并从执行栈中弹出，直到执行栈为空，整个 JavaScript 代码的执行过程结束。

## 说说JavaScript中的事件模型

JavaScript 中的事件模型指的是`浏览器中的事件处理机制`，它`允许开发者在文档中的元素上注册各种类型的事件`，并定义事件发生时应该执行的代码。JavaScript 中的事件模型`基于 DOM（文档对象模型）`

#### **事件类型：** 

事件类型定义了浏览器中可能发生的各种事件，例如`点击事件、鼠标移动事件、键盘事件等`。

#### **事件目标：** 

事件目标是事件发生的对象，也就是触发事件的元素。可以`在文档中的任何元素上注册事件监听器`，当事件发生时，浏览器`会将事件传递给对应的事件目标`，并`执行相应的事件处理函数`。

#### **事件监听器**：

事件监听器是用于处理特定事件的函数，也称为事件处理函数。可以通过 DOM API（如 `addEventListener`）或者 HTML 属性（如 `onclick`）来注册事件监听器，当事件发生时，浏览器会调用相应的事件处理函数。

#### **事件流：** 

事件流描述了事件从事件目标传播到文档根节点的过程。事件流分为`捕获阶段`、`目标阶段`和`冒泡阶段`。在`捕获阶段，事件从文档根节点向事件目标传播`；在`目标阶段，事件在事件目标上触发`；在`冒泡阶段，事件从事件目标向文档根节点反向传播。`

#### 事件模型

可以分为三种：

##### 原始事件模型（DOM0级）

绑定速度快,`DOM0`级事件具有很好的跨浏览器优势

- 只支持冒泡，不支持捕获
- 同一个类型的事件只能绑定一次

##### 标准事件模型（DOM2级）

`监听器`,`冒泡`处理和`捕获`3个阶段

##### IE事件模型（基本不用）

## typeof 与 instanceof 区别

`typeof`与`instanceof`都是判断数据类型的方法，区别如下：

- `typeof`会返回一个变量的`基本类型`，`instanceof`返回的是一个`布尔值`,`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

  

- `instanceof` 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型

  - 而`typeof` 也存在弊端，检测`null`和`数组`返回都是`Object`, 它虽然可以判断基础数据类型（`null` 除外），但是引用数据类型中，除了`function` 类型以外，其他的也无法判断

如果需要通用检测数据类型，可以采用`Object.prototype.toString`，调用该方法，统一返回格式`“[object Xxx]”`的字符串

```javascript
function getType(obj){
    let type = typeof(obj);
    if(type !== 'object') return type;
    // return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');;
    return Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);
}
//typeof 特例
let a = new Number(1)
console.log(getType(new Number(1)));//Number
console.log(typeof(new Number(1)));//Object
```

## 事件代理和事件委托

事件代理和事件委托是同一个概念的不同表达方式，`指的是通过在父元素上注册事件监听器来处理子元素上的事件。`

1. 在父元素上注册事件监听器，监听特定类型的事件。
2. 当事件发生时，事件会在子元素上触发，并冒泡到父元素。
3. 父元素捕获事件，根据事件目标（即触发事件的子元素）来执行相应的处理逻辑。

#### 应用场景：

1. **动态添加元素：** 当页面中的元素是动态生成的，并且数量较多时，可以使用事件代理来简化事件处理逻辑。`只需将事件监听器绑定到父元素上`，而`不需要为每个子元素都添加事件监听器`。
2. **性能优化：** 在大型列表或表格中，如果为每个元素都添加事件监听器，可能会导致页面性能下降。使用事件代理可以`减少事件处理程序的数量`，提高页面的性能。
3. **元素重新渲染：** 在使用虚拟 DOM 技术或框架时，页面元素可能会经常重新渲染。如果直接在子元素上绑定事件监听器，每次重新渲染都需要重新绑定事件。而使用事件代理，`只需在父元素上绑定一次事件监听器，不受元素重新渲染的影响`。
4. **节省内存：** 在特定情况下，使用事件代理可以节省内存。因为`事件处理程序只需绑定到一个父元素上，而不是多个子元素上，减少了内存消耗`。

## new操作符具体干了什么

`new`操作符用于创建一个给定构造函数的实例对象

- 创建一个新的对象`obj`
- 将对象与构建函数通过原型链连接起来
- 将构建函数中的`this`绑定到新建的对象`obj`上
- 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理

## Ajax

即异步的`JavaScript` 和`XML`是一种创建交互式网页应用的网页开发技术，可以在`不重新加载`整个网页的情况下，与`服务器交换数据`，并且`更新部分网页`

`Ajax`的原理简单来说通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`JavaScript`来操作`DOM`而更新页面

浏览器可以发送`HTTP`请求后，接着做其他事情，等收到`XHR`返回来的数据再进行操作

**异步通信：** AJAX 使用 JavaScript 发起 HTTP 请求，并在后台与服务器进行异步通信，不会阻塞页面的加载和渲染。

**XMLHttpRequest 对象：** AJAX 使用 XMLHttpRequest 对象来实现与服务器的交互。这个对象允许客户端发送 HTTP 请求和接收服务器响应。

**事件驱动：** AJAX 通过事件驱动的方式处理服务器响应，当服务器响应返回时，会触发相应的事件（如 `onreadystatechange` 事件），从而执行相应的回调函数处理响应数据。

#### AJAX 的实现步骤：

1. **创建 XMLHttpRequest 对象：** 在 JavaScript 中创建一个 XMLHttpRequest 对象，用于发起 HTTP 请求。

2. **设置回调函数：** 使用 `onreadystatechange` 属性设置一个回调函数，用于处理服务器响应。

3. **打开和发送请求：** 使用 `open` 方法设置请求方法（GET、POST 等）、请求地址和是否异步等参数，然后使用 `send` 方法发送请求。

4. **处理服务器响应：** 当接收到服务器响应时，会触发 `onreadystatechange` 事件，此时可以通过 `readyState` 和 `status` 属性来判断请求状态，通过 `responseText` 或 `responseXML` 属性来获取服务器响应数据，然后在回调函数中处理数据并更新页面。

5. ```javascript
   // 创建 XMLHttpRequest 对象
   var xhr = new XMLHttpRequest();
   
   // 设置回调函数
   xhr.onreadystatechange = function() {
       if (xhr.readyState === 4 && xhr.status === 200) {
           // 处理服务器响应数据
           console.log(xhr.responseText);
       }
   };
   
   // 打开和发送请求
   xhr.open('GET', 'https://api.example.com/data', true);
   xhr.send();
   
   ```

## bind、call、apply 区别

`bind`、`call` 和 `apply` 都是 JavaScript 中用于`改变函数执行上下文`的方法

- 三者都可以改变函数的`this`对象指向
- 三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`
- 三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入
- `bind`是返回绑定this之后的函数，`apply`、`call` 则是立即执行

##### 实现一个Bind

```javascript
Function.prototype.myBind = function (context) {
    var self = this; // 保存原函数的引用
    var args = Array.prototype.slice.call(arguments, 1); // 获取除 context 外的参数

    return function () { // 返回一个新函数
        var bindArgs = Array.prototype.slice.call(arguments); // 获取新函数的参数
        return self.apply(context, args.concat(bindArgs)); // 使用 apply 执行原函数，将 context 和参数合并传入
    };
};
```

## 正则表达式

在 `JavaScript`中，正则表达式也是对象

计思想是用一种描述性的语言定义一个规则

构建正则表达式有两种方式

- 字面量创建，其由包含在斜杠之间的模式组成

  ```javascript
  const re = /\d+/g;
  ```

- 调用`RegExp`对象的构造函数

  ```javascript
  const re = new RegExp("\\d+","g");
  
  const rul = "\\d+"
  const re1 = new RegExp(rul,"g");
  ```

#### 特点

1. **灵活性：** 正则表达式可以描述各种复杂的字符串模式，包括字符、数字、特殊符号等。
2. **强大的匹配能力：** 正则表达式可以匹配多种字符组合，包括连续字符、单词、数字等。
3. **通用性：** 正则表达式是跨平台、跨语言的，几乎所有的编程语言都支持正则表达式。

#### 应用场景：

1. **字符串匹配：** 可以用于搜索文本中特定模式的字符串。
2. **数据验证：** 可以用于验证用户输入的数据格式是否符合要求，例如邮箱、电话号码等。
3. **字符串替换：** 可以用于将文本中特定模式的字符串替换为其他内容。
4. **文本提取：** 可以用于从文本中提取特定格式的信息，例如从网页中提取链接、标题等。
5. **日志分析：** 可以用于分析日志文件中特定格式的信息。

## 事件循环

事件循环（Event Loop）是 `JavaScript 运行时环境中的一种机制`，用于`处理异步任务和事件处理`,`实现单线程非阻塞`。在 JavaScript 中，单线程的执行模型意味着所有的代码都是按顺序执行的，不能同时处理多个任务。但是，`JavaScript 又支持异步编程`，例如通过`定时器`、`事件监听`、`Promise` 等方式`实现的异步操作`。`事件循环机制就是用来管理和调度这些异步任务的执行顺序`。

`同步任务`进入`主线程`，即`主执行栈`，`异步任务`进入`任务队列`，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环

#### 异步任务还可以细分为微任务与宏任务

- 宏列队: 用来保存待执行的`宏任务`(回调), 比如: `定时器回调`/`DOM 事件回调`/`ajax 回调`
- 微列队: 用来保存待执行的`微任务`( 回调), 比如:` promise` 的回调/`MutationObserver` 的回调

*JS 执行时会区别这2 个队列*

　　*JS 引擎`首先必须先执行`所有的`初始化同步任务代码`*

　　每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出**执行**

**promise是微任务优先于定时器执行**



常见的宏任务有：

- script (可以理解为外层同步代码)
- setTimeout/setInterval
- UI rendering/UI事件
- postMessage、MessageChannel
- setImmediate、I/O（Node.js）



`async`是用来声明一个异步方法，而 `await`是用来等待异步方法执行, `async`函数返回一个`promise`对象

不管`await`后面跟着的是什么，`await`都会阻塞后面的代码

##### 示例

```javascript
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('settimeout')
})
async1()
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')
```

最后的结果是：`script start`、`async1 start`、`async2`、`promise1`、`script end`、`async1 end`、`promise2`、`settimeout`

```javascript
async function fn1 (){
    console.log(1)
    await fn2()
    console.log(2) // 阻塞
}

async function fn2 (){
    console.log('fn2')
}

fn1()
console.log(3)
```

执行结果: `1` `fn2` `3` `2`

## 常见Dom操作

#### 什么是dom

DOM（Document Object Model，`文档对象模型`）是一种`用于表示和操作网页文档的编程接口`。它`将整个 HTML 或 XML 文档表示为一个树状结构`，其中`每个节点都是文档中的一个元素、属性或文本`。通过 DOM，可以使用编程方式访问、操作和修改网页的内容、结构和样式

#### 主要特点：

1. **树状结构：** DOM 将文档表示为一个`树状结构`，由多个节点组成，包括元素节点、文本节点、属性节点等。
2. **对象模型：** DOM 将文档中的`每个部分都表示为一个对象`，通过操作这些对象可以实现对文档内容、结构和样式的控制。
3. **平台和语言无关：** DOM 是`与平台和语言无关的标准`，因此`可以在各种编程语言和平台上使用`，例如 JavaScript、Python、Java 等。
4. **动态性：** 由于 DOM 可以通过编程方式修改，因此`可以实现动态地更新页面内容、结构和样式`。

#### 常见的 DOM 操作

1. **获取元素：**
   - `document.getElementById()`: 根据元素的 id 获取元素对象。
   - `document.getElementsByClassName()`: 根据类名获取元素对象集合。
   - `document.getElementsByTagName()`: 根据标签名获取元素对象集合。
   - `document.querySelector()`: 根据 CSS 选择器获取第一个匹配的元素对象。
   - `document.querySelectorAll()`: 根据 CSS 选择器获取所有匹配的元素对象集合。
2. **创建元素：**
   - `document.createElement()`: 创建新的元素节点。
   - `document.createTextNode()`: 创建新的文本节点。
3. **插入、删除和替换元素：**
   - `parentNode.appendChild()`: 将一个新的子节点添加到指定节点的子节点列表的末尾。
   - `parentNode.removeChild()`: 从父节点中移除一个子节点。
   - `parentNode.replaceChild()`: 用一个新的节点替换父节点中的一个子节点。
   - `parentNode.insertBefore()`: 在指定的已有子节点之前插入新的子节点。
4. **修改元素的属性和样式：**
   - `element.setAttribute()`: 设置元素的属性值。
   - `element.getAttribute()`: 获取元素的属性值。
   - `element.style.property`: 直接设置元素的 CSS 样式。
   - `element.classList.add()`: 添加一个类名到元素的类列表中。
   - `element.classList.remove()`: 从元素的类列表中移除一个类名。
   - `element.classList.toggle()`: 如果元素的类列表中存在指定的类名，则删除它；如果不存在，则添加它。
5. **事件处理：**
   - `element.addEventListener()`: 绑定事件监听器。
   - `element.removeEventListener()`: 移除事件监听器。
   - `element.onclick`: 直接设置元素的点击事件处理函数。
6. **获取和修改元素内容：**
   - `element.innerHTML`: 获取或设置元素的 HTML 内容。
   - `element.innerText`: 获取或设置元素的文本内容。
   - `element.textContent`: 获取或设置元素的纯文本内容。

## BOM

#### 什么是BOM

BOM（Browser Object Model，`浏览器对象模型`）是 `JavaScript 中`用于`操作浏览器窗口和浏览器本身的一组对象`。它`提供了一系列的对象和方法`，`用于获取和控制浏览器窗口`、`导航`、历史记录、屏幕信息等。

`Bom`的核心对象是`window`，它表示浏览器的一个实例

浏览器中，`window`对象有双重角色，即是浏览器窗口的一个接口，又是全局对象

因此所有在全局作用域中声明的变量、函数都会变成`window`对象的属性和方法

#### 常见的 BOM 对象：

1. **window 对象：** 代表浏览器窗口，是 BOM 中的核心对象，包含了很多属性和方法，例如 `window.location`、`window.document`、`window.alert()` 等。
2. **navigator 对象：** 包含有关浏览器的信息，例如浏览器类型、版本、操作系统等，常用属性有 `navigator.userAgent`、`navigator.platform`。
3. **screen 对象：** 包含有关用户屏幕的信息，例如屏幕宽度、高度、像素深度等，常用属性有 `screen.width`、`screen.height`、`screen.availWidth` 等。
4. **history 对象：** 用于操作浏览器的历史记录，可以前进、后退、跳转到指定页面等，常用方法有 `history.back()`、`history.forward()`、`history.go()`。
5. **location 对象：** 包含有关当前 URL 的信息，可以用于获取和修改浏览器的当前地址，常用属性有 `location.href`、`location.pathname`、`location.search`、`location.hash` 等。
6. **document 对象：** 代表当前网页的文档，可以用于操作网页中的元素、样式、内容等，常用方法有 `document.getElementById()`、`document.createElement()`、`document.querySelector()` 等。
7. **event 对象：** 包含有关当前事件的信息，例如事件的类型、目标元素等，常用属性有 `event.type`、`event.target`。
8. **XMLHttpRequest 对象：** 用于在后台与服务器交换数据，可以实现异步加载数据，常用于 AJAX 请求。

## JavaScript 中内存泄漏的几种情况

JavaScript 中的内存泄漏指的是程序中`不再需要的内存仍然被占用`，`无法被及时释放`，`最终导致内存占用过高或者持续增长`，影响程序性能和稳定性。

Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，`执行环境会负责管理代码执行过程中使用的内存`

两种方式:

- 标记清理
- 引用计数

#### 常见的引起内存泄漏的情况

1. **未释放的引用：** `当一个对象不再被使用，但仍然被其他对象持有引用`，导致对象无法被垃圾回收器识别和释放。这种情况通常发生在循环引用、闭包、事件绑定等场景中。
2. **定时器未清理：** 如果定时器未被正确清理或者重复设置，会导致定时器中的回调函数一直存在引用，即使不再需要，也无法被垃圾回收器回收。
3. **DOM 节点未移除：** 当页面上的 DOM 节点被移除或者替换时，如果没有及时清理相关的事件监听器、数据绑定等，会导致 DOM 节点及其相关的对象无法被释放。
4. **全局变量未销毁：** 如果全局变量不再需要但没有被及时销毁，会一直存在于内存中，无法被回收。
5. **闭包：** 闭包中的变量在函数执行完毕后依然存在于内存中，如果闭包中引用了大量的外部变量或者其他对象，可能导致内存泄漏。
6. **缓存：** `缓存数据未被正确管理`，如果缓存过多或者缓存时间过长，会占用大量内存，导致内存泄漏。

## Javascript本地存储的方式有哪些？区别及应用场景？

- cookie
- sessionStorage
- localStorage
- indexedDB

#### cookie

为了解决 `HTTP`无状态导致的问题

- **特点：** Cookie 是一小段数据，由服务器发送到浏览器并保存在本地，`每次请求时都会被发送`到服务器。Cookie `可以设置过期时间`，`可以跨域名访问`，但每个 Cookie 的大小通常受到限制。
- **应用场景：** 适合存储小量的`用户信息`、`会话标识`等，例`如用户登录状态`、`用户偏好设置`等。

#### **Web Storage（LocalStorage 和 SessionStorage）**

- 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的
- 存储的信息在同一域中是共享的
- 当本页操作（新增、修改、删除）了`localStorage`的时候，本页面不会触发`storage`事件,但是别的页面会触发`storage`事件。
- 大小：`5M（跟浏览器厂商有关系）`
- `localStorage`本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
- 受同源策略的限制
- 存储在 Session 对象中的变量将不会丢失，而是`在整个用户会话中一直存在下去`
- 作用范围不同，`Cookie 保存在客户端`（浏览器），`Session 保存在服务器端`
- 存取方式的不同，`Cookie 只能保存 ASCII`，`Session 可以存任意数据类型`，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- `Cookie 只能保存 ASCII`，`Session 可以存任意数据类型`

**应用场景：** 适合`存储大量的用户数据`、`本地缓存`、`Web 应用的状态`等，例`如用户偏好`设置、`表单数据`、缓存的页面内容等。

**两个缺点：**

- `无法`像`Cookie`一样`设置过期时间`
- `只能存入字符串`，`无法直接存对象`

SessionStorage 数据`只在当前会话有效`，`页面关闭后就会被清除`。

#### indexedDB

- **特点：** IndexedDB 是一个`浏览器提供的本地数据库`，`允许存储大量结构化数据`，并提供强大的查询和索引功能。IndexedDB 是`异步操作`，`可以在后台处理大量数据`。
- **应用场景：** `适合存储大量结构化的数据`，例如`离线应用数据`、`复杂的客户端缓存`、大规模数据的本地存储等。

## 函数式编程

函数式编程是一种"编程范式"（programming paradigm），一种编写程序的方法论

主要的编程范式有三种：`命令式编程`，`声明式编程`和`函数式编程`

函数式编程更加`强调程序执行的结果`而非执行的过程，

#### 命令式编程（Imperative Programming）：

- **特点：**
  - 通过编写一系列的命令和指令来描述程序的执行过程。
  - 程序员需要关注程序的具体实现细节，指定每一步的执行过程。
  - 强调如何实现某个目标，而不仅仅是描述目标是什么。
- **示例：** 典型的命令式编程语言包括 C、C++、Java 等，例如使用循环、条件语句、变量赋值等来控制程序流程。

#### 声明式编程（Declarative Programming）：

- **特点：**
  - 强调描述问题的解决方案，而不是解决问题的步骤。
  - 程序员关注需要实现的目标，而不是具体的执行过程。
  - 更关注问题的本质和解决方案的逻辑，而不是实现细节。
- **示例：** SQL 是声明式编程的一个典型例子，通过简单的 SQL 查询语句描述数据查询操作，而不需要指定具体的执行过程。

#### 函数式编程（Functional Programming）：

- **特点：**
  - 将计算视为数学函数的求值，强调使用纯函数和不可变数据结构来进行编程。
  - 函数是一等公民，可以作为参数传递、返回值返回，支持高阶函数和函数组合。
  - 避免了状态变量和可变数据，强调无副作用的函数调用。
- **示例：** 函数式编程语言如 Haskell、Scala、Clojure 等，以及在 JavaScript 中采用函数式编程范式编写的代码，例如使用 map、filter、reduce 等高阶函数进行数据处理。

#### 区别：

1. **实现方式：**` 命令式编程关注如何实现目标`，`以具体的步骤和指令描述程序执行过程`；`声明式编程`关注`描述目标的解决方案`，`以描述性的语句表达解决方案`；函数式编程则将计算视为函数的求值，避免了状态变量和可变数据。
2. **抽象程度：** 函数式编程是声明式编程的一种，它更强调抽象和高级概念，通过函数组合和高阶函数实现更高层次的抽象；而命令式编程更侧重于底层细节和具体实现。
3. **可变性：** 命令式编程和一些声明式编程方式（如部分的函数式编程）通常允许可变数据和状态变量，而函数式编程强调不可变性和纯函数的使用。

## 函数缓存

函数缓存，就是`将函数运算过的结果进行缓存`

本质上就是`用空间（缓存存储）换时间（计算过程）`

常用于缓存数据计算结果和缓存对象

实现函数缓存主要依靠`闭包、柯里化、高阶函数`



实现原理也很简单，把参数和对应的结果数据存在一个对象中，`调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结果`

```javascript
const memoize = function (func, content) {
  let cache = Object.create(null)
  content = content || this
  return (...key) => {
    if (!cache[key]) {
      cache[key] = func.apply(content, key)
    }
    return cache[key]
  }
}
const calc = memoize(add);
const num1 = calc(100,200)
const num2 = calc(100,200) // 缓存得到的结果
```

#### 应用场景

1. **计算密集型任务：** 对于需要进行复杂计算的函数，如果函数的输入参数相同，那么输出结果也是相同的，可以通过函数缓存来避免重复计算，提高性能。
2. **网络请求：** 对于需要从服务器获取数据的函数，如果请求参数相同，可以缓存服务器返回的结果，避免重复请求，提高响应速度。
3. **数据处理：** 对于数据处理函数，如果需要对大量数据进行处理，可以缓存处理过的数据，避免重复操作，提高效率。
4. **递归函数：** 对于递归函数，可以使用函数缓存来存储已经计算过的中间结果，避免重复计算，提高效率。

## Javascript 数字精度

JavaScript 中，数字精度丢失问题是由于采用` IEEE 754 标准的双精度浮点数表示法`所导致的

#### 解决方法：

1. **使用整数进行计算：** 将需要进行精确计算的小数转换为整数进行计算，计算完成后再转换回小数。
2. **使用精确计算库：** 可以使用第三方的精确计算库，如 BigNumber.js、decimal.js 等，这些库提供了精确的十进制数值运算，避免了浮点数的精度问题。
3. **四舍五入或截断处理：** 对于需要显示的小数结果，可以使用四舍五入或截断处理来控制小数点后的位数，避免显示过多的小数位数。
4. **避免直接比较：** 在进行数字比较时，避免直接使用等号判断两个浮点数是否相等，而是采用误差范围的方式进行比较。
5. **使用 ECMAScript 6 的新特性：** ECMAScript 6 引入了 BigInt 类型，用于表示任意精度的整数，可以避免大整数的精度问题。

```javascript
// 使用整数进行计算示例
function add(x, y) {
  const precision = Math.pow(10, 4); // 精度，此处为保留四位小数
  const result = Math.round((x * precision + y * precision) / precision);
  return result / precision;
}

console.log(add(0.1, 0.2)); // 输出 0.3
```

## 8种数据类型

1. Undefined（未定义）
2. Null（空值）
3. Boolean（布尔值）
4. Number（数字）
5. String（字符串）
6. Symbol（符号）
7. BigInt（大整数）
8. Object（对象）

## 防抖和节流

本质上是`优化高频率执行代码`的一种手段

如浏览器的 `resize`、`scroll`、`keypress`、`mousemove` 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 **防抖（debounce）** 和 **节流（throttle）** 的方式来减少调用频率

#### 防抖（Debouncing）：

防抖是指`在一段连续触发事件结束后，只执行一次函数`。`如果在指定的时间间隔内又触发了该事件`，则`重新开始计时`，`直到再次触发事件结束`。

#### 节流（Throttling）：

节流是指`在一段时间内，只执行一次函数`。如果在`指定的时间间隔内多次触发了该事件`，则`忽略后续的触发`，`直到时间间隔过去后再次触发`。

#### 区别：

- **执行时机不同：** `防抖是在事件结束后执行一次函数`，而`节流是在固定时间间隔内执行一次函数`。
- **执行频率不同：** `防抖可以确保函数只会执行一次`，而`节流可以控制函数在一定时间内的执行频率`。

#### 应用场景

##### 防抖在连续的事件，只需触发一次回调的场景有：

- **搜索框实时搜索**：当用户在搜索框中快速连续输入时，不需要在每次输入时立即发起搜索请求，而是等待用户停止输入一段短暂时间（比如300毫秒）后才发起请求，以减少对服务器的压力和带宽消耗。
- **窗口大小调整**（Window Resize）：当用户快速调整浏览器窗口大小时，如果不做防抖处理，resize事件会被频繁触发，这可能会导致大量不必要的计算和布局重排。通过防抖，可以确保在窗口大小稳定后才执行布局计算和渲染。
- **表单验证**：在用户连续修改表单字段时，不需要每次键入后都立即验证表单，而是等到用户停顿后再验证。

##### 节流应用场景

- **页面滚动事件（Scroll Event）**：在无限滚动加载的页面中，不需要每滚动一点点就触发加载更多数据的操作，而是设置一个时间间隔，例如每滚动停止500毫秒后才触发加载事件，既能及时响应用户的滚动行为，又能避免过于频繁的后台请求。
- **鼠标连续移动事件（MouseMove Event）**：在某些情况下，无需实时响应鼠标每一点微小的移动，只需要在一定时间间隔内（如每100毫秒）取最近一次移动事件坐标进行处理。

```javascript
// 防抖
function debounce(fn, delay) {
    let timer;
    return function(...args) {
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    }
}

// 节流
function throttle(fn, delay) {
    let timer = null;
    return function(...args) {
        if (!timer) {
            fn.apply(this, args);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    }
}
```



## 如何判断一个元素是否在可视区域中

1. 获取目标元素的位置和尺寸信息。
2. 获取窗口（视口）的滚动位置和尺寸信息。
3. 计算目标元素的位置是否在可视区域内。

## 大文件上传如何做断点续传

1. **分片：** 将大文件`分割成多个小文件块`（分片），每个文件块大小合适，一般为几百 KB 到几 MB。可以使用前端或后端分片，`前端分片可以减轻服务器压力`，`后端分片可以更好地控制上传进度`。
2. **上传：** 将`分割后的文件块依次上传到服务器`。可以采用多线程或并行上传提高上传速度，同时确保上传过程中的文件块顺序正确。
3. **记录上传进度：** 在上传过程中，记录每个文件块的上传状态（已上传或未上传）、上传位置（已上传的字节数）、上传时间等信息，以便在上传中断后恢复上传进度。
4. **断点续传：** 如果上传过程中发生中断，可以根据记录的上传进度信息，从中断处开始继续上传未完成的文件块，而不需要重新上传已上传的部分。可以在客户端或服务器端实现断点续传逻辑，客户端实现更灵活，但服务器端实现更可靠。
5. **合并文件：** 当所有文件块上传完成后，服务器端将所有文件块合并成完整的文件。在合并过程中，需要检查每个文件块的完整性和顺序，确保合并后的文件与原始文件一致。
6. **清理资源：** 上传完成后，清理临时文件和记录的上传进度信息，释放资源，确保系统稳定性和安全性。

- `网络环境较差`：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part
- `流式上传`：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在`视频监控`等行业应用中比较常见

## 单点登录？如何实现？

SSO的定义是在`多个应用系统中`，用户`只需要登录一次`就可以`访问所有相互信任的应用系统`

当一个系统成功登录以后，`passport`将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被`passport`授权以后，会`建立一个局部会话`，在一定时间内可以无需再次向`passport`发起认证

#### 实现步骤

1. **用户登录：** 用户在身份验证系统中进行登录，身份验证系统验证用户的凭据，并`生成一个令牌`。
2. **令牌颁发：** 身份验证系统将生成的令牌发送给用户的浏览器，或者将令牌存储在身份验证服务器中。
3. **令牌验证：** 用户`访问其他应用程序时，这些应用程序会发送身份验证请求到身份验证系统`，并提供之前生成的令牌。
4. **验证令牌：** 身份验证系统验证接收到的令牌的有效性，包括令牌是否过期、签名是否有效等。
5. **授权访问：** 如果令牌有效，身份验证系统根据令牌中的用户身份信息决定是否允许用户访问应用程序，如果允许，则向应用程序返回授权响应。
6. **访问应用程序：** 用户可以访问被授权的应用程序，应用程序可以根据令牌中的用户信息来提供个性化的服务或内容

## web常见的攻击方式有哪些？如何防御？

- **跨站脚本攻击（XSS）：** 攻击者注入恶意脚本到 Web 页面中，当用户浏览页面时执行这些脚本，从而盗取用户信息、会话标识或篡改页面内容。
- **SQL 注入攻击：** 攻击者通过在 Web 应用程序的输入字段中插入 SQL 查询语句，从而获得对数据库的未授权访问权限，可以窃取敏感数据或破坏数据库。
- **跨站请求伪造攻击（CSRF）：** 攻``击者伪造用户在 Web 应用程序上的请求``，以用户身份执行未经授权的操作，例如转账、更改密码等。
- **点击劫持攻击：** 攻击者将透明的、恶意的页面叠加在合法页面上，并诱使用户在不知情的情况下执行恶意操作，例如点击一个隐藏的按钮。
- **DDoS 攻击：** 分布式拒绝服务（DDoS）攻击旨在通过向目标系统发送大量的请求来耗尽其资源，使其无法响应正常用户的请求。
- **文件上传漏洞：** 攻击者利用文件上传功能上传恶意文件到 Web 服务器上，可能导致服务器受到攻击、文件泄露或恶意代码执行等问题。

为了防御这些攻击，可以采取以下措施：

1. **输入验证和过滤：** 对用户输入进行严格的验证和过滤，防止恶意输入注入到系统中。
2. **输出编码：** 在将用户输入显示到页面上之前，对其进行适当的编码，以防止 XSS 攻击。
3. **参数化查询：** 使用参数化查询或预编译语句来执行数据库查询，以防止 SQL 注入攻击。
4. **CSRF Token：** `在敏感操作中使用 CSRF Token 来防止跨站请求伪造攻击`。
5. **点击劫持防御：** 设置 X-Frame-Options 标头，以防止页面被嵌套到 iframe 中，从而防止点击劫持攻击。
6. **网络安全策略：** 配置网络安全策略（例如防火墙、入侵检测系统），及时检测和阻止 DDoS 攻击。
7. **文件上传限制：** 对用户上传的文件进行严格的类型和大小限制，并在服务器端对上传的文件进行安全扫描。
8. **定期安全审计和更新：** 定期进行安全审计，及时更新系统和库，修补已知漏洞，保持系统的安全性和稳定性。

## Session

session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，`session就是一个对象`，用于`存储信息`。 

## JS字符串和数组的区别

1. **字符串（String）**：
   - 字符串是一组由零个或多个字符组成的有序序列。
   - 字符串中的每个字符`可以通过索引来访问`，索引从0开始，例如 `str[0]` 表示字符串中的第一个字符。
   - `字符串是不可变的（immutable），即一旦创建，就不能修改其内容。任何对字符串的修改都会返回一个新的字符串。`
   - 字符串可以使用单引号、双引号或者模板字符串（反引号）来表示。
2. **数组（Array）**：
   - 数组是一组有序的数据集合，可以包含任意类型的数据，包括字符串、数字、对象等。
   - 数组中的每个元素可以通过索引来访问，索引从0开始，例如 `arr[0]` 表示数组中的第一个元素。
   - `数组是可变的（mutable）`，即可以通过添加、删除或修改元素来改变数组的内容。
   - 数组提供了丰富的方法和属性来操作和管理数据，如 `push()`、`pop()`、`splice()`、`concat()`、`slice()` 等。

## 网页出现卡顿,怎么排查怎么解决

1. **检查`网络和服务器`**：
   - 网络延迟或服务器响应时间过长可能会导致网页加载缓慢或卡顿。使用网络工具（如浏览器开发者工具的 Network 标签）检查网络请求和响应时间，并确保服务器性能良好。
2. **检查`代码质量`**：
   - 大量的`无效代码、冗余代码、重复代码、死循环`或者复杂的算法可能会导致网页运行缓慢。通过代码审查和性能分析工具（如Chrome DevTools的Performance标签）来检查和优化代码。
3. **优化`页面渲染`**：
   - 复杂的DOM结构、大量的DOM操作、频繁的重绘和重排可能会导致页面渲染性能下降。优化CSS样式，`减少不必要的DOM操作`，`使用 CSS 动画而不是 JavaScript 动画`，尽量减少频繁更新 DOM。
4. **`压缩和合并`资源**：
   - 优化网页加载速度，可以`压缩和合并 JavaScript、CSS、图片等静态资源`，减少网络请求次数，提高加载速度。
5. **使用`懒加载`**：
   - 对于大型网页或者包含大量图片的网页，可以使用懒加载技术，延迟加载图片或者其他资源，减少首次加载时的压力。
6. **使用`缓存`**：
   - `合理使用浏览器缓存和服务器缓存，减少不必要的重复请求，提高网页加载速度`。
7. **`处理大量数据`**：
   - 如果网页需要处理大量数据，可以`考虑使用分页、虚拟滚动`等技术，`减少一次性加载大量数据`导致的性能问题。
8. **浏览器`兼容性`**：
   - 不同浏览器可能对同一段代码的性能表现有所差异，需要进行跨浏览器测试，并针对性地进行优化。
9. **`硬件加速`**：
   - 对于一些复杂的动画或者渲染效果，可以考虑使用硬件加速，通过 CSS 属性 `transform` 或者 `opacity` 触发 `GPU 加速`，提高动画性能。
10. **使用`服务端渲染`（SSR）**：
    - 对于需要大量计算或者复杂逻辑的页面，可以考虑使用`服务端渲染来提高网页的性能`和加载速度。

## css包大怎么处理

1. **`代码优化`**：
   - 检查 CSS 代码，`删除不必要的样式和规则`，减少冗余和重复的代码。
   - 使用压缩工具（例如CSS压缩器）`对CSS文件进行压缩`，减少文件大小。
   - 将大型的`CSS文件拆分成多个小文件，按需加载`，减少单个文件的大小和加载时间。
2. **使用 `CSS 预处理器`**：
   - 使用 CSS 预处理器（如`Sass、Less`等）可以提高CSS代码的可维护性，并通过`使用变量、嵌套、混合等功能来减少重复代码量`。
   - 预处理器可以帮助你更好地组织和管理 CSS 代码，同时生成压缩的 CSS 输出。
3. **`图像优化`**：
   - 对于使用了大量图像的网页，可以使用`图像压缩工具`（如ImageOptim、TinyPNG等）来减少图像文件的大小，从而减少 CSS 包的大小。
   - 考虑使用 `CSS Sprites 技术将多个小图标合并成一张大图`，`减少 HTTP 请求`次数。
4. **使用`字体子集`**：
   - 如果网页中使用了自定义字体，可以考虑使用字体子集（Font Subset）来仅包含页面所需的字符，减少字体文件的大小。
5. **`模块化开发`**：
   - 使用模块化开发工具（如Webpack、Parcel等）来`对 CSS 进行模块化管理和打包`，`只打包页面所需的 CSS 文件`，减少冗余和不必要的代码。
6. **`CDN 加速`**：
   - 使用内容分发网络（CDN）来`加速 CSS 文件的加载`，提高网页的访问速度。
7. **`缓存和资源优化`**：
   - 合理设置缓存策略，利用`浏览器缓存和服务器缓存`来`减少重复加载 CSS 文件的次数`。
   - 将CSS文件放置在静态资源服务器上，通过优化服务器配置来提高文件的传输速度。

## 排序算法有哪些,时间复杂度多少

| 算法     | 最快时间复杂度 | 最慢时间复杂度 | 平均时间复杂度 | 空间复杂度 | 简单介绍                                                     |
| -------- | :------------: | :------------: | :------------: | :--------: | :----------------------------------------------------------- |
| 冒泡排序 |      O(n)      |     O(n^2)     |     O(n^2)     |    O(1)    | 通过比较相邻元素，将较大的元素逐步“冒泡”到数组的末尾。       |
| 选择排序 |     O(n^2)     |     O(n^2)     |     O(n^2)     |    O(1)    | 从未排序部分选择最小（或最大）元素并放入已排序部分。         |
| 插入排序 |      O(n)      |     O(n^2)     |     O(n^2)     |    O(1)    | 将元素逐个插入已排序的部分，以构建有序数组。                 |
| 快速排序 |    O(nlogn)    |     O(n^2)     |    O(nlogn)    |  O(logn)   | 使用分治法将数组划分为较小的子数组，然后递归地排序子数组。   |
| 归并排序 |    O(nlogn)    |    O(nlogn)    |    O(nlogn)    |    O(n)    | 将数组分成两半，递归地排序每一半，然后合并两个有序子数组。   |
| 堆排序   |    O(nlogn)    |    O(nlogn)    |    O(nlogn)    |    O(1)    | 使用堆数据结构，将数组视为完全二叉树，然后进行排序。         |
| 希尔排序 | 取决于步长选择 | 取决于步长选择 | 取决于步长选择 |    O(1)    | 通过多次插入排序，每次使用不同的步长，逐渐改进数组的有序性。 |
| 基数排序 |    O(logRB)    |    O(logRB)    |    O(logRB)    |   O(RB)    | 按照位数（个位、十位、百位等）对数字进行排序，从低位到高位。 |

## [HMR] Waiting for update signal from WDS...

1. **HMR**：全称为 Hot Module Replacement（热模块替换）。这是一种技术，允许开发者在应用运行时替换、添加或删除模块，而无需完全重新加载页面。这大大提高了开发效率，因为你可以实时看到更改的效果。
2. **WDS**：全称为 Webpack Dev Server（Webpack  开发服务器）。这是一个小型的 Express 服务器，它使用 webpack 与浏览器进行通信，并且利用 sockjs  提供实时重载功能。它主要用于在开发期间提供 assets（由 webpack 构建）。

![image-20240424150054247](D:\Js\assets\image-20240424150054247.png)

## 展开操作符为什么能确保响应性系统能够捕捉到数据变化

在许多现代JavaScript框架中（如Vue.js和React），响应性系统依赖于对数据对象或数组的引用更改来检测状态变化。这种响应式侦测通常是通过代理（Proxy）或者其他机制实现的，使得框架能够侦听数据结构的变化并相应地更新UI。

### 展开操作符的作用

使用展开操作符 `...` 来拷贝数组是一种常用的技术，它可以帮助确保在数据结构上的更改能被响应性系统捕捉到：

1. **创建新的引用：** 使用展开操作符（`...`）在创建新数组时，实际上是对数组元素进行了浅拷贝到一个全新的数组对象中。这意味着新数组和原始数组不共享同一个引用。示例：

   ```javascript
   let newArray = [...oldArray];
   ```

   在这个过程中，`newArray` 和 `oldArray` 指向不同的内存地址，尽管它们包含的元素是相同的（浅拷贝）。

2. **响应性侦测：** 在响应式框架中，重新赋值通常是通过设置新的引用来触发更新。例如，如果你有一个响应式变量 `menu.value` 来存储菜单数据，并且你通过直接赋值来更改它：

   ```javascript
   menu.value = [...data];
   ```

   这里，`menu.value` 获取了一个全新的数组对象，其内部元素来自于 `data`。响应性系统（比如 Vue.js 的 reactivity system 或者 React 的 setState）会侦测到 `menu.value` 的引用发生了变化，因此会触发界面的更新。

3. **避免直接突变：** 直接修改原始状态（如添加、删除或修改数组中的元素）而不更改引用，有时可能不会触发更新，因为响应性系统可能没有检测到引用级别的变化。通过创建一个新的数组并重新赋值，你确保了状态的突变是可追踪的，从而确保UI能够相应地更新。

### 总结

总的来说，使用展开操作符创建一个数组的新副本并重新赋值到响应性变量可以确保：

- 响应性系统能够侦测到数据结构上的引用变化。
- 触发依赖于该数据的组件或计算属性等的重新渲染。
- UI始终能够反映最新的状态，保持数据与视图的同步。

## 什么是`运行时`

### **TypeScript 是带有编译时类型检查器的 JavaScript `运行时`**



在计算机编程领域，"运行时"（runtime）有几种不同的含义，但通常它指的是`运行程序的时候发生的操作和环境`。这可以涉及到软件被加载、执行，以及提供程序所需的任何支持的时期。具体到编程语言中，运行时可以指代下面这些概念：

#### 1. 运行时环境（Runtime Environment）

这是指支持程序执行的软件环境。例如，Java 程序运行在 Java 虚拟机（JVM）上，而 JavaScript 程序通常运行在浏览器的  JavaScript 引擎中（如 V8 引擎）或在 Node.js 的环境中。这个环境负责管理代码的执行、内存分配、垃圾回收等。

#### 2. 运行时库（Runtime Library）

运行时库是一组预编写的软件函数或工具，程序在运行时可以调用这些函数或工具。它们包括进行输入输出、处理字符串、内存管理等操作的函数。例如，C 语言有一个标准的运行时库，提供文件操作、内存分配等基础功能。

#### 3. 程序的运行时

这可以指程序实际运行的阶段，即从程序开始执行到程序结束的整个时间段。在这个阶段，程序中的各种计算、条件判断、循环等都会实际执行。

#### TypeScript 中的“运行时”

当谈论到 TypeScript 的“运行时”，其实有些混淆。因为 TypeScript 本身是 JavaScript  的一个`超集`，它需要被编译成 JavaScript 才能在任何能运行 JavaScript 的环境（如网页浏览器或 Node.js）中执行。因此，**TypeScript 的运行时实际上就是 JavaScript 的运行时**。



TypeScript 为 JavaScript 添加了`类型系统`，并且在开发环境中`通过编译器进行类型检查`，但`这一过程只发生在编译时`。一旦  TypeScript 被编译（转译）成 JavaScript，它就不再具有任何额外的运行时行为；它的运行时表现与普通的 JavaScript  没有区别。

## 数组扁平化(多维转一维数组)

在JavaScript中，将二维数组或者含有嵌套数组的数组转换成一维数组有多种方法。这种操作通常被称为“扁平化”数组。对于数组 `let arr = [1,2,[3,4],5]`，下面是几种常见的方法进行扁平化处理：

### 1. 使用 `Array.prototype.flat()`
`Array.prototype.flat()` 方法可以创建一个新的数组，其中所有的子数组元素都被递归地按照指定深度连接到新数组中。

```javascript
let arr = [1, 2, [3, 4], 5];
let flatArray = arr.flat(); // 默认深度是 1
console.log(flatArray); // 输出: [1, 2, 3, 4, 5]
```

### 2. 使用 `Array.prototype.reduce()` 和 `Array.prototype.concat()`
这种方法利用 `reduce` 来累加每个元素，如果元素是数组就用 `concat` 方法来扩展。

```javascript
let arr = [1, 2, [3, 4], 5];
let flatArray = arr.reduce((acc, val) => acc.concat(val), []);
console.log(flatArray); // 输出: [1, 2, 3, 4, 5]
```

### 3. 使用递归函数手动扁平化
如果数组的嵌套层级非常深，可以自定义一个递归函数来处理。

```javascript
function flatten(arr) {
    let result = [];
    arr.forEach((element) => {
        if (Array.isArray(element)) {
            result = result.concat(flatten(element)); // 递归扁平化
        } else {
            result.push(element);
        }
    });
    return result;
}

let arr = [1, 2, [3, 4], 5];
let flatArray = flatten(arr);
console.log(flatArray); // 输出: [1, 2, 3, 4, 5]
```

### 4. 使用扩展运算符 `...`
这种方法和 `reduce` 结合使用，可以有效地展开一层嵌套的数组。

```javascript
let arr = [1, 2, [3, 4], 5];
let flatArray = arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? [...val] : val), []);
console.log(flatArray); // 输出: [1, 2, 3, 4, 5]
```

### 5. 利用 `toString` 和 `split`
这是一种比较取巧的方法，可以在一些简单的场景下使用，但它将所有元素转换为字符串，然后再转换回数字。

```javascript
let arr = [1, 2, [3, 4], 5];
let flatArray = arr.toString().split(',').map(Number);
console.log(flat theiray); // 输出: [1, 2, 3, 4, 5]
```

### 6. 利用 `Array.prototype.flatMap()`
`flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压平到新数组。它只能扁平一层。

```javascript
let arr = [1, 2, [3, 4], 5];
let flatArray = arr.flatMap(x => x);
console.log(flatArray); // 输出: [1, 2, 3, 4, 5]
```

这些方法中，推荐使用 `flat()` 方法或是递归方法，因为它们语义清晰，而且 `flat()` 方法是现代JavaScript标准的一部分。其他方法依具体情况选用，尤其考虑到性能和代码的可读性。

## 箭头函数和普通函数的this指向

```javascript
var obj = {
  name: 'obj',
  foo1: () => {
    console.log(this.name)
  },
  foo2: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var name = 'window'
obj.foo1()
obj.foo2()()
```

在 JavaScript 中，函数内 `this` 的值取决于函数是如何被调用的，以及该函数是如何定义的（传统函数还是箭头函数）。以下是对你给出的代码中各函数调用时 `this` 值的一个详细解释：

1. **`obj.foo1()` 调用**:
   - `foo1` 是使用箭头函数定义的。在箭头函数中，`this` 是在函数创建时词法绑定的，也就是说箭头函数不会创建自己的 `this` 上下文，它只会捕获其所在上下文的 `this` 值。在你提供的代码片段中，`foo1` 是在全局范围内创建的，而在全局范围内（在非严格模式下），`this` 指向全局对象，即 `window`。因此，`console.log(this.name)` 在 `foo1` 中输出的是 `window.name`，由于你已经在全局作用域定义了 `var name = 'window'`，所以输出的是 'window'。

2. **`obj.foo2()` 调用**:
   - `foo2` 是一个传统的函数表达式。对于非箭头函数，`this` 的值完全取决于函数的调用方式。由于 `foo2` 是作为对象 `obj` 的方法被调用的（即通过 `obj.foo2()`），在这种情况下，`this` 被自动设置为调用方法的对象，即 `obj`。因此，`console.log(this.name)` 在 `foo2` 的执行环境中输出 'obj'，这是因为 `this` 指向 `obj`，而 `obj.name` 等于 'obj'。

3. **`obj.foo2()()` 再调用返回的箭头函数**:
   - 在 `foo2` 内部返回的是一个箭头函数。如前所述，箭头函数不会创建自己的 `this` 上下文，它`捕获并使用在它创建时所处的上下文中`的 `this` 值。因为这个箭头函数是在 `foo2` 的环墼中创建的，而当时 `foo2` 的 `this` 绑定到了 `obj`，所以这个返回的箭头函数里的 `this` 也将指向 `obj`。因此，当你通过 `obj.foo2()()` 调用这个箭头函数时，它里面的 `console.log(this.name)` 输出的依旧是 'obj'。

总结来说，箭头函数与传统函数在 `this` 绑定上有本质的不同。箭头函数不会为 `this` 创建绑定，它简单地从它自己的上下文链中继承 `this`，而传统函数的 `this` 则取决于如何调用这个函数。在这个例子中，这导致了在不同场景下 `this.name` 的输出有 'window' 和 'obj' 的不同。



##### `自问` foo1创建时所处的上下文不是obj吗

在 JavaScript 中，箭头函数的 `this` 值是在`函数定义时`（而不是在执行时）捕获的，且其 `this` 值取决于上层作用域的 `this`。即使箭头函数位于某个对象内部，它依然不会将 `this` 绑定到该对象上，而是继续捕获包含它的（词法上的）外部函数的 `this` 值。如果外部没有函数，那么在全局作用域中，`this` 会指向全局对象（在浏览器中是 `window`），也就是箭头函数在全局代码中定义时的情况。

在给定的代码示例中，即使 `foo1` 被定义为对象 `obj` 的属性，箭头函数 `foo1` 并没有“看到” `obj` 作为它的上层作用域，而是继承了更外层作用域（全局作用域）的 `this`。因此，即使它在对象 `obj` 里面定义，它在执行时 `this` 依然指向全局对象。

这种行为与在哪里（或在哪个对象中）调用箜头函数无关；它完全取决于函数定义时的外围作用域。由于 `foo1` 定义在全局作用域中，它的 `this` 将指向全局对象，这也是为什么当调用 `obj.foo1()` 时，输出的是全局变量 `name` 的值（假设是在浏览器环境中运行，`this` 在全局上下文中通常指向 `window`，且 `window.name` 命中了设置的 `'window'` 字符串值）。

总结，虽然 `foo1` 函数本身是作为对象 `obj` 的方法定义的，但是箭头函数中的 `this` 并不会指向 `obj` 而是其在定义时的上下文环境，也就是全局对象 `window`。希望这次的解释能够更清晰地表明原因。

## 前端框架,像vue和react的生命周期和html页面的生命周期有关系吗

Vue 和 React 等前端框架的生命周期与 HTML 页面的生命周期确实有关系，但它们不完全相同。让我们来比较一下：

HTML 页面的生命周期：

1. DOMContentLoaded：DOM 完全加载和解析完成后触发
2. load：页面完全加载后触发（包括所有资源如图片、样式表等）
3. beforeunload：用户离开页面前触发
4. unload：用户离开页面时触发

前端框架（如 Vue 和 React）的生命周期：

这些框架引入了更细粒度的生命周期，主要关注组件级别的变化。

Vue 的主要生命周期钩子：

1. beforeCreate
2. created
3. beforeMount
4. mounted
5. beforeUpdate
6. updated
7. beforeDestroy
8. destroyed

React 的主要生命周期方法（包括旧版和新版）：

1. constructor
2. render
3. componentDidMount
4. shouldComponentUpdate
5. componentDidUpdate
6. componentWillUnmount

关系和区别：

1. 粒度不同：HTML 页面生命周期关注整个页面，而框架生命周期主要关注单个组件。
2. 时间点重叠：某些框架生命周期钩子可能与 HTML 生命周期事件同时发生。例如，Vue 的 mounted 钩子或 React 的 componentDidMount 方法通常在 DOMContentLoaded 事件之后不久触发。
3. 额外功能：框架提供了更多的生命周期钩子，允许开发者在组件的不同阶段执行代码，如数据更新前后、组件销毁前等。
4. 虚拟 DOM：框架通常使用虚拟 DOM，这意味着它们的生命周期与实际 DOM 的操作并不总是直接对应。
5. 框架初始化：在 HTML 页面加载过程中，框架会进行初始化，然后才开始组件的生命周期。
6. 性能优化：框架的生命周期允许更精细的性能优化，如 React 的 shouldComponentUpdate。

总之，虽然前端框架的生命周期与 HTML 页面的生命周期有关联，但框架提供了更细致和强大的控制机制，使得开发者能更精确地管理组件的行为和状态。了解两者的关系和区别有助于更好地利用框架的特性，同时也能帮助理解整个应用的运行过程。

## async和defer

`async` 和 `defer` 有一个共同点：加载这样的脚本都不会阻塞页面的渲染。因此，用户可以立即阅读并了解页面内容。

但是，它们之间也存在一些本质的区别：

|         | 顺序                                                         | `DOMContentLoaded`                                           |
| :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `async` | **加载优先顺序**。脚本在文档中的顺序不重要 —— 先加载完成的先执行 | 不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。 |
| `defer` | **文档顺序**（它们在文档中的顺序）                           | 在文档加载和解析完成之后（如果需要，则会等待），即在 `DOMContentLoaded` 之前执行。 |

在实际开发中，`defer` 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候。

`async` 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。

## 宏任务与微任务

例子

```javascript
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // 做繁重的任务的一部分 (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      queueMicrotask(count);
    }

  }

  count();
```

这样写有什么用吗,我还是不太理解,为什么要写if呢

您提出了一个很好的问题。让我更详细地解释这段代码的目的和结构：

1. 代码的目的： 这段代码模拟了一个耗时的操作（counting to a large number），同时展示了如何在不阻塞用户界面的情况下执行这种操作。

2. 为什么要使用 if 语句：

   ```javascript
   if (i < 1e6) {
     queueMicrotask(count);
   }
   ```

   这个 if 语句有两个重要作用：

   a. 设定终止条件：

   - 当 i 达到或超过 1,000,000 (1e6) 时，停止计数。
   - 如果没有这个条件，计数会无限进行下去。

   b. 控制任务分割：

   - 使用 queueMicrotask() 将下一次 count() 调用安排为一个微任务。
   - 这允许浏览器在每 1000 次计数后有机会更新 UI 和处理其他事件。

3. 为什么这样写有用：

   - 性能优化：通过将大任务分割成小块，可以避免长时间阻塞主线程。
   - 响应性提升：即使在执行耗时操作时，用户界面仍然保持响应。
   - 进度可视化：用户可以看到实时更新的进度。

4. 不使用这种方法的问题： 如果直接在一个循环中计数到 1,000,000，会导致浏览器暂时无响应，用户界面会冻结，直到计数完成。

5. 实际应用场景： 这种技术可以应用于需要处理大量数据或执行耗时操作的网页应用，例如：

   - 大文件处理
   - 复杂计算
   - 大量数据的前端处理

## 进程与线程的区别,进程的通信方式

一、进程与线程的区别

1. 定义：
   - 进程：是操作系统中的一个执行实体，是系统进行资源分配和调度的基本单位。
   - 线程：是进程中的一个执行流程，是CPU调度和分派的基本单位。
2. 资源占用：
   - 进程：拥有独立的内存空间和系统资源。
   - 线程：共享所属进程的内存空间和资源。
3. 开销：
   - 进程：创建、销毁和切换的开销较大。
   - 线程：创建、销毁和切换的开销较小。
4. 通信：
   - 进程：通信相对复杂，需要特殊的IPC（进程间通信）机制。
   - 线程：可以直接通过共享内存通信，更简单高效。
5. 安全性：
   - 进程：由于拥有独立的内存空间，一个进程崩溃通常不会影响其他进程。
   - 线程：同一进程内的线程崩溃可能会导致整个进程崩溃。
6. 数据共享：
   - 进程：数据共享复杂，需要特殊的IPC机制。
   - 线程：可以方便地共享数据。

二、进程的通信方式

1. 管道（Pipe）：
   - 用于具有亲缘关系的进程间通信。
   - 半双工通信，数据只能单向流动。
2. 命名管道（Named Pipe）：
   - 可用于无亲缘关系的进程间通信。
   - 可以双向通信。
3. 消息队列（Message Queue）：
   - 消息的链表，存放在内核中。
   - 独立于发送和接收进程。
4. 共享内存（Shared Memory）：
   - 最快的IPC方式。
   - 多个进程可以直接读写同一块内存空间。
5. 信号量（Semaphore）：
   - 主要用于进程间同步。
   - 也可用于进程间传递有限的信息。
6. 信号（Signal）：
   - 用于通知接收进程某个事件已经发生。
7. 套接字（Socket）：
   - 可用于同一机器或不同机器上的进程间通信。
   - 常用于网络通信。
8. 文件映射（Memory-mapped File）：
   - 将文件或其他对象映射到进程的地址空间。
   - 实现了进程间共享内存。

## java跟js的区别

语言类型：

- Java: 静态类型、编译型语言
- JavaScript: 动态类型、解释型语言

运行环境：

- Java: 主要在Java虚拟机(JVM)上运行
- JavaScript: 主要在浏览器中运行，也可以在Node.js等环境中运行

应用领域：

- Java: 主要用于后端开发、Android应用开发、大型企业级应用等
- JavaScript: 主要用于前端web开发，也可用于后端(Node.js)、移动应用开发等

面向对象：

- Java: 完全面向对象
- JavaScript: 基于原型的面向对象

类型系统：

- Java: 强类型，变量必须声明类型
- JavaScript: 弱类型，变量类型可以动态改变

编译过程：

- Java: 需要编译成字节码后运行
- JavaScript: 直接解释执行

多线程：

- Java: 支持多线程
- JavaScript: 单线程（尽管有异步编程模型）

内存管理：

- Java: 自动垃圾回收
- JavaScript: 自动垃圾回收，但管理方式不同

语法：

- 虽有一些相似之处，但整体语法差异较大

标准库和生态系统：

- Java: 拥有庞大的标准库和第三方库
- JavaScript: 标准库相对较小，但有大量的npm包可用

## 有ipv4了为什么还要有ipv6

1. 主要原因：地址耗尽
   - 简述：IPv4的42亿个地址已接近用尽，无法满足当今互联网设备的需求。
   - 数据点：提及IoT设备预计将达到数百亿，远超IPv4地址容量。
2. 技术改进
   - 安全性：IPv6内置IPSec，提供更好的网络层安全。
   - 效率：简化的头部结构，提高数据包处理速度。
   - QoS：通过流标签和优先级改进服务质量。
3. 现代网络需求
   - 自动配置：支持无状态地址自动配置（SLAAC），简化网络管理。
   - 移动性：better支持移动设备和5G网络。
   - 直接连接：减少NAT使用，实现真正的端到端连接。
4. 未来技术支持
   - IoT：为海量物联网设备提供充足地址空间。
   - 5G和未来网络：满足高速、大容量网络的需求。
5. 全球互联网发展
   - 新兴市场：为缺乏IPv4地址的地区提供发展机会。
   - 数字化转型：支持全球范围内的数字化进程。
6. 总结
   - IPv6不仅解决了地址短缺问题，还为未来网络技术和应用提供了基础。
   - 强调IPv6是互联网可持续发展的必要条件。





1. 地址空间耗尽：
   - IPv4只有约43亿个唯一地址，随着互联网设备的激增，这些地址已经接近用尽。
   - IPv6提供了128位地址空间，理论上可以为2^128个设备分配唯一地址，这个数字几乎是无限的。
2. 更好的安全性：
   - IPv6内置了IPSec（Internet Protocol Security），提供了更好的加密和认证机制。
   - 改进了对网络层安全的支持。
3. 简化的头部结构：
   - IPv6的头部结构更加简单，有助于提高数据包的处理速度和效率。
4. 改进的服务质量（QoS）：
   - IPv6通过流标签和优先级字段提供了更好的QoS支持。
5. 自动配置：
   - IPv6支持无状态地址自动配置（SLAAC），使得网络设置更加简单。
6. 更好的移动性支持：
   - IPv6改进了对移动设备的支持，更适合移动互联网时代。
7. 消除NAT（网络地址转换）的需求：
   - 由于地址充足，IPv6可以为每个设备分配公网IP，减少了对NAT的依赖。
8. 更好的多播支持：
   - IPv6改进了对多播的支持，有利于流媒体等应用。
9. 简化网络管理：
   - 地址自动配置和端到端连接性使网络管理变得更加简单。
10. 为物联网（IoT）做准备：
    - 随着IoT设备的增多，需要更多的IP地址，IPv6可以满足这一需求。
11. 新功能和未来扩展：
    - IPv6的设计考虑了未来的扩展性，为新的互联网功能和应用提供了基础。
12. 全球互联网发展：
    - 某些地区（如亚太地区）的IPv4地址已经严重不足，IPv6为这些地区的互联网发展提供了机会。

## nextTick

在Vue.js中，`nextTick()` 函数是一种非常有用的方法，它用于延迟执行代码，直到下一次的DOM更新周期之后。这意味着它确保所有的DOM更改都已完成，并且渲染过程已经稳定下来后，你的代码将会运行。

### 作用和用途

1. **确保DOM更新完成**: 当你在组件的数据上做出修改时，Vue更新DOM的变化是异步执行的。如果你立即尝试访问或操作DOM（比如获取一个元素的尺寸或位置），可能会得到未更新的值。`nextTick` 允许你在DOM更新完成后执行代码，确保你的代码看到的是最新的DOM状态。
2. **解决由于异步更新导致的问题**: 在Vue的响应式系统中，数据变化后DOM的更新并不是立即发生的，而是被异步延迟的。如果你依赖于最新的DOM状态来执行操作（如滚动到一个新添加的元素），使用 `nextTick` 可以确保操作执行时DOM已经被更新。

### 示例

```javascript
export default {
  data() {
    return {
      message: "Hello"
    };
  },
  methods: {
    updateMessage() {
      this.message = "Hello, World";
      // 立即查询这个元素可能获取不到最新的DOM
      console.log(document.getElementById('message').innerText);  // 输出: Hello
      
      // 使用nextTick以确保获取更新后的DOM
      this.$nextTick(() => {
        console.log(document.getElementById('message').innerText);  // 输出: Hello, World
      });
    }
  }
}
```

在这个示例中，修改数据 `message` 后，我们立即打印了元素的内容和使用 `nextTick` 后打印该元素的内容。没有 `nextPanel` 的直接访问可能拿到旧的DOM状态，而 `nextTick` 确保获取的是新状态。

### 使用场景

- 当你需要确保视图完全更新后再执行某些操作时。
- 在修改数据后，需要基于最新的视图状态进行DOM操作或执行某些后续逻辑。
- 测试或调试过程中，确定Vue实例的状态和DOM的一致性。

## map和set的原理以及区别

在JavaScript中，`Map`和`Set`是两种常用的数据结构，它们在ES6版本中被正式引入。尽管两者都用于存储数据，但它们的用途和内部实现原理有所不同。

### Map

#### 原理:

- **Map** 是键值对的集合，类似于对象，但键可以是任意类型的值，包括对象、数组或任何其他的原始类型。
- 内部实现通常是通过哈希表实现的，但具体实现取决于JavaScript引擎。哈希表是一种使用哈希函数来计算数据存储位置的数据结构，从而实现快速的数据查找、添加和删除等操作。

#### 特点:

- 键的唯一性：不会有重复的键存在于Map中。
- 保持键值插入的顺序。
- 直接可以通过大小（size属性）获取元素个数。

### Set

#### 原理:

- **Set** 是值的集合，每个元素只能出现一次，即所有元素都是唯一的。
- Set的实现通常也基于哈希表，以支持快速访问和修改集合。Set中的每个元素被视为键和值相同（或者仅作为键），这一点类似于只有键没有值的Map。

#### 特点:

- 元素的唯一性：集合中不会有两个相同的元素。
- 元素的排序：和Map一样，Set保持元素的插入顺序。
- 对象引用：如果你添加了一个对象的引用到Set中，即使两个对象内容相等，只要它们的引用不相同，它们都会被添加到Set中。

### Map和Set的区别

1. **用途的不同**:
   - `Map`保存键值对集合，你可以通过键来获取值。
   - `Set`仅保存键（值）的集合，用于检查数据是否存在。
2. **键的类型**:
   - `Map`的键可以是任意值，包括函数、对象或任何原始类型。
   - `Set`的元素也几乎可以是任何类型，但在Set中它们只作为值存在。
3. **API方法**:
   - `Map`有 `.get()`, `.set()`, `.has()`, `.delete()` 等方法。
   - `Set`有 `.add()`, `.has()`, `.delete()`, `.clear()` 等方法。
4. **性能**:
   - `Map`对于键值对的插入、删除和查找都提供较快的操作，尤其是当键是非字符串类型时。
   - `Set`在检查值是否存在、删除值和添加值时也具有高效的性能。
5. **实现原理相似**:
   - 通过哈希表来管理数据，这允许两种结构在存储和搜索数据时具有较高的效率。

### 使用场景

- 使用`Map`当你需要关联数据，并通过键快速检索数据。
- 使用`Set`当你需要检查某项数据是否已经存在于集合中，或者当你需要存储一个集合的唯一项时。

哈希表（Hash Table），也称为散列表，是一种广泛使用的数据结构，它提供了非常快速的数据插入、查找和删除操作的平均时间复杂度，通常是O(1)，即常数时间复杂度。在最坏的情况下（比如发生大量哈希冲突时），哈希表操作的时间复杂度可以退化到O(n)。哈希表通过使用哈希函数对存储的数据进行处理，将输入（通常是一个键）转换成一个数组索引来实现这些操作。

### 原理

1. **哈希函数**: 哈希表使用一个哈希函数将插入的键转换为数组的索引。理想的哈希函数应该快速计算，并且尽可能均匀地将键分配到数组索引上，以减少冲突（两个键映射到同一索引）。
2. **数组结构**: 哈希表底层通常使用数组来存储数据。每个键通过哈希函数转换成一个数组的索引，相关的值则存储在数组的这个位置上。
3. **冲突解决**: 当两个键的哈希值相同，即它们映射到同一数组位置时，就会发生冲突。解决冲突的常用方法有：
   - **开放寻址**（Open addressing）: 当发生冲突时，寻找数组中的下一个空闲位置。
   - **链表法**（Chaining）: 每个数组元素维护一个链表，所有映射到该索引的元素都会被添加到这个链表中。
   - **双重哈希**（Double hashing）: 使用第二个哈希函数来决定探查序列。

### 功能和应用

- **插入（Put）**: 插入键值对时，使用哈希函数将键转换成数组索引，并将值存储在该索引位置。
- **删除（Remove）**: 删除键时，同样使用哈希函数找到数组索引并进行删除操作。
- **查找（Get）**: 查找键对应的值时，使用哈希函数确定数组索引并获取存储在那里的数据。

### 优点

- **快速操作**: 在没有发生或发生少量冲突的情况下，哈希表的大部分基本操作（插入、删除、查找）可以在常数时间内完成。
- **空间效率**: 尽管哈希表可能需要额外的空间来解决哈希冲突，但它通常使用空间换取时间的效率。

### 缺点

- **哈希冲突**: 哈希冲突是哈希表的主要问题，需要通过良好的哈希函数和冲突解决策略来处理。
- **动态扩展**: 当哈希表元素过多时，负载因子（即元素个数与数组长度的比率）会增加，可能需要重新哈希所有键值到一个更大的哈希表中。

哈希表在许多编程语言中都有实现，如Java的HashMap、Python的字典（dict）、和JavaScript的对象或Map等。它们广泛应用于需要快速数据访问的场合，如数据库索引、缓存实现、查找表、防止数据重复等场景。

## this指向

```javascript
let name = 'a'
let obj = {
    name: 'b',
    func: () => console.log(this.name)
}
obj.func()
//undefined
为什么输出是undefined
```

在这个代码示例中，您使用了一个箭头函数来定义 `obj.func`。箭头函数的一个关键特性是它不会创建自己的 `this` 上下文。相反，箭头函数捕获其在定义时所处的上下文的 `this` 值。在您的示例中，因为 `obj.func()` 是在全局作用域中定义的（即使它被赋给了一个对象的属性），其 `this` 指向的是全局对象（在浏览器中通常是 `window`），而不是 `obj` 对象本身。

因为您是在严格模式之外编写代码，所以全局作用域下的 `this` 默认指向全局对象 `window`。==在全局对象 `window` 上并没有定义一个名为 `name` 的变量==（除非已经在其他地方这样做了），所以 `this.name` 的结果是 `undefined`。

这里需要注意的是，即使 `obj` 对象内部有一个 `name` 属性，箭头函数并不会将 `this` 绑定到定义它的对象 `obj`，而是继承定义它时的上下文的 `this`。这是箭头函数与常规函数在 `this` 行为上的主要差异。

```javascript
let name = 'a'
let obj = {
    name: 'b',
    func: () => console.log(name)
}
obj.func()
//a
```

## var的特性

在JavaScript中，当你使用`var`关键字在全局作用域中声明变量时，这个变量会成为`window`对象的属性（这里假设是在浏览器环境中）。这意味着，当你在浏览器中的全局作用域使用`var`声明变量，你实际上是在给`window`对象添加属性。

例如：

```javascript
var x = 5;
console.log(window.x);  // 输出 5
```

这种行为是`var`声明的特性之一，并且与`let`和`const`关键字不同，后者在全局作用域中声明变量时不会将这些变量添加到`window`对象。

一个重要的点是，在使用`var`声明变量时还有一些其他特性要注意，如变量提升。变量提升意味着变量可以在声明之前使用，尽管实际的初始化仍必须在声明后发生。

例如：

```javascript
console.log(y);  // 输出 undefined，而不是抛出 ReferenceError 错误
var y = 10;
```

在这个例子中，变量`y`在声明语句执行之前就已经存在，但是它的值是`undefined`直到执行到声明语句的位置。这种提升行为只适用于`var`声明的变量，不适用于`let`或`const`声明的变量。
