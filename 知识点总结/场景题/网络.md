## 为什么浏览器会有跨域限制

浏览器实施跨域限制（Cross-Origin Resource Sharing, CORS）的主要原因是为了保障网站和用户的安全。跨域限制是通过同源策略（Same-Origin Policy, SOP）来实现的。以下是一些主要原因：

### 1. 防止跨站请求伪造（CSRF）

同源策略可以防止跨站请求伪造攻击。CSRF 攻击利用用户已认证的状态发起恶意请求，通常目标是未经授权的操作，如转账、修改数据等。跨域限制确保只有同源的请求才能被执行，从而减小这一风险。

### 2. 保护用户隐私和数据安全

浏览器会自动管理用户的会话信息和身份验证信息，如 Cookies。如果没有同源策略的保护，一个恶意网站可以轻易地通过嵌入的脚本访问其他网站的用户数据，甚至可以冒充用户进行操作。同源策略通过限制这些行为保护用户隐私。

### 3. 防止跨域脚本攻击（XSS）

跨域脚本攻击是指恶意站点通过加载或注入脚本攻击其他站点。同源策略限制了从一个域加载的脚本只能影响同一域的内容，从而减少了跨域脚本攻击的可能性。

### 4. 保障资源的完整性和机密性

不同域之间直接访问资源的数据可能会涉及到敏感信息，如 API 请求中的机密数据。同源策略阻止了未经授权的资源访问，从而保护了数据的完整性和机密性。

### 实现原理

同源策略的基本原则是，要访问的资源必须与请求的源具有相同的协议、域名和端口号。否则，浏览器会阻止访问，除非目标服务器在响应头中显式允许跨域请求。

例子：

```javascript
// 从 example.com 请求 example.org 的资源
fetch('http://example.org/data', {
    method: 'GET',
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));

// 如果 example.org 允许跨域访问，它需要在响应头中包含以下信息
// Access-Control-Allow-Origin: http://example.com
```

### 配置 CORS 头

要允许跨域请求，目标服务器需要配置适当的 CORS 头，例如：

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type
```

这些头信息告知浏览器请求是被允许的，并提供了允许的 HTTP 方法和头字段。

### 总结

跨域限制通过同源策略确保网络请求的安全性，避免了各种潜在的安全风险，如 CSRF、XSS 和数据泄露。服务器可以通过适当配置 CORS 头，灵活地允许某些跨域请求，从而在保证安全的前提下实现所需的功能。

## 跨域是服务器拒绝请求还是浏览器拒绝请求

跨域限制主要是由浏览器实施的，而不是服务器。这是因为浏览器实现了同源策略（Same-Origin Policy）作为安全防护措施，防止潜在的跨站点攻击。然而，服务器需要配合配置，以允许或拒绝跨域请求。

### 浏览器的角色：

- **执行同源策略**：浏览器内置的同源策略会阻止网页请求从不同源获取资源，这意味着即使请求到达服务器并成功处理，浏览器仍可能拒绝访问响应的数据。
- **检查CORS头**：浏览器对跨域请求会检查服务器返回的CORS响应头。如果响应头中包含允许该来源的跨域请求的指令（如`Access-Control-Allow-Origin`），则浏览器会允许访问相应的数据；否则，浏览器会阻止访问，即使服务器响应状态码为成功（如200）。

### 服务器的角色：

- **设置CORS响应头**：服务器需配置跨域资源共享（CORS）头，以明确指示浏览器是否允许来自特定源的请求。常见的CORS头包括：
  - `Access-Control-Allow-Origin`：指定哪些域被允许访问资源。
  - `Access-Control-Allow-Methods`：指定允许的HTTP请求方法。
  - `Access-Control-Allow-Headers`：指定允许的请求头。

- **处理预检请求**：对某些跨域请求（特别是那些修改了数据的请求）浏览器会发送一个HTTP OPTIONS请求（即预检请求）来确定实际请求是否被允许。服务器需要正确回应这些预检请求。

因此，虽然跨域限制是由浏览器执行的，但服务器必须进行适当的配置，以在需要时允许跨域访问。通过正确配置服务器响应头，可以告知浏览器跨域访问是被允许的，这样可以实现跨域数据交互。

## 为什么http2.0可以实现多路复用

HTTP/2 引入了许多新特性，以提高性能和效率，其中一个关键特性就是多路复用（Multiplexing）。多路复用使得一个单一的TCP连接可以承载多个并发的请求和响应，这大幅度提高了网络的利用效率和网页加载速度。下面详细说明HTTP/2为何以及如何实现多路复用。

### HTTP/2的工作机制

#### 1. 二进制分帧层

HTTP/2采用了二进制分帧层（Binary Framing Layer），它将HTTP消息划分为独立的帧并通过单一的TCP连接传输。每个数据流被分解为更小的帧，这些帧会混杂在同一个连接中传输，而接收端再组装这些帧，从而恢复原始的HTTP请求/响应。

#### 2. 流（Stream）和帧（Frame）

- **流（Stream）**：流是HTTP/2通信中的一个独立的双向通信数据流，可以并行传输。这些流被赋予一个唯一的流ID。
- **帧（Frame）**：每个流中的数据被切分成更小的帧，帧是HTTP/2通信的最小单位。帧带有标识其所属流的流ID。

#### 3. 多路复用

HTTP/2的多路复用机制允许多个流在同一个TCP连接上同时发送。通过这种机制，客户端和服务器可以在同一连接上独立地发送和接收多条流的信息，而不会阻塞其他流的传输。

### 多路复用的实现原理

HTTP/2多路复用的实现依赖以下机制来确保数据流的顺利传输和组装：

#### 1. 帧的类型化

每个HTTP/2帧包含一个流ID，不同类型的帧用于不同的目的，例如：

- **HEADERS帧**：用于发送HTTP头部信息。
- **DATA帧**：用于发送HTTP主体数据。
- **PRIORITY帧**：用于调整流的优先级。
- **RST_STREAM帧**：用于取消某个流。

#### 2. 流控制

HTTP/2支持流量控制（Flow Control），用于管理在单一连接上传输的数据量。流控制是基于窗口（Window）的机制，比如每个流都有其独立的流控制窗口，这可以帮助避免发送过多的数据造成接收端的溢出。

#### 3. 头部压缩

HTTP/2引入了HPACK压缩算法，对头部信息进行压缩，使得头部数据更小，从而减少了冗余数据的传输，进一步提高了传输效率。

### 为什么HTTP/2能比HTTP/1.x更高效？

#### 1. 消除队头阻塞（Head-of-Line Blocking）

在HTTP/1.1中，队头阻塞是一个常见问题：因为所有的请求都需要通过同一个TCP连接，如果一个请求阻塞了，后续所有请求都会被延迟。HTTP/2通过多路复用在单一连接上并发传输多个流，从而消除了队头阻塞的问题。

#### 2. 减少连接数

HTTP/2允许在一个TCP连接上并发多个请求，这减少了对多个TCP连接的需求。每个TCP连接的建立和维护都需要消耗资源，而减少连接数可以减小服务器和客户端的负担，并减少TCP握手和慢启动时间。

#### 3. 更高的传输效率

由于HTTP/2使用二进制分帧和头部压缩，传输的数据更加紧凑和高效，减少了带宽的使用。

### 总结

多路复用是HTTP/2的关键特性，通过以下方式实现：

- 使用二进制分帧层将数据分解成更小的帧，并在同一TCP连接中传输。
- 引入流和帧的概念，使得单一连接支持多个并发流。
- 通过流控制和头部压缩机制，确保传输的效率和稳定性。

这些改进使得HTTP/2能够有效地提高传输性能，特别是在高延迟和高带宽的网络环境中，显著提升了网页加载速度和整体用户体验。

## 为什么浏览器只能建立6个连接

浏览器对于每个域名的连接数量限制源于对网络资源合理利用以及历史约定的考量，这主要与HTTP/1.1协议的发展阶段和相关规范有关。在HTTP/1.1中，"每个域名最多6个连接"的限制并不是一个硬性规则，而是一个约定俗成的最佳实践，具体原因包括：

1. **避免资源争抢和拥塞**：
   - 浏览器限制每个域名的并发连接数量是为了减少对服务器和网络资源的争抢，防止因为过多连接导致网络拥塞，进而影响网页加载速度和整体用户体验。

2. **历史原因**：
   - 早期HTTP协议版本（特别是HTTP/1.0）不支持持久连接，每个请求/响应对需要新建连接。升级至HTTP/1.1后，引入持久连接和管道化技术，以提升网络效率，但考虑到服务器和网络设备当时的处理能力，对连接数量仍有限制。
   - HTTP/1.1的设计理念中，规范推荐浏览器以限制并发TCP连接的方式来避免过度消耗带宽和阻塞其他请求。

3. **带宽利用和服务器负载**：
   - 限制连接数可以鼓励更好的带宽利用率和有效负载均衡。太多的并发连接可能导致带宽被非优化使用，并增加服务器的负载压力。

4. **协议本身的限制**：
   - HTTP/1.1的队头阻塞问题（Head-of-Line blocking）使得增加过多的并发连接并不能有效解决性能瓶颈。因为在同一连接中如果一个请求阻塞了，后续的请求也会被阻塞，限制连接数迫使开发者寻求优化请求策略。

现代浏览器的确较普遍遵循每域名6个连接的实际实现情况，不过这并非强制标准，不同浏览器和版本可能略有不同。HTTP/2的引入则缓解了此问题，通过多路复用等技术使得一个连接可以同时处理多个请求，降低了对并发连接数的依赖。随着HTTP/3和QUIC协议的引入，网络通信将进一步优化，不再需要这样的连接数限制。

## 为什么某个概念允许浏览器建立多个连接，这不是不好吗

浏览器允许对同一域名建立多个并发连接，虽然看似会增加资源消耗，但实际上这是一个平衡性能和资源管理的策略。以下是详细解释：

### 背景：队头阻塞

在HTTP/1.0和HTTP/1.1协议下，一个HTTP请求对应一个TCP连接，而HTTP/1.1虽然引入了持久连接，但仍然存在队头阻塞（Head-of-Line Blocking）的问题。队头阻塞是指在同一连接上，如果前一个请求被阻塞，后续的请求就无法被处理，必须等到前一个请求完成。

### 多连接的好处

1. **提高网页加载速度**

   - **并行下载**：现代网页往往包含大量资源，例如HTML文件、CSS样式表、JavaScript脚本、图片和视频等。通过允许多个连接，浏览器可以并行地下载这些资源，从而缩短页面加载时间。
   - **避免队头阻塞**：多个连接可以有效地避开队头阻塞问题，使得各连接上的请求独立进行，不会相互影响。

2. **提高用户体验**

   - **快速响应**：用户在访问资源丰富的网页时，能够更快地看到页面内容，从而提升用户体验。
   - **资源预加载**：浏览器可以在后台使用多个连接预加载用户可能会访问的内容，提高互动体验。

### 资源负担的平衡

虽然建立多个TCP连接会增加一定的资源消耗，但有以下几种机制来平衡和优化资源的使用：

1. **连接复用**

   - **HTTP/1.1持久连接**：在HTTP/1.1之前，每个请求都需要建立新的连接。HTTP/1.1引入了持久连接，允许在一个连接中发送多个HTTP请求和响应，减少了建立和关闭连接的成本。
   - **HTTP/2多路复用**：HTTP/2通过多路复用技术，在单一的TCP连接中传输多个并发的流，大大减少了连接数量。同时，二进制分帧和头部压缩技术也进一步优化了传输性能。

2. **适度限制**

   - **并发连接数限制**：为了防止过度使用资源，浏览器对同一域名的并发连接数进行了限制。尽管这个限制因浏览器不同而有所不同，一般设定为4到8个。这样既保证了一定的并发下载能力，又不至于让服务器和网络资源过度消耗。

3. **连接池**

   - **连接复用和共享**：浏览器在合理的时间段内（比如几分钟内）会重用已经建立的连接。不需要每次请求都重新建立一个新的连接，从而减少了连接建立和拆除的开销。

### 新协议的改进

现代协议，如HTTP/2和HTTP/3，进一步改进了这一机制：

1. **HTTP/2**：引入多路复用，允许在单一TCP连接中并发多个流，解决了HTTP/1.1中的队头阻塞问题。这样，一个连接就能处理多个请求和响应，减少了连接数的需求。

2. **HTTP/3**：基于QUIC协议，采用UDP而不是TCP，进一步优化了连接建立和数据传输的效率，减少了连接建立时的延迟，并保留了HTTP/2的多路复用特性，提高了传输效果和效率。

### 结论

浏览器允许对同一域名建立多个并发连接，虽然在一开始会增加一定的资源开销，但这种机制实际上是为了解决早期HTTP协议中的性能问题，提高网页加载速度和用户体验。在现代网络环境中，这种机制通过连接复用、多路复用以及协议优化等手段，确保了资源的有效利用并提升了传输效率。

## 这个开发过程中有使用过 cookie 或者是 local storage， session storage 这种前端的缓存的能力吗，说说场景区别

在Web开发中，`cookie`、`localStorage`和`sessionStorage`都是常用的存储机制，用于在客户端保存数据。它们具有不同的特性，适用于不同的场景：

### Cookie

- **特性**：
  - **持久性**：Cookie的生命周期可以通过设置过期时间来控制。从几秒钟到几年不等。
  - **大小限制**：通常大小限制为4KB。
  - **服务器通信**：在每次HTTP请求中，浏览器都会将Cookie发送到服务器。
  - **安全性**：可以设置`HttpOnly`和`Secure`标志来提高安全性。

- **使用场景**：
  - **会话管理**：用于保存登录状态或用户会话信息。
  - **用户偏好**：记录用户的语言选择、主题等。
  - **跟踪用户行为**：广告商常用Cookie进行用户跟踪和分析。

### localStorage

- **特性**：
  - **持久性**：数据持久存储，除非显式删除，否则数据不会失效。
  - **大小限制**：通常能存储约5MB的数据，具体限制因浏览器而异。
  - **无服务器通信**：数据仅存储在客户端，不随请求发送到服务器。

- **使用场景**：
  - **大量数据存储**：适合于不需要与服务器同步的大量数据，比如保存应用设置或配置信息。
  - **离线应用**：可以用于存储在离线状态下使用的数据。
  - **用户数据缓存**：如缓存用户输入表单的数据，以防页面刷新导致数据丢失。

### sessionStorage

- **特性**：
  - **短暂性**：数据只在单一浏览会话中有效；当浏览器或标签页关闭时，数据会被清除。
  - **大小限制**：与`localStorage`类似，大约为5MB。
  - **无服务器通信**：同样不随请求发送到服务器。

- **使用场景**：
  - **一次性数据存储**：适用于仅在当前会话中需要的数据，如单次填写的表单信息。
  - **页面刷新保持状态**：在一次浏览会话中，允许页面刷新后数据仍然有效。
  - **多标签页隔离**：不同标签页间的数据需要彼此隔离时适用。

### 选择使用场景的区别

- **持久性需求**：若需要数据长时间有效而不随浏览器关闭删除，使用`cookie`或`localStorage`。若只需在当前标签页中有效，选择`sessionStorage`。
- **数据大小**：如果需要存储较大数据，`localStorage`和`sessionStorage`更合适，因为`cookie`的数据量非常有限。
- **服务器通信需求**：若需要在服务器端读取数据，需用`cookie`，因为它会随HTTP请求发送。`localStorage`和`sessionStorage`则不会。
- **安全性顾虑**：对安全要求高的数据不适合存储在`cookie`、`localStorage`或`sessionStorage`中，应该通过更安全的方式如加密或安全传输机制进行处理。

合理使用这些存储机制可以显著提升Web应用的用户体验和性能表现。选择正确的存储方案应根据应用的具体需求、数据类型、持久性及安全性考量。

## 如果你同时打开了两个浏览器的Tab，然后都是www.baidu.com，嗯，然后你在 TAB 1 下面的在对它的 session storage 进行了一些操作，那在 Tab 二下面同域名下这个 session 会同步到 Tab 二下面吗

`sessionStorage` 是在浏览器中用于存储会话级数据的一种机制，它有一些独特的特性，其中一个关键特性是它的数据仅在单个浏览会话中有效，并且在页面会话结束（即浏览器标签页或窗口关闭）时数据会被清除。

### 关于多个 Tab 的行为：

- **独立的会话**：每个浏览器标签页或窗口在同一个域下的 `sessionStorage` 是互相独立的。这意味着如果你在一个标签页中对 `sessionStorage` 进行了修改，另一个打开的标签页不会看到这些变化。
  
- **标签页不共享**：即使是同一个网站（例如 `www.baidu.com`）在不同的标签页中打开，每个标签页都有自己独立的 `sessionStorage` 实例。因此，对 `sessionStorage` 的任何读写操作都仅限于当前的标签页，不会自动同步到其他的标签页，即便它们指向同一个 URL。

### 场景说明：

如果你在 Tab 1 上对 `www.baidu.com` 的 `sessionStorage` 进行了一些操作，比如设置键值对，这些改变不会反映到 Tab 2 上的 `sessionStorage`。Tab 2 上的 `sessionStorage` 仍会保留它自己的初始状态，除非它自己也对 `sessionStorage` 进行操作。

### 使用提示：

- 如果需要在多个标签页之间共享数据，考虑使用 `localStorage`、`cookie` 或其他跨标签页数据共享的方法。
- 用于同一会话的临时数据而不需要持久化存储时，`sessionStorage` 是有用和安全的，因为它的隔离特性。

所以，对于你提到的情况，在 Tab 1 中对 `sessionStorage` 进行的操作不会影响 Tab 2。每个标签页的 `sessionStorage` 是隔离且独立的。

## local storage有什么样的限制？在存储的情况下，比方说触发了什么限制，拿不到 local storage

`localStorage` 是一种方便的客户端存储机制，但它也有一些限制和注意事项。了解这些限制可以更有效地利用 `localStorage`，避免在使用过程中出现问题：

### 限制

1. **容量限制**：
   - 各个浏览器对 `localStorage` 的存储容量有不同的限制，但通常每个域名有5MB左右的存储空间。
   - 当试图存储的数据超过此限制时，会抛出 `QuotaExceededError` 错误。

2. **同源策略**：
   - `localStorage` 遵循同源策略，即只有在相同协议、相同域名、相同端口下的页面才能访问其数据。
   - 不同域或子域无法共享同一个 `localStorage`。

3. **同步操作**：
   - `localStorage` 的操作是同步执行的，这意味着大量数据读写可能会导致性能问题或页面冻结，尤其是在主线程受到阻塞的情况下。

4. **数据格式**：
   - `localStorage` 只能存储字符串格式的数据。如果要存储对象或其他复杂数据类型，需要先将它们转换成字符串（例如使用 JSON.stringify）再存储。

5. **隐私模式**：
   - 在某些浏览器的隐私模式或无痕浏览模式下，`localStorage` 可能被禁用或不保持数据。

6. **浏览器支持**：
   - 虽然大多数现代浏览器都支持 `localStorage`，有些较旧的浏览器可能不完全支持。

### 无法获取 `localStorage` 时的情况

1. **禁用 JavaScript**：
   - 如果用户关闭了浏览器中的 JavaScript，那么任何对于 `localStorage` 的访问都会失败。

2. **隐私设置**：
   - 用户的隐私设置可能禁用了 `localStorage`。在隐私模式下，有些浏览器可能不支持 `localStorage`。

3. **浏览器的存储空间已满**：
   - 如果浏览器的存储配额已经达到上限，那么在继续写入数据时会触发 `QuotaExceededError`。

4. **跨域限制**：
   - 访问不同域的 `localStorage` 会因为同源策略而不被允许。

5. **用户的插件或扩展程序**：
   - 一些插件或扩展程序可能会干扰浏览器的存储机制。

应对这些限制，最好是尝试在使用`localStorage`之前检查其是否可用，并处理可能抛出的异常。这样可以提高应用的鲁棒性和用户体验。例如，在存储数据之前检查现有数据的大小并做出清理策略，或者在访问 `localStorage` 的时候使用 `try-catch` 块来捕获潜在的错误。

## 如果要是 local storage 存满了会怎么样

当 `localStorage` 达到其存储限制时（通常为每个域名约5MB，这可能因浏览器而异），尝试存储更多数据会导致以下情况：

1. **QuotaExceededError**：
   - 浏览器会抛出一个 `QuotaExceededError` 异常。此错误表示试图超过允许的存储空间。
   - 这通常发生在执行 `localStorage.setItem()` 方法时，且只有当新数据使当前存储的数据量超出上限时才会抛出。

2. **无数据写入**：
   - 尝试写入的数据将不会被保存到 `localStorage` 中。原有的数据依然保留，只有超出容量的新数据会被拒绝。

### 如何处理存储已满的情况？

1. **错误处理**：
   - 在使用 `localStorage.setItem()` 写入数据时，使用 `try-catch` 结构捕获 `QuotaExceededError`。这可以防止应用崩溃，并允许你处理错误。

   ```javascript
   try {
       localStorage.setItem('key', 'value');
   } catch (e) {
       if (e instanceof DOMException && e.code === 22) {
           console.error('LocalStorage quota exceeded');
       }
   }
   ```

2. **清理旧数据**：
   - 实施数据清理策略。例如，在存储新数据之前，清理掉不再需要的旧数据以释放空间。
   - 可以通过一开始设计好数据过期机制，比如在记录数据时同时记录时间戳，并定期删除过期的数据。

3. **压缩数据**：
   - 考虑对大块数据进行压缩以节省空间。例如，使用 JSON 的压缩算法。
   - 优化存储的数据结构，确保以更加高效的方式存储数据。

4. **用户反馈**：
   - 在检测到存储溢出错误时，给用户一些反馈或选项，比如清除一些不常用的数据或重新加载页面。

了解并处理 `localStorage` 的存储限制是开发应用时需要考虑的重要部分，有助于确保应用在不同情况下的稳定性和健壮性。

## cookie 有什么限制吗？比如说是什么情况下是前端拿不到这个 cookie 的？然后什么情况下是可以拿到它？有它相对于 local storage 或 session storage 有什么限制？

Cookies 是一种最初用于在客户端和服务器之间维护状态的小型文本数据存储方式。不过，使用 Cookies 会受到一些限制和条件影响，这些限制包括存储容量、安全设置、域名和路径限制等。具体来说：

### Cookies 的限制

1. **容量限制**：
   - Cookies 的大小通常限制为 4KB，每个域名下可以存储的 cookies 数量也是有限的（通常为 20 到 50 个不等，视浏览器而定）。

2. **数据类型限制**：
   - Cookies 只能存储字符串。复杂数据类型（如对象、数组）需要先转换为字符串（通常用 JSON 编码）才能存储。

3. **域名和路径限制**：
   - Cookies 与 domain 和 path 属性关联，限制其在哪些请求中可用。例如，设置特定的 domain 和 path 可以使得 cookies 在特定的子域或路径下可用。

4. **安全属性**：
   - `Secure` 属性：如果设置了此属性，Cookies 只能在 HTTPS 连接中发送。
   - `HttpOnly` 属性：如果设置了此属性，仅服务器端可以访问，限制 JavaScript 访问（无法通过 `document.cookie` 读取），有助于防御一些跨站脚本（XSS）攻击。

5. **SameSite 属性**：
   - `SameSite` 属性用于控制跨站请求时是否发送 cookies。可设置为 `Strict`、`Lax` 或 `None`。

### 前端无法访问 Cookie 的情形

1. **HttpOnly**：
   - 如果设置了 `HttpOnly` 属性，JavaScript 在客户端无法读取该 Cookies。

2. **跨域限制**：
   - Cookies 受制于同源政策，无法跨域访问。即一个域名或子域不能访问由其他域设置的 cookies。

3. **路径和域不匹配**：
   - 如果请求的路径或域不匹配 Cookies 的路径或域属性，Cookies 不会被发送，也无法在前端访问。

4. **浏览器设置**：
   - 用户可以通过浏览器的隐私设置禁用 cookies。

5. **`SameSite` 设置**：
   - 当 Cookies 的 `SameSite` 属性为 `Strict` 或 `Lax` 时，跨站请求可能会阻止 Cookies 的发送。

### Cookies vs. Local Storage/Session Storage

1. **存储容量**：
   - Cookies 大约限制为 4KB，而 `localStorage` 和 `sessionStorage` 的存储容量通常为每域 5MB 或更大。

2. **生命周期**：
   - Cookies 可以设置过期时间，更适合持久化情况，而 `localStorage` 数据没有过期限制，除非用户或代码主动清除。`sessionStorage` 数据在页面会话结束（通常是关闭浏览器标签页）后清除。

3. **通信功能**：
   - Cookies 可以自动随请求发送到与其 domain 和 path 属性匹配的服务器，适合用于需要与服务器通信的情况，而 `localStorage` 和 `sessionStorage` 只能在客户端使用，不会自动随请求发送。

4. **安全性**：
   - Cookies 提供一些安全属性（如 `Secure` 和 `HttpOnly`）来增加安全性，但也可能成为跨站点请求伪造（CSRF）和 XSS 攻击的目标。`localStorage` 和 `sessionStorage` 无这些属性，容易受到 XSS 攻击，需做好输入输出验证。

在选择使用哪种存储机制时，通常需要根据具体的应用场景、数据安全和持久性需求进行权衡。

## cookie 通过什么样的方式来实现前端和服务端的这个共享

Cookies 是一种特殊的 HTTP 头字段，能够在客户端（通常是浏览器）和服务端之间共享数据。其工作机制基于请求-响应模型，具体来说，通过以下方式实现共享：

### 1. 服务端设置 Cookies

服务端通过在 HTTP 响应中设置 `Set-Cookie` 头来创建 Cookies。例如：

```http
HTTP/1.1 200 OK
Set-Cookie: sessionId=abc123; Path=/; HttpOnly
```

#### 详细解析：

- **`Set-Cookie` 头**：这是服务端传递给客户端的命令，告诉浏览器存储一个 Cookies。
- **`sessionId=abc123`**：指示键值对，其中 `sessionId` 是 Cookies 的名称，`abc123` 是其值。
- **`Path=/`**：定义 Cookies 在何种路径下有效。这里的 `/` 表示在该域的所有路径下都有效。
- **`HttpOnly`**：指示此 Cookies 不能通过 JavaScript 的 `document.cookie` 访问，提高了安全性。

### 2. 客户端持久化和发送 Cookies

浏览器接收到来自服务端的 `Set-Cookie` 响应头后，会根据该命令创建和存储 Cookies。在随后的请求中，浏览器会自动将符合条件的 Cookies 发送给服务器。这是通过 HTTP 请求头中的 `Cookie` 字段实现的。例如：

```http
GET /dashboard HTTP/1.1
Host: example.com
Cookie: sessionId=abc123
```

#### 详细解析：

- **`Cookie` 头**：当客户端向服务端发送请求时，浏览器自动附加存储的、符合条件的 Cookies。
- **服务端可以从请求的 `Cookie` 头解析需要的信息。**

### 3. 共享机制

cookies 在客户端和服务端之间共享是通过请求和响应之间的 `Cookie` 和 `Set-Cookie` 头机制实现的：

- **读取 Cookies**：客户端可以使用 JavaScript 读取非 `HttpOnly` 的 Cookies 值，从而实现某些业务逻辑，如个性化展示，但注意安全性。
- **发送 Cookies**：由于请求中的 Cookies 会在每次匹配条件的请求中自动发送给服务端，因此服务端能够保持用户会话的状态并进行适当的响应处理。

### 4. 细节考虑

- **域和路径**：通过设置适当的 `domain` 和 `path`，可以控制 Cookies 被附加在哪些请求上，从而管理访问范围。
  
- **过期时间和生命周期**：使用 `Expires` 或 `Max-Age` 属性设置 Cookies 有效期限，从而控制其生命周期。

- **安全性属性**：使用 `Secure` 属性确保 Cookies 仅通过 HTTPS 发送，使用 `SameSite` 属性限制 Cookies 的跨站请求。

这种机制为客户端和服务端之间的数据共享提供了基础，常用于会话管理、用户追踪、个性化设置等场景。通过合理设置和使用 Cookies，有可能对系统的安全性和用户体验产生深远的影响。

## cookie具体通过哪些字段携带

Cookies 在 HTTP 请求和响应中通过特定的头字段进行传递和管理。以下是请求和响应中涉及 cookies 的关键字段和相关属性：

### 在 HTTP 响应中设置 Cookies

通常在服务器端响应中使用 `Set-Cookie` 头字段来设定 cookies。该字段可以包含多个属性：

1. **Name=Value**：
   - 必须字段，用于定义 Cookies 的名称和值。例如，`sessionId=abc123`。

2. **Expires**：
   - 指定 Cookies 的失效日期。例如，`Expires=Wed, 09 Jun 2023 10:18:14 GMT`。这是一个绝对时间。

3. **Max-Age**：
   - 设置 Cookies 的存活时长（秒数）。使用 `Max-Age=3600` 说明 cookies 在 3600 秒后失效。

4. **Domain**：
   - 指定 cookies 的有效域。例如，`Domain=example.com`。子域名可以共享此 cookies。

5. **Path**：
   - 限定 cookies 的使用路径。例如，`Path=/` 使 cookies 按照网站的根目录适用。

6. **Secure**：
   - 指示 cookies 仅通过 HTTPS 连接传输，增加数据传输过程中的安全性。

7. **HttpOnly**：
   - 设置该属性后，cookies 不可通过 JavaScript 的 `document.cookie` 访问，从而提高安全性。

8. **SameSite**：
   - 控制 cookies 的跨站请求行为。 可能的值包括：`Strict`、`Lax` 和 `None`。

示例：
```http
Set-Cookie: sessionId=abc123; Expires=Wed, 09 Jun 2023 10:18:14 GMT; Path=/; Domain=example.com; Secure; HttpOnly; SameSite=Lax
```

### 在 HTTP 请求中发送 Cookies

客户端（通常是浏览器）会在每次发送符合条件的请求时自动附带 `Cookie` 头字段。客户端的 `Cookie` 字段包含多个 cookies 的名称和值对，用分号和空格分隔。例如：

```http
Cookie: sessionId=abc123; theme=light; userId=789
```

- **Name=Value 对**：请求中携带的 cookies 的名称和值对，可以在请求中包含多个。

每个 cookies 都会根据浏览器管理的域和路径规则决定是否随请求发送，包括但不限于：

- 同源策略限制 cookies 的发送，仅发送到与其域和路径配置相符的服务器。
- `Secure` 选项限制 cookies 仅通过 HTTPS 通信。
- `SameSite` 限制 cookies 的跨域行为。

这些文件头字段和相关属性组合形成了一种灵活且功能强大的机制，确保明智地传递、访问和管理 cookies。它们广泛用于用户会话管理、偏好设置管理以及其他需要维持状态的场景。

## websocket

WebSocket 是一种通信协议，它提供了全双工通信通道，通过单个 TCP 连接实现客户端和服务器之间的即时数据交换。WebSocket 解决了传统 HTTP 协议在双向通信方面的局限性，使得实时应用开发（如在线聊天、股票行情、在线游戏等）变得更加高效和可行。

### WebSocket 的特点和优势

1. **全双工通信**：
   - WebSocket 允许客户端和服务器之间双向同时通信，无需像 HTTP 那样请求-响应的模式。这样可以显著降低延迟，提高实时性。

2. **单个持久连接**：
   - 与短时间即失效的 HTTP 连接不同，WebSocket 在初次连接建立后，保持一个持久的连接，用于传输数据，这减少了额外的 HTTP 连接开销。

3. **减少开销**：
   - 在 WebSocket 中，消息头较小，从而进一步减小了数据传输时的开销，与 HTTP 的高频短连接相比，WebSocket 更节省带宽。

4. **实时性**：
   - 因为信息可以立即从服务器推送到客户端，无需客户端不断轮询服务器。这样可以显著优化实时应用的用户体验。

### WebSocket 通信基础

1. **连接建立**：
   - WebSocket 连接是通过 HTTP/HTTPS 握手建立的。
   - 客户端通过发起带有 `Upgrade` 头的 HTTP 请求来请求从 HTTP 连接升级为 WebSocket 连接。

2. **握手过程**：
   - **客户端请求**：
     ```http
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Version: 13
     ```
   - **服务器响应**：
     ```http
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     ```

3. **数据帧**：
   - WebSocket 通过帧（frame）传输数据。
   - 每个帧包含一个帧头和可选的负载数据。
   - 帧细分了控制信息和负载数据，支持文本（UTF-8 编码）和二进制数据。

4. **关闭连接**：
   - 任何一方都可以发送帧请求关闭连接，并指定一个关闭状态码，表示关闭的原因。

### 使用场景

1. **在线游戏**：
   - 需要实时双向通信，WebSocket 可以提供低延迟的连续性连接。
   
2. **实时聊天**：
   - 支持实时消息发送和接收，不需要客户端轮询服务器。
   
3. **交易系统/股票行情**：
   - 高频率的数据推送，在市场震动时迅速通知客户端。
   
4. **协作编辑平台**：
   - 允许多个用户实时编辑同一文档或项目。

### 实现 WebSocket

#### 在浏览器中

JavaScript API 很简单：

```javascript
// 创建 WebSocket 对象并建立连接
const socket = new WebSocket('ws://example.com/socket');

// 监听连接打开事件
socket.addEventListener('open', function (event) {
    console.log("Connection established!");
    socket.send('Hello Server!');
});

// 监听消息事件
socket.addEventListener('message', function (event) {
    console.log('Message from server:', event.data);
});

// 监听关闭事件
socket.addEventListener('close', function(event) {
    console.log('Connection closed');
});

// 监听错误事件
socket.addEventListener('error', function(error) {
    console.log('WebSocket error:', error);
});
```

#### 在服务器上

服务器可以在不同平台和语言中实现，Node.js 中有多个库可以用来创建 WebSocket。例如，`ws` 是一个受欢迎的库：

```javascript
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
    ws.on('message', function incoming(message) {
        console.log('received:', message);
        ws.send('Hello, client!');
    });

    ws.send('Welcome to WebSocket server!');
});
```

### 安全性和限制

- **安全性**：使用 WSS(`wss://`) 来确保数据传输的加密性。
  
- **跨域**：WebSocket 本身不受限于浏览器的同源策略，但需要注意服务器配置以防止恶意连接。

- **TCP/IP 限制**：由于基于 TCP/IP 协议，WebSocket 不适用于 UDP 的轻量和广播功能要求的应用。

### 总结

WebSocket 是一种强大的工具，能够在现代网络应用中实现实时、高效的数据传输。相比于传统的 HTTP 通信方式，WebSocket 通过其持久连接和全双工通信能力，显著提高了双向实时通信的响应速度和效率。

## websocket的握手流程

WebSocket 的握手流程是将现有的 HTTP/HTTPS 连接升级为 WebSocket 连接的过程。这个过程确保客户端与服务器之间的协议切换是安全可靠的，并由双方确认。握手过程通常包括以下步骤：

### 1. 客户端请求

客户端通过发送一个标准的 HTTP 请求来发起握手请求，但请求中包含一些特殊的头信息，表明希望升级到 WebSocket 协议。

**示例请求**：
```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

- **GET**：请求行中使用 HTTP GET 方法请求建立连接。
- **Upgrade: websocket**：表明请求升级到 WebSocket 协议。
- **Connection: Upgrade**：表示当前连接要被“升级”。
- **Sec-WebSocket-Key**：一个 Base64 编码的随机字符串，由客户端生成，用于后续握手验证。
- **Origin**：说明请求来源，通常用来防止跨域攻击。
- **Sec-WebSocket-Protocol**：可选的，表明协议子集，以此来选择子协议。
- **Sec-WebSocket-Version**：表示 WebSocket 协议的版本，必须是 13。

### 2. 服务器响应

服务器收到请求后，确认请求中 Upgrade 和 Connection 头的值，验证 Sec-WebSocket-Key，返回 HTTP 101 状态代码表示协议切换成功，以及必要的头信息。

**示例响应**：
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

- **101 Switching Protocols**：表示协议切换成功，HTTP 连接被升级。
- **Upgrade: websocket**：确认切换到 WebSocket 协议。
- **Connection: Upgrade**：与请求头相匹配。
- **Sec-WebSocket-Accept**：这是服务器根据客户端提供的 `Sec-WebSocket-Key` 计算得出。服务器将客户端的 `Sec-WebSocket-Key` 和一个固定的全局唯一标识符 `258EAFA5-E914-47DA-95CA-C5AB0DC85B11` 拼接后，使用 SHA-1 哈希进行计算，再通过 Base64 编码得到结果。这个结果用于验证客户端的 WebSocket 握手请求。
- **Sec-WebSocket-Protocol**：表明选中的子协议（如果客户端请求了多个可选子协议）。

### 3. 握手成功

一旦服务器发回了标准的 101 HTTP 响应码，并确认了协议被升级，客户端会开始发送和接收 WebSocket 帧。此后，连接处于活跃状态，直到任一方发起连接关闭操作。

### 小结

WebSocket 握手是通过 HTTP/HTTPS 进行的标准请求/响应通讯过程。这种设计方式确保 WebSocket 可以正常穿越防火墙及代理服务器，因为它最初的请求与常规的 HTTP/HTTPS 请求并无二致。而通过握手过程中的特殊头来判断和进行协议切换，使得连接很安全并高效支持双向实时通信。

## SSE

服务器发送事件（Server-Sent Events，简称 SSE）是一种基于 HTTP 协议的技术，用于从服务器向客户端推送更新数据。SSE 是单向的，只能由服务器向客户端发送数据，不能从客户端向服务器发送数据。SSE 主要用于需要持续数据更新的应用场景，如实时新闻、股票价格、社交媒体更新等。

### SSE 的特点与优势

1. **简单性**：
   - 使用简单，符合 HTTP 协议，易于实施。
   - 不需要复杂的协议处理，仅需在客户端维护一个持久连接。

2. **自动重连**：
   - 浏览器会自动处理连接断开后的重连操作，可以为应用开发提供更高的可用性。

3. **文本事件传输**：
   - SSE 以文本格式发送事件，便于解析和处理。

4. **较低延迟**：
   - 通过持久连接推送数据，通常比传统的 HTTP 轮询方法具有更低的延迟。

5. **广泛的浏览器支持**：
   - 原生支持主流的现代浏览器，虽然不如 WebSocket 普及和强大，但在文本流用途上很有效。

### 工作原理

#### 1. 服务器端

服务器端通过持续发送带有特定格式的文本信息来实现数据推送。这些文本信息具有一定的格式，用于标识事件类型和数据内容。

**示例响应**：
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

retry: 10000
id: 1
event: message
data: Hello, world!

id: 2
data: Another message
```

- **Content-Type: text/event-stream**：设置响应的内容类型为 `text/event-stream`，表明是 SSE 数据流。
- **id**：可选，每个事件的唯一标识符，用于恢复连接时从正确的状态恢复。
- **event**：可选，事件类型名。客户端脚本可以监听特定类型的事件。
- **data**：事件传输的数据内容。可以有多行，连接成单个消息发送。
- **retry**：可选，表示在断开后浏览器重新连接的时间间隔，以毫秒为单位。

#### 2. 客户端

客户端使用 `EventSource` API 来接收服务器发送的事件。`EventSource` 自动处理连接维护和重试。

**示例 JavaScript 客户端代码**：
```javascript
if (typeof(EventSource) !== "undefined") {
    const source = new EventSource('http://example.com/events');

    source.onopen = function(event) {
        console.log("Connection to server opened.");
    };

    source.onmessage = function(event) {
        console.log("New message:", event.data);
    };
    
    source.addEventListener('message', function(event) {
        console.log("Another message:", event.data);
    });

    source.onerror = function(event) {
        console.error("EventSource failed:", event);
    };
} else {
    console.log("SSE not supported by the browser.");
}
```

### 适用的应用场景

1. **实时更新的新闻或博客**：
   - 需要定时刷新以获取最新内容，而 SSE 可以自动推送更新。

2. **实时报价或市场数据**：
   - 如股票、外汇市场监控。SSE 提供了允许客户端持续接收更新的方式。

3. **社交媒体动态**：
   - 实时聊天或消息通知流，实现数据不丢失的新鲜度推送。
   
4. **监控面板**：
   - 某些需要实时展示状态或事件的面板，适合使用 SSE。

### 与其他技术的比较

1. **与 WebSocket**：
   - SSE 是单向的，只能服务器向客户端推送数据，而 WebSocket 是双向的。
   - SSE 使用 HTTP 协议，在原有 HTTP 基础上增加灵活性和简单性，而 WebSocket 则是一个独立协议。

2. **与 HTTP 轮询/长轮询**：
   - 轮询需要客户端定期请求更新，这会带来较大延迟，和服务器负担，长轮询虽然改善了这一点，但实现复杂度增加。
   - SSE 优化了常规 HTTP 的缺陷，通过持久连接降低开销和复杂度。

3. **与 AJAX**：
   - AJAX 主要处理传统的请求-响应模型，而 SSE 专注于实时数据流。

### 总结

SSE 是一种纯文本下的高效事件推送机制，符合 HTTP 标准和简单实现的特性，适用于绝大多数浏览器环境。对于需要由服务器向浏览器频繁推送数据的场景，SSE 提供了一个较为轻量级的解决方案，并且不再需要复杂的客户端轮询逻辑。尽管 WebSocket 更为强大、灵活，能够进行双向通信，但对于许多与流数据推送相似的问题领域，SSE 提供了一个性能优良且简单可靠的工具。

## sse的握手过程

![image-20240825185223905](assets/image-20240825185223905.png)

![image-20240825185241334](assets/image-20240825185241334.png)

服务器发送事件（Server-Sent Events, SSE）使用 HTTP 协议之上的简单文本流来实现服务器向客户端推送事件的功能。相比于 WebSocket 的双向通信，SSE 的握手过程更加简单和直接。它实际上是一个标准的 HTTP 请求，用于建立从服务器到客户端的单向连接。

### SSE 握手过程详解

1. **客户端请求**

   客户端通过一个普通的 HTTP GET 请求来启动 SSE 连接。这个请求目的明确，即请求与服务器建立一个持久的连接来接收事件流。

   ```http
   GET /events HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   ```

   - **GET /events**：请求路径可能是 `/events`，具体根据应用设计。
   - **Accept: text/event-stream**：表明客户端希望接收服务器发送的事件流，这个头尤其重要。

2. **服务器响应**

   服务器接收到请求后，以长连接的方式回复一个特殊格式的响应，response 的内容类型 为 `text/event-stream`。这个响应头表示数据将以事件流的形式持续发送而不是一次性返回：

   ```http
   HTTP/1.1 200 OK
   Content-Type: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
   ```

   - **Content-Type: text/event-stream**：指示响应内容是 SSE 事件流。
   - **Cache-Control: no-cache**：防止代理服务器缓存响应。
   - **Connection: keep-alive**：保持连接的持续性，保证流数据的连续传输。

3. **数据流开始**

   一旦 SSE 连接建立，服务器开始以事件流的形式向客户端发送数据。数据块可以包含几个类型的字段：

   ```http
   id: 1
   event: message
   data: Hello, World!
   ```

   - **id**：事件的唯一标识符（可选），用于断线重连时标识从哪个事件开始。
   - **event**：事件类型（可选），客户端可以针对特定类型事件作出反应。
   - **data**：具体的事件数据，须用`data:`指示，每行一条信息。
   - **retry**：表示客户端应该在断开连接后等待的毫秒数后重新连接（可选）。

4. **客户端事件处理**

   客户端使用 `EventSource` 对象来处理这些事件。`EventSource` 在打开连接、接收数据、出错等情况下都有相应的事件触发：

   ```javascript
   const eventSource = new EventSource('/events');

   eventSource.onmessage = function(event) {
       console.log("Data received:", event.data);
   };

   eventSource.onerror = function(event) {
       console.error("Error occurred:", event);
   };
   ```

5. **自动重连**

   默认情况下，连接中断时，`EventSource` 对象会自动尝试重新连接服务器, 如果成功，客户端可以使用 ID 恢复到它们丢失的事件表.

### 总结

在执行上述过程时，握手细节显得简单而有效，这使得 SSE 特别适合在服务器到客户端的单向更新中使用。这种通信模式不需要复杂的协议切换，且加载小，适宜用在需要实时更新流、推送通知和其他广播信息的场景。与 WebSocket 不同，SSE 是一种更轻量级的协议，与标准 HTTP 兼容，因此易于与现有基础设施集成。

## 为什么ai问答的前端页面使用sse而不是websocket

在构建 AI 问答系统的前端页面时，选择使用 SSE（服务器发送事件）而不是 WebSocket 主要基于以下几个原因：

### 1. 单向数据流

AI 问答应用中的通信模式通常是由用户在客户端发送请求，然后服务器处理后将结果推送给客户端。这种场景天然符合 SSE 的单向数据流模型：

- **SSE**：适合于这种从服务器到客户端的单向数据流，客户端不需要主动向服务器发送持续信息，而只需要接收来自服务器的更新。
- **WebSocket**：设计用于双向通信，当需要频繁的双向数据交换时才更加合适。

### 2. 简单性与便利性

SSE 更加简单，易于实现，对于只需要服务器推消息给客户端的场景，SSE 提供了便捷的解决方案：

- **开发复杂度**：SSE 使用 HTTP 协议之上的文本流，而 WebSocket 则需要处理连接的管理和化繁为简的握手过程。
- **HTTP 友好性**：SSE 在 HTTP 上运行，易于跨越防火墙和代理，对现有的 HTTP 基础设施几乎没有改变。

### 3. 自动重连机制

SSE 有内置的自动重连机制，这一点非常利于提高应用的可用性和用户体验：

- **自动处理断开连接**：浏览器会在连接断开时自动尝试重新连接，而这个过程是透明的，不需要更多的代码实现。
- **方便接续**：借助于事件 ID（`event id`），SSE 可以方便地从中断点继续，使数据流保持一致性。

### 4. 浏览器支持

SSE 在现代浏览器中得到了很好的支持，并且实现方式上对常见场景已经足够：

- **广泛兼容性**：SSE 由大多数现代浏览器原生支持，并且可以在服务端简单实现。
- **自带 API**：SSE 使用 `EventSource` 接口，对开发者非常友好，将复杂性隐藏在 API 之后。

### 5. 延迟和效率

对于一些只需要接收数据而不需要实时发起请求的场景，SSE 是一种比 WebSocket 更高效的选择：

- **低延迟**：SSE 保持一个持久的连接，高效地传输信息，不需要频繁建立连接。
- **更少的资源消耗**：典型应用场景使用 SSE 需要的资源通常比 WebSocket 少，因为不涉及复杂的双向通信和心跳检测。

### 合适的应用场景

AI 问答系统的典型工作流可能是用户在前端进行问题输入，然后后端处理并将答案返回给用户。这种结果推送非常适合采用 SSE：

- 适合一对多广播场景，数据流简单、明确。
- 适用于需要以低延迟推送服务器事件而不需要返回结果的单向互动应用。

### 总结

SSE 很适合 AI 应用场景的原因主要在于通信模式的特性，简便的开发过程，以及 HTTP 友好的标准支持。WebSocket 则多用于复杂的双向通信应用，比如在线游戏、即时通信工具等。因此，在 AI 问答系统中，如果仅仅是为了实现从服务器向客户端推送 AI 计算结果或状态更新，SSE 是一种极为合适的选择

## 前后端交互的网络请求参数。

在前后端交互时，网络请求参数的设计和传递非常关键。这影响到系统的可维护性、安全性、效率和用户体验。以下是一些常见的参数设计及处理方式：

### 网络请求参数分类

1. **路径参数（Path Parameters）**
   - 用于 RESTful 风格的 API，通常用来标识特定资源。
   - 例如：`GET /api/users/{userId}`，其中 `{userId}` 是路径参数。

2. **查询参数（Query Parameters）**
   - 通常附加在 URL 的末尾，用于传递非敏感的、可以在 URL 显示的数据。
   - 格式为：`/api/items?category=books&page=2`。

3. **请求体参数（Body Parameters）**
   - 在 POST、PUT 等请求中，用于传输复杂和大的数据结构。
   - 常用 JSON 作为数据格式，包含在请求体中。

4. **头部参数（Header Parameters）**
   - 用于传递元信息，例如认证信息、客户端信息、内容类型等。
   - 例如：`Authorization: Bearer token`。

### 参数设计原则

1. **简洁明确**
   - 参数命名要清晰，便于理解和使用。例如，使用 `userId` 而不是 `uId`。

2. **安全性**
   - 避免在 URL 和 Header 中传递敏感信息，如密码和密钥。
   - 使用 HTTPS 协议确保数据在网络传输中的安全。

3. **灵活性和扩展性**
   - 在设计 API 时，确保参数能够支持未来的业务扩展。例如，通过引入新的可选查询参数支持更复杂的查询而不破坏现有功能。

4. **数据校验和验证**
   - 在发送请求之前和接收请求时，前后端都应对参数进行验证，确保数据格式和类型正确。

5. **使用规范和标准**
   - 遵从 RESTful 标准，合理使用路径参数、查询参数等。

### 常见的参数处理方式

1. **前端处理**
   - **构建请求**：使用 Fetch API 或 Axios 等库进行请求构建，处理路径、查询和请求体参数。
   - **参数验证**：在发送请求之前进行输入校验，确保参数合法。

2. **后端处理**
   - **解析参数**：从 URL、请求体或头部中解析参数。
   - **验证参数**：使用验证库（如 Joi、express-validator 等）进行参数的进一步验证。
   - **安全检查**：防止 SQL 注入、跨站脚本攻击（XSS）等。

### 例子

假设要设计一个获取用户信息的 API：

- 请求 URL: `GET /api/users/{userId}`
- 路径参数：`userId`，用于识别特定用户。
- 查询参数：如 `details=true` 控制返回的数据是否包括详细信息。
- 头部参数：`Authorization: Bearer token` 用于用户身份认证。

一个典型的请求构建：

```javascript
const userId = 123;
const token = 'your-auth-token';
fetch(`/api/users/${userId}?details=true`, {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
}).then(response => response.json())
  .then(data => console.log(data));
```

通过合理设计和使用网络请求参数，可以大大提高前后端交互的效能，同时确保系统的安全性和可扩展性。

## 项目里用户名和密码是明文传输到后端的吗？

在项目中，**绝对不应该**以明文方式传输用户名和密码。这会严重威胁到用户的安全，因为明文传输的敏感信息很容易被窃听、截取和破解。为了保护用户的敏感信息，以下是一些常见的安全实践：

### 1. 使用 HTTPS 协议

- **加密传输**：确保所有数据，包括用户名和密码，通过 HTTPS 协议传输。这可以加密传输数据，避免在传输过程中被窃听。
- 通过 SSL/TLS 提供安全的通信通道，确保客户端与服务器之间的交互是保密和完整的。

### 2. 密码加密

- **客户端加密（可选）**：虽然 HTTPS 已经足够安全，但在一些高度敏感的应用中，可以在客户端使用加密算法（如 AES）对密码加密，然后再传输。不过，这是一个较少采用的做法，因为 SSL/TLS 本身已经提供了传输层的加密。

### 3. 不要在 URL 传输敏感数据

- 避免将用户名和密码作为查询参数在 URL 中传输，因为 URL 可能会被记录在服务器日志中或浏览器历史中而泄露。

### 4. 后端安全措施

- **哈希存储密码**：在保存用户密码时，绝不应该以明文形式保存。在后端使用强哈希算法（如 bcrypt, Argon2）对密码进行加密存储。
- **参数验证和清理**：在服务器端严格验证和清理收到的所有数据以防止注入攻击。

### 5. 身份验证机制

- **使用认证令牌**：例如 JWT 或 OAuth，可以避免直接传输密码。用户登录后，服务器生成一个令牌，前端只需在后续请求中附带该令牌即可进行身份验证。
- **开启跨站请求伪造（CSRF）保护**：防止攻击者在用户不知情的情况下执行身份验证操作。

通过以上安全措施，可以有效地保护用户的敏感信息，并提高系统的整体安全性与数据保护水平。在设计和实现身份验证机制时，务必认真遵循这些安全实践。

## ip地址和域名

IP 地址和域名是互联网通信的基础概念，它们在网络中扮演着重要角色，简化用户访问和数据传输的过程。

### IP 地址

**IP 地址**（Internet Protocol Address）是指分配给设备的一个数值标签，用于标识其在网络上的位置和进行网络通信。IP 地址有两种主要版本：

1. **IPv4**：
   - 由四个十进制数组成（范围为0到255），以点分隔，例如：`192.168.1.1`。
   - 由于地址数量有限，IPv4 地址的分配日益紧张。

2. **IPv6**：
   - 为了解决IPv4地址耗尽的问题，IPv6使用128位地址长度。
   - 通常表示为8组16进制数字，每组4个字符，以冒号分隔，例如：`2001:0db8:85a3:0000:0000:8a2e:0370:7334`。
   - 提供几乎无限的唯一地址，支持更多设备互联。

### 域名

**域名**（Domain Name）是用于识别人们和互联网的易于记忆的地址。它用来代替难以记忆的 IP 地址，使用户更方便地访问网站。主要特点包括：

1. **层次结构**：
   - 由多个部分组成，通过点号（`.`）分隔。通常有顶级域（TLD）、二级域名等，例如：`www.example.com`。
   - 顶级域名如 `.com`, `.org`, `.net`, 以及国家或地区代码如 `.cn`, `.uk`。

2. **DNS 系统**：
   - 域名系统（Domain Name System）负责将人类可读的域名转换为机器可读的 IP 地址。
   - DNS 服务器通过 DNS 解析（域名解析）过程，将用户输入的域名转换为对应的服务器 IP 地址进行访问。

### 工作原理

1. **用户输入域名**：用户在浏览器中输入一个域名，比如 `www.example.com`。

2. **DNS 解析**：浏览器通过 DNS 查找服务器，从而找到对应的 IP 地址。

3. **连接服务器**：浏览器使用得到的 IP 地址与目标服务器建立连接，并请求所需的资源。

4. **传输数据**：服务器接收请求，并返回相应的数据（如网页、图像、视频等）给浏览器。

IP 地址和域名相互配合，使得用户可以轻松访问互联网资源，而不必记忆复杂的数字地址。域名的管理通常由域名注册机构来进行，而互联网中的 IP 地址分配由国际和地区性的互联网注册机构进行管理。

## 网络协议都有哪几层？通过什么协议建立的连接

网络协议通常按照分层模型进行组织，以便标准化通信并简化设计。两种广泛使用的分层模型是 OSI 模型和 TCP/IP 模型。

### OSI 模型

OSI（开放系统互连）模型是一个理论模型，由七层组成：

1. **物理层**：负责传输原始比特流，通过电缆、电波等媒介。
2. **数据链路层**：提供节点到节点的数据传输，负责帧的生成、传输和校验。常见协议有以太网（Ethernet）、Wi-Fi 等。
3. **网络层**：负责数据包的路由和转发，如 IP (Internet Protocol)。
4. **传输层**：提供端到端的传输服务，协议包括 TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol)。
5. **会话层**：管理会话，维持连接，常用于会话维护和管理。
6. **表示层**：负责数据的格式化、加密和解密。
7. **应用层**：提供网络服务给应用软件，如 HTTP、FTP、SMTP 等。

### TCP/IP 模型

TCP/IP 模型是互联网的基础协议体系，较为简化，通常分为四层：

1. **网络接口层**（也称为链路层）：对应 OSI 的物理层和数据链路层。
2. **互联网层**：对应 OSI 的网络层，主要协议是 IP。
3. **传输层**：同 OSI 的传输层，主要协议是 TCP 和 UDP。
4. **应用层**：对应 OSI 的会话层、表示层和应用层，涵盖应用协议如 HTTP、FTP、DNS 等。

### 建立连接的协议

3. **通过什么协议建立的连接**

- **TCP（Transmission Control Protocol）**：用于建立可靠的连接。TCP 连接需要三次握手过程，以确保连接的稳定性和可靠性。常用于需要保证数据完整性的应用，如网页浏览 (HTTP/HTTPS)、文件传输 (FTP) 和电子邮件 (SMTP)。

- **UDP（User Datagram Protocol）**：用于建立不需要连接的传输协议。与 TCP 不同，UDP 不保证数据的可靠交付，更适合实时性要求较高或容许一定数据丢失的应用，如视频流、VOIP 和在线游戏。

根据不同的应用需求，网络程序会选择使用 TCP 或 UDP 来建立连接，以优化数据传输的速度、可靠性和实时性。

## TCP是怎么保证它的可靠性的

TCP（Transmission Control Protocol）是一种面向连接的协议，设计用于提供可靠的数据传输服务。它通过多种机制来确保数据的完整性和可靠性，这些机制包括：

1. **三次握手（Three-way Handshake）**：
   - 在传输数据之前，TCP 通过三次握手过程来建立连接，确保通信双方都准备好发送和接收数据。此过程有助于初始化顺序确认和窗口大小等信息。

2. **顺序数据传输（Ordered Data Transfer）**：
   - TCP 包含一个序列号系统，确保所有数据包按照发送顺序重新组装。这样的机制能够防止数据包乱序问题，尤其是在网络拥堵时。

3. **重传机制（Retransmission Mechanism）**：
   - TCP 使用确认（ACK）消息来确认数据包的接收。如果发生数据包丢失或损坏，发送方判断没有收到预期的 ACK 后会重传数据包。

4. **超时重传（Timeout Retransmission）**：
   - 如果发送方在一定时间（超时期限）内未收到 ACK，TCP 将自动重传该数据包，以应对丢失的数据包和临时中断。

5. **流量控制（Flow Control）**：
   - 使用滑动窗口协议，TCP 可以调节发送方的数据流速率，确保接收方不会被过量数据压倒。窗口大小动态变化，依据接收方的处理能力进行调整。

6. **拥塞控制（Congestion Control）**：
   - TCP 实现多种拥塞控制算法（如慢启动、拥塞避免、快速重传和快速恢复），以避免网络拥堵。这些算法调节发送数据的速度，确保不会超出网络的负载能力。

7. **错误检测（Error Detection）**：
   - TCP 使用校验和（checksum），在传输开始时计算并发送。接收方在收到数据时重新计算校验和，验证数据的完整性。如有错误则请求重传。

通过这些机制，TCP 确保数据能够在不可靠的网络环境中保持一致性和可靠性，为应用提供一个稳定的传输基础。

## cache-control,说一下对它的理解。no-store和no-cache的区别

`Cache-Control` 是 HTTP 协议中的一个重要头字段，用于指定请求和响应如何进行缓存。通过这一头字段，服务器可以控制资源在客户端和中间服务器（如代理服务器）中的缓存行为，以及缓存的时效性和条件。

### `Cache-Control` 基础概念

`Cache-Control` 的指令用于优化 HTTP 请求和响应的传输效率、减少网络带宽的使用，并改善用户体验提高资源访问速度。这个头字段中的指令可以分为请求指令和响应指令，常见的指令包括：

- `public`: 表示响应可以被任何缓存区缓存。
- `private`: 表示响应只能被单个用户缓存，不能共享缓存。
- `no-store`: 请求或响应禁止缓存，每次都要从源服务器获取数据。
- `no-cache`: 缓存可以存储，但是需要在使用之前重新验证。
- `max-age`: 指定资源在缓存中存储的最大时间（以秒为单位），例如：`max-age=3600`。
- `must-revalidate`: 必须重新验证缓存过期的内容。

### `no-store` 和 `no-cache` 的区别

- **`no-store`**:
  - 含义：完全禁止缓存机制，不保存请求和响应的任何内容，既不在客户端缓存，也不在中间服务器缓存。每次请求资源，总是从服务器获取。
  - 适用场景：敏感数据或实时数据更新，确保每次都从原始服务器获得最新数据。
  
- **`no-cache`**:
  - 含义：允许缓存，但是在使用缓存的副本之前，必须向服务器进行再验证。例如，浏览器在显示缓存的副本前会发出一个验证请求，以确认副本仍然是最新的。
  - 适用场景：希望减轻服务器压力和带宽负载，但在一定条件下保证数据的准确性和新鲜性。

### 实际应用

- 使用 `no-store` 可以确保诸如金融交易中的敏感数据不被无意缓存。
- 使用 `no-cache` 可以针对静态但需要不定时更新的数据（如配置文件）进行缓存优化，但需保证在过期时能正确重新验证和更新缓存。

总的来说，使用 `Cache-Control` 头字段可以有效地管理 HTTP 缓存策略，选择合适的策略可以提高网络应用的性能和安全性。了解如何正确地使用这些指令，有助于在开发中大幅提升页面加载速度和数据安全。

## null和undefind的区别，null一般怎么用?

`null` 和 `undefined` 是 JavaScript 中的两个表示“无值”或“空”的特殊值，但它们有着不同的用途和语义。

### 区别：

1. **类型和定义**:
   - `null` 是一个字面量，表示“空值”或“无对象”，它通常用于有意地赋值给变量，以表明该变量没有对象。`typeof null` 返回 `"object"`，这是一种历史遗留问题，因为在最初的 JavaScript 实现中，`null` 被认为是一个指向空地址的对象。
   - `undefined` 表示一个变量已经声明但尚未赋值。它是全局对象的一个属性，也可以由 JavaScript 引擎自动赋给未初始化的变量，或者在函数中没有明确返回值的地方被自动返回。`typeof undefined` 返回 `"undefined"`。

2. **用途**:
   - `null` 通常用于表示一个变量应该有一个对象或值，但目前为空。例如，在删除一个对象的属性或重置某些对象引用时，可以将其设为 `null`。
   - `undefined` 通常用于表示变量尚未赋值或不存在。它经常出现在函数参数未传递、对象属性不存在等情况下。

3. **使用场景**:
   - 使用 `null` 可以表示没有可用的对象或空值，开发者可以通过显式地将变量设置为 `null` 来表示变量的“空状态”。例如：
     ```javascript
     let user = null; // 没有设置用户对象
     ```
   - `undefined` 则更加用于检查变量是否已定义或初始化。例如，检查一个函数的参数是否传递：
     ```javascript
     function greet(name) {
       if (name === undefined) {
         console.log('Name not provided');
       } else {
         console.log('Hello, ' + name);
       }
     }
     ```

### 总结：

- `null` 是开发者可控的表述“空”的状态，用于明确意图地表示某个变量当前没有值。
- `undefined` 则更多是系统自动赋予表示未定义状态，当我们访问未初始化变量或属性时，会得到 `undefined`。
- 在编程中，合理地使用这两者可以更清晰地表述代码逻辑，从而减少理解和调试上的误解。

## 介绍一下promise，promise特性以及优缺点。

`Promise` 是 JavaScript 中的一种用于异步编程的对象，提供了一种更清晰和更具可读性的方式来处理异步操作。它是 ECMAScript 6 (ES6) 引入的特性，能够让开发者更好地管理异步代码的执行，从而避免陷入回调地狱。

### Promise 的基本概念

一个 `Promise` 对象代表一个在未来完成（或失败）的异步操作及其产生的值。它有三种状态：

1. **Pending (待定)**: 初始状态，既不是成功也不是失败。
2. **Fulfilled (已完成)**: 表示操作成功完成。
3. **Rejected (已拒绝)**: 表示操作失败。

一旦 `Promise` 的状态发生改变（从 Pending 变为 Fulfilled 或 Rejected），就会触发相关联的处理程序（handlers）。并且，状态一旦改变，就不会再变。

### Promise 的特性

1. **链式调用**:
   - 支持通过 `.then()` 方法进行链式调用，每个 `then` 返回的都是一个新的 `Promise`，可以串联多个异步操作。
2. **异常捕获**:
   - 异常自动传递，可以通过 `.catch()` 方法统一处理异常，提供了一种一致的错误处理方式。
3. **清晰的异步代码结构**:
   - 避免层层嵌套和回调地狱，使代码更易读，也更容易理解和维护。
4. **只处理一次**:
   - 每个 `Promise` 只会被处理一次，不会重复执行回调。

### Promise 的优点

1. **提高代码的可读性**:
   - 使用 `Promise` 可以写出更为线性的异步代码，避免传统回调函数格式导致的嵌套过深（即回调地狱）。
2. **错误处理更易管理**:
   - 提供了统一的异常处理机制，减少了因遗漏错误处理而导致的异常问题。
3. **支持组合操作**:
   - 通过 `Promise.all()` 和 `Promise.race()` 等方法，可以并行处理多个异步操作，并根据需求在全部完成或其中一个完成时继续操作。

### Promise 的缺点

1. **异常吞噬**：
   - 如果链中某一步忘记了错误处理，错误可能会被吞噬而未被检测到。
2. **复杂性增加**：
   - 对一些简单的异步操作而言，Promise 的链式调用和错误处理反而增加了复杂性。
3. **调试困难**：
   - 调试异步操作有时比较困难，尤其是在链条很长时，跟踪错误变得复杂。

## 性能分析有哪些指标

前端性能直接影响用户体验和交互效率。为了确保前端应用的高效性，前端性能分析需要关注多个关键指标。以下是一些常见且重要的前端性能分析指标：

### 1. 首屏时间（First Contentful Paint, FCP）
- **含义**：用户首次看到页面内容的时间。
- **衡量**：从页面开始加载到页面内容元素（如文本、图片）首次出现在屏幕上的时间。

### 2. 首字节时间（Time to First Byte, TTFB）
- **含义**：浏览器在发送请求后，从服务器接收第一个字节的时间。
- **衡量**：从浏览器请求发出到接收第一个字节响应的时间。

### 3. 首次绘制（First Paint, FP）
- **含义**：浏览器在屏幕上绘制任何像素的时间点。
- **衡量**：从导航开始到浏览器首次在屏幕上绘制任何视觉变化的时间。

### 4. 交互时间（Time to Interactive, TTI）
- **含义**：页面变得完全可交互的时间点。
- **衡量**：从导航开始到页面可可靠地响应用户输入的时间。

### 5. 完全加载时间（Load Time）
- **含义**：页面所有资源（包括图像、样式表、JavaScript）完全加载的时间。
- **衡量**：从导航开始到页面中的所有资源加载完毕的时间。

### 6. 首次意义性绘制时间（Largest Contentful Paint, LCP）
- **含义**：页面主内容展示所需的加载时间。
- **衡量**：从页面开始加载到最大的内容元素（如大型图像或块级文本）的渲染时间。

### 7. 持续阻塞时间（Total Blocking Time, TBT）
- **含义**：从 FCP（首次内容绘制）到 TTI（可交互）的时间之间，阻塞主线程的时间总和。
- **衡量**：这段时间中超过 50 毫秒的所有长任务的时间总和。

### 8. 累积布局偏移（Cumulative Layout Shift, CLS）
- **含义**：页面加载期间视觉内容的稳定性。
- **衡量**：在页面加载过程中，任何未预期页面布局变化的总和。

### 9. JavaScript 执行时间
- **含义**：关键 JavaScript 文件加载和执行所需的时间。
- **衡量**：解析和执行 JavaScript 的时间。

### 10. 资源大小和数量
- **含义**：页面加载的所有资源的总大小和请求数量。
- **衡量**：页面加载的总字节数和请求的总数。

### 11. 缓存利用率
- **含义**：利用浏览器缓存加载页面资源的比例。
- **衡量**：缓存命中率和缓存资源加载的性能影响。

### 12. DOM 解析时间（DOM Content Loaded, DCL）
- **含义**：浏览器完全解析 HTML 文档并构建 DOM 树的时间。
- **衡量**：从导航开始到 DOMContentLoaded 事件触发的时间。

### 13. CSS 解析时间
- **含义**：样式表（CSS）加载和解析所花费的时间。
- **衡量**：CSS 文件完全加载和解析完成的时间。

### 14. 链接和脚本阻塞时间
- **含义**：阻塞浏览器渲染的外部脚本和链接加载时间。
- **衡量**：阻塞资源的总加载和执行时间。

### 15. 网络请求时间（Network Request Time）
- **含义**：个别网络请求的时间，包括 DNS 查找、连接时间、TLS 握手时间等。
- **衡量**：总请求时间以及各部分的具体时间。

### 16. 图片和媒体加载时间
- **含义**：页面中所有图片和其他媒体文件的加载时间。
- **衡量**：各个图像和媒体资源加载完成所需的总时间。

### 17. 脚本错误率
- **含义**：前端脚本执行期间发生错误的比例。
- **衡量**：脚本错误的总数和错误率。

### 18. 用户交互延迟（Input Delay）
- **含义**：用户进行输入或点击操作到页面实际响应的时间。
- **衡量**：用户交互和页面响应之间的时间差。

### 19. 渲染帧率（Frames Per Second, FPS）
- **含义**：页面在浏览器中渲染帧的速率。
- **衡量**：每秒钟渲染的帧数，通常期望保持在 60 FPS 以上以确保流畅的用户体验。

### 20. 内存使用（Memory Usage）
- **含义**：浏览器在加载和运行页面时使用的内存数量。
- **衡量**：总内存使用量和峰值内存使用量。

全面的前端性能分析需要结合多个指标，通过工具如 Google 的 Lighthouse、WebPageTest、Chrome DevTools、Performance 很多监控服务和工具来获得这些指标，并不断优化和改进，以提供最佳的用户体验。

## 局域网怎么链接外部

局域网（LAN，Local Area Network）通常是指一个相对小的、基于地理位置的网络，例如家庭、办公室或校园网络。要让局域网中的设备连接到外部网络（即互联网），通常需要以下几个步骤和设备：

### 1. 硬件和网络结构

**1.1 路由器**

- 路由器是连接局域网和广域网（WAN，Wide Area Network，例如互联网）的关键设备。它具有连接内网和互联网的功能。
- 路由器有两个接口：
  - **WAN 接口**：连接到外部网络（通常是通过调制解调器连接到互联网服务提供商，ISP）。
  - **LAN 接口**：连接到局域网内部设备（电脑、打印机、手机等）。

**1.2 调制解调器**

- 调制解调器将来自 ISP 的信号（通常是光纤、电缆或DSL信号）转换为以太网信号，从而可以被路由器使用。

### 2. 网络配置

**2.1 路由器的设置**

- 配置路由器的 WAN 接口，确保其能够从 ISP 获取外部 IP 地址（通常是通过 DHCP 自动获取）。
- 路由器通过 NAT（Network Address Translation，网络地址转换）将局域网内部的私有 IP 地址映射到一个公共的 IP 地址，用于互联网通信。

**2.2 局域网设置**

- 路由器的 DHCP 服务器功能会为局域网内的设备分配本地 IP 地址。
- 局域网内的设备通过这个本地 IP 地址进行内部通信，并通过路由器访问外部网络。

### 3. DNS 配置

- 确保路由器和局域网内的设备配置了正确的 DNS（Domain Name System，域名系统）服务器地址，用于解析域名到 IP 地址。

### 4. 安全设置

- 配置防火墙规则，确保局域网内的设备受到保护，防止未经授权的外部访问。
- 配置 Wi-Fi 的安全设置，使用 WPA3 或者 WPA2 加密，确保网络安全。

### 连接示例

假设你有一个家庭网络，配置步骤可能如下：

1. **连接调制解调器**
   - 将 ISP 提供的调制解调器连接到墙上的网络接口。
   - 将调制解调器与路由器的 WAN 端口连接。

2. **配置路由器**
   - 访问路由器的管理界面对其进行配置（通常可以通过访问 `192.168.1.1` 或 `192.168.0.1` 进入管理界面，具体视路由器品牌和型号而定）。
   - 在 `WAN` 设置中，确保路由器通过 DHCP 获取 IP 地址。

3. **局域网设备连接**
   - 将局域网内的设备（电脑、手机等）连接到路由器的 LAN 端口或通过 Wi-Fi 连接。
   - 设备会通过 DHCP 获取本地 IP 地址。

4. **测试连接**
   - 在局域网内的设备上访问互联网，测试连接是否正常。

### 图示（简化版）

```plaintext
┌──────────────────────────────┐
│    互联网（ISP提供的连接）       │
└─────────────┬────────────────┘
              │
     ┌────────▼────────┐
     │   调制解调器    │（ISP提供）
     └────────┬────────┘
              │
     ┌────────▼────────┐
     │     路由器      │
     │ (NAT、DHCP、防火墙) │
     └────────┬────────┘
              │
   ┌──────────┼───────────┐
   │          │           │
┌──▼──┐   ┌───▼───┐   ┌───▼───┐
│PC1  │   │ Printer │   │ Phone│
└─────┘   └────────┘   └───────┘
```

通过以上配置，局域网内的设备就可以通过路由器连接到外部网络，即互联网。

## ftp协议干嘛的

FTP（File Transfer Protocol，文件传输协议）是一种用于在计算机网络间传输文件的标准通信协议。其主要功能包括：

1. **文件传输**:
   - **上传文件**: 从客户端计算机上传文件到服务器。
   - **下载文件**: 从服务器下载文件到客户端计算机。

2. **目录管理**:
   - **查看目录**: 检索和显示服务器上的目录和文件列表。
   - **创建、删除和移动文件/目录**: 在服务器上管理文件和目录的操作，包括创建新目录、删除文件和目录、重命名和移动等。

3. **访问控制**:
   - **用户认证**: 通过用户名和密码进行身份验证，确保只有授权用户可以访问和操作文件。
   - **权限管理**: 设置文件和目录的访问权限，控制哪些用户或组可以读取、写入或执行特定文件。

4. **支持多种传输模式**:
   - **ASCII模式**: 用于传输文本文件，自动处理不同系统的换行符。
   - **二进制模式**: 用于传输非文本文件，如图像、音频、视频和压缩文件，确保文件完整性。

FTP协议通常用于需要可靠和高效传输文件的场合，如网站文件更新、文件共享、系统备份和数据迁移等。然而，由于FTP协议缺乏加密机制，其传输内容（包括用户名和密码）可以被截获。因此，安全需求较高的场合可能使用更安全的协议替代，如SFTP（SSH File Transfer Protocol）或FTPS（FTP Secure），它们增加了加密和安全认证功能。

## nginx是什么，它反向代理底层实现

Nginx 是一个高性能的 Web 服务器和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。广泛用于处理高并发连接、提供负载均衡、缓存、以及静态内容的快速处理等场景。Nginx 的轻量级、模块化架构和高效率使其成为许多企业和个人的首选服务器之一。

### 主要功能

1. **反向代理**:
   - 将客户端的请求转发至后端服务器，并将响应发送回客户端。它有效地隐藏了后端服务器的存在，增加了一层安全性。

2. **负载均衡**:
   - 通过将请求分配到多个服务器上，Nginx 提供了良好的负载均衡能力，支持多种调度算法，如轮询、Least Connections 和 IP Hash。

3. **HTTP 缓存**:
   - Nginx 可作为缓存服务器使用，缓存后端服务器响应的内容，以减轻后端服务器的负载和提高响应速度。

4. **静态文件处理**:
   - 高效地提供静态文件服务，如 HTML、图片、JavaScript 和 CSS 文件等。

5. **安全与访问控制**:
   - 提供 SSL/TLS 支持，允许配置细粒度的访问控制规则。

### 反向代理的底层实现

Nginx 反向代理的底层实现结合了事件驱动和异步非阻塞处理机制，主要特点包括：

1. **事件驱动架构**:
   - Nginx 使用事件驱动架构来处理请求。这意味着它可以利用单个线程来管理数千个并发连接，从而减少内存消耗和上下文切换开销。

2. **异步非阻塞 I/O**:
   - Nginx 使用操作系统提供的异步非阻塞 I/O 支持（如 `epoll`、`kqueue`），避免在等待 I/O 操作完成时阻塞进程。它通过事件通知机制在 I/O 完成时获得通知，从而处理请求。

3. **请求处理管道**:
   - 当接受一个客户端请求后，Nginx 会根据配置解析该请求，并将其转发给指定的后端服务器。处理响应时，Nginx 可以逐块读取数据并立即发送回客户端，从而有效减少延迟。

4. **连接池和复用**:
   - 为了提高性能，Nginx 实现了连接池机制，用以管理后端服务器的连接，减小建立和关闭连接的频繁消耗。

5. **模块化设计**:
   - Nginx 以模块化方式实现功能扩展，用户可以根据需要加载不同模块进行功能调整和扩展，如压缩、访问控制等。

总体来说，Nginx 的高性能和灵活性为其反向代理功能提供了坚实的底层技术支持，使其能够在高并发和多任务处理的环境下高效运行。

## 向后端发请求的时候，经常会遇到先选一个选项发请求，这个请求可能有一段时间才能相应，然后又选了另一个选项，你怎么保证我的数据是正确的？

1. 请求是可以打断的，比如fetch可以通过AbortController中断请求，然后去发最新的请求就行了

## AbortController原理

`AbortController` 和 `AbortSignal` 的实现原理主要依赖于事件发布-订阅模式（也称为观察者模式），并通过 JavaScript 的 Promise 和事件模型来实现对异步操作的取消控制。下面深入探讨其背后的技术实现原理。

### 实现原理

1. **事件发布-订阅模式**：
   - `AbortController` 充当发布者，而 `AbortSignal` 作为信号的订阅者。`AbortSignal` 会监听来自 `AbortController` 的信号。
   - 当 `AbortController` 调用 `abort()` 时，它会向所有关联的 `AbortSignal` 发送一个中止通知。

2. **AbortSignal 与 EventTarget**：
   - `AbortSignal` 实现自 `EventTarget` 接口，这意味着它具有标准的事件处理方法（如 `addEventListener`、`removeEventListener`）。
   - 这允许开发者通过事件监听器来响应信号的中止，例如监听 `abort` 事件。

3. **状态管理**：
   - `AbortSignal` 内部维护一个状态，表示该信号是否已中止。
   - 当 `AbortController` 的 `abort()` 方法被调用时，该状态会被更新，并触发一个 `abort` 事件。这一事件会通知所有的监听器，以及任何关联的 Promise，使它们能够适当地处理终止逻辑。

4. **Promise 中止**：
   - 在实际用例如网络请求中，例如使用 `fetch` API，`AbortSignal` 的实现需要与异步操作的 Promise 结合使用。
   - 当 `AbortController` 发出中止信号时，这种异步操作需要检测其对应的 `AbortSignal` 的状态，并在相应的 Promise 被标记为中止（通常通过抛出一个 `AbortError` 错误），让开发者可以用 `.catch()` 或 `try-catch` 块来处理取消后的逻辑。

5. **整合到浏览器 API**：
   - 浏览器的内建 API（例如 `fetch`）在实现上被扩展，以支持 `AbortSignal`。因此，当 `fetch` 请求启动时，它会观察传入的 `AbortSignal` 的状态。
   - 一旦 `signal` 被触发，`fetch` 的实现会捕捉到这个状态变化并终止请求，抛出一个 `AbortError`。

### 示例

下面简单的代码示例演示了 `AbortController` 和 `AbortSignal` 的工作流程：

```javascript
// 创建一个 AbortController 实例
const controller = new AbortController();
const signal = controller.signal;

// 模拟一个长时间的异步操作，比如 fetch 请求
fetch('https://example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('请求被中止');
    } else {
      console.error('请求失败:', err);
    }
  });

// 在某个条件下中止请求，比如用户离开页面或需要取消不必要的请求
setTimeout(() => {
  controller.abort();
  console.log('请求已被手动中止');
}, 5000);
```

### 实现中的关键要点

- **事件驱动与异步机制结合**：`AbortSignal` 的设计依赖事件驱动模型，以便在状态变更时通知所有相关的异步操作。
- **标准化**：`AbortController` 和 `AbortSignal` 的实现是浏览器原生标准 API 扩展的一部分，这使得它们与 JavaScript 异步生态系统得到很好的集成。
- **灵活的异步控制**：通过与 Promise 机制整合，开发者可以在诸如网络请求、异步计时器和自定义异步操作中有效地应用。

整体来说，`AbortController` 和 `AbortSignal` 提供了开发者一个标准且强大的工具，以精确控制异步操作的生命周期，尤其是在涉及资源管理和用户交互复杂的场景中。

## dns寻址过程

## 403

##  浏览器响应码 403 (Forbidden) 解释

当浏览器请求一个网页时，如果服务器理解了请求，但是拒绝授权访问，就会返回 **403 Forbidden**  错误。 这意味着你没有足够的权限访问请求的资源。 

**常见原因:**

* **权限不足:** 你尝试访问的页面或资源需要特定权限，而你当前的账户没有这些权限。 例如，你尝试访问网站后台，但你并非管理员。
* **身份验证失败:**  你可能需要登录才能访问该资源，但你的登录信息无效或已过期。
* **网站设置:**  网站所有者可能配置了服务器，禁止特定 IP 地址或用户代理访问特定资源。
* **文件或文件夹权限:**  你尝试访问的文件或文件夹可能设置了错误的权限，导致 Web 服务器无法读取或执行它们。
* **.htaccess 文件错误:**  `.htaccess` 文件用于控制网站访问，错误的配置可能导致 403 错误。
* **防火墙设置:**  防火墙可能阻止了你对网站的访问。


**解决方法:**

* **检查网址:** 确保你输入的网址正确，并且你确实有权访问该页面。
* **登录:**  如果需要登录，请尝试使用正确的用户名和密码登录。 
* **联系网站管理员:**  如果你认为自己应该有权限访问该页面，请联系网站管理员寻求帮助。
* **清除浏览器缓存和 Cookies:** 有时，浏览器缓存会导致问题，尝试清除缓存和 cookies 之后再试一次。
* **稍后再试:**  问题可能是暂时的，可以稍后再试。
* **检查文件或文件夹权限:**  如果你有服务器访问权限，请检查相关文件和文件夹的权限设置。
* **检查 .htaccess 文件:**  确保 `.htaccess` 文件没有错误配置。
* **检查防火墙设置:** 确保防火墙没有阻止你访问该网站。


**其他建议:**

* 仔细阅读错误信息： 有些网站会提供更详细的错误信息，帮助你找到问题所在。
* 使用其他浏览器或设备测试： 尝试使用其他浏览器或设备访问该网站，看是否能解决问题。


如果以上方法都无法解决问题，建议你联系网站管理员或技术支持寻求进一步的帮助。

## jsonp的原理是什么，是标签允许跨域还是某个属性允许跨域

你对 JSONP 的理解很到位！它的确利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据的。

**让我们更详细地解析 JSONP 的原理：**

1. **同源策略的限制：**  浏览器出于安全考虑，实施了同源策略。简单来说，它限制了来自不同源（协议、域名、端口都相同）的 JavaScript 代码之间的交互。这意味着，使用 XMLHttpRequest 或 Fetch API 通常只能请求相同域下的数据。

2. **`<script>` 标签的例外：** 浏览器允许 `<script>` 标签加载并执行来自任何域的 JavaScript 代码。这就是 JSONP 利用的漏洞！

3. **JSONP 的巧妙之处：**
   - **服务器端配合：** 你请求的服务器必须支持 JSONP。它会将数据包装在一个预先约定好的 JavaScript 函数调用中，而不是直接返回 JSON 数据。
   - **客户端的回调函数：** 在客户端，你需要定义一个与服务器约定好的回调函数。
   - **动态创建 `<script>` 标签：** 当你想要请求跨域数据时，JavaScript 代码会动态创建一个 `<script>` 标签，并将它的 `src` 属性设置为目标 URL，该 URL 包含要传递给回调函数的数据。
   - **数据传递与执行：** 浏览器加载 `<script>` 标签，并将服务器返回的代码（包含你的数据和回调函数调用）作为 JavaScript 执行。
   - **回调函数处理数据：**  预定义的回调函数被调用，并将服务器传递的数据作为参数，从而让你可以在客户端访问跨域数据。

**举个例子：**

```html
<!-- 客户端代码 -->
<script>
  function handleResponse(data) {
    console.log(data); // 处理接收到的数据
  }

  const script = document.createElement('script');
  script.src = 'https://example.com/api/data?callback=handleResponse'; // 假设服务器支持 JSONP
  document.body.appendChild(script); 
</script>
```

```javascript
// 服务器端代码 (示例)
const data = { name: 'Alice', age: 30 };
const callbackName = request.query.callback; // 获取回调函数名
response.send(`${callbackName}(${JSON.stringify(data)})`); 
```

**总结：**

-  JSONP 并不是 HTML 中某个属性允许跨域，而是利用了 `<script>` 标签本身不受同源策略限制的特性。
-  它需要服务器端的配合，将数据包装在回调函数中。
-  虽然 JSONP 可以解决跨域数据请求的问题，但它也有一些缺点，例如：
    -  只支持 GET 请求。
    -  安全性较低，容易受到跨站请求伪造（CSRF）攻击。

## IP地址的作用

IP地址（Internet Protocol Address）是设备在网络中进行识别和通信的重要标识符。它的主要作用包括以下几个方面：

1. **设备标识**：
   - IP地址为网络上每个设备提供了一个唯一的标识符，类似于邮寄地址，用于在网络中区分不同设备。
   
2. **位置信息**：
   - IP地址可以提供设备相对的地理位置（如国家、城市）信息，虽然这种定位并不精确，但在整体网络架构中具有指导意义。

3. **数据传输**：
   - IP地址被用于数据包的路由。它确保数据从源地址传输到目标地址。路由器和交换机等网络设备利用IP地址来实现数据传输的正确路径选择。

4. **网络管理**：
   - IP地址有助于网络管理员进行监控、管理和维护网络。通过查看IP地址，可以识别潜在的网络问题、监控网络流量和进行访问控制。

5. **远程访问和连接**：
   - IP地址允许用户通过互联网实现远程访问，例如远程桌面连接、服务器访问等。

6. **安全控制**：
   - IP地址也是网络安全系统的重要组成部分。防火墙和入侵检测系统可利用IP地址来设定规则，允许或阻止某些IP地址范围的访问。

7. **域名解析**：
   - IP地址与域名系统（DNS）一起工作。DNS将易于理解的域名（例如，www.example.com）转换为IP地址，从而使用户更容易访问网站。

IP地址分为IPv4和IPv6两种版本。IPv4使用32位地址格式，最多可支持约43亿个唯一地址。随着互联网的快速增长，IPv4地址逐渐短缺，于是引入了IPv6，其使用128位地址格式，可以提供更大的地址空间。

总体来说，IP地址是互联网及其相关系统基础设施中不可或缺的组成部分，确保了设备互联互通和数据的有效传递。

## https握手加密的关键是什么

HTTPS（Hypertext Transfer Protocol Secure）是通过在 HTTP 协议上增加 SSL/TLS 层来实现数据加密和安全传输的协议。HTTPS 握手过程是建立安全连接的关键，它确保客户端和服务器之间的数据传输是加密和验证的。HTTPS 握手过程的核心在于 **TLS（Transport Layer Security）握手**，其加密的关键在于以下几个方面：

### 1. 协议协商
客户端和服务器首先协商使用的 TLS 版本和加密算法。TLS 版本和加密套件决定了用于会话的加密算法、密钥交换算法、哈希算法等。

### 2. 服务器身份验证和公钥交换
服务器通过发送其数字证书（通常由受信任的证书颁发机构 CA 签发）来验证自己的身份。这个证书包含服务器的公钥，客户端通过验证证书来确保服务器的真实性。

### 3. 对称密钥生成
通过交换部分密钥材料，客户端和服务器生成一个共享的会话密钥，用于之后的对称加密通信。常见的密钥交换方法包括 RSA、Diffie-Hellman（DH）、Elliptic Curve Diffie-Hellman（ECDH）等。

### 4. 会话加密
一旦生成并共享了对称密钥，就会使用对称加密算法（如 AES 或 ChaCha20）加密通讯数据，从而保证数据在传输过程中的保密性和完整性。

### HTTPS/TLS 握手过程的详细步骤

1. **客户端问候（Client Hello）**
客户端向服务器发送问候消息，其中包括支持的 TLS 版本、加密套件列表、压缩方法和一个随机数（Client Random）。

```plaintext
Client Hello
  - TLS 版本
  - 支持的加密套件列表
  - 客户端随机数（Client Random）
  - 扩展字段（如支持的协议、散列算法等）
```

2. **服务器问候（Server Hello）**
服务器选择一组加密参数，并回应客户端问候消息，包括确定的 TLS 版本、加密套件、压缩方法和服务器随机数（Server Random）。

```plaintext
Server Hello
  - 确定的 TLS 版本
  - 确定的加密套件
  - 服务器随机数（Server Random）
```

3. **服务器发送证书（Server Certificate）**
服务器向客户端发送其数字证书。客户端验证证书是否合法，如证书是否由受信任的 CA 签发。

```plaintext
Server Certificate
  - 服务器证书
```

4. **（可选）服务器密钥交换（Server Key Exchange）**
如果密钥交换算法需要额外的密钥材料（如 ECDHE），服务器会发送服务器密钥交换消息。

```plaintext
Server Key Exchange
  - 额外的密钥材料
```

5. **服务器问候完毕（Server Hello Done）**
服务器表示它的问候阶段已结束。

```plaintext
Server Hello Done
```

6. **客户端密钥交换（Client Key Exchange）**
客户端生成预主密钥（Pre-Master Secret），并用服务器的公钥加密后发送给服务器。预主密钥结合客户端和服务器的随机数生成会话密钥（Master Secret）。

```plaintext
Client Key Exchange
  - 预主密钥（加密）
```

7. **客户端问候结束（Client Finished）**
客户端向服务器发送一条受会话密钥保护的“Finished”消息，表示客户端问候阶段结束。

```plaintext
Client Finished
```

8. **服务器问候结束（Server Finished）**
服务器用会话密钥加密前面的握手消息，并发送“Finished”消息以确认握手过程已完成。

```plaintext
Server Finished
```

在这个过程中，**加密的关键**包括：

1. **数字证书**：确保服务器身份的真实性。
2. **非对称加密**：用于安全地交换会话密钥（如 RSA）。
3. **对称加密**：用于保护实际数据传输的内容（如 AES）。
4. **哈希函数**：用于数据完整性验证和消息认证（如 SHA-256）。

### 会话密钥的生成

1. **预主密钥**：预主密钥是通过客户端和服务器间的密钥交换协议（如 RSA、DH、ECDH）生成的。
2. **随机数**：客户端和服务器各自生成一个随机数（Client Random 和 Server Random）。
3. **主密钥**：结合预主密钥和随机数生成主密钥。

```plaintext
Master Secret = PRF(Pre-Master Secret, "master secret", Client Random + Server Random)
```

### 加密通信

在握手阶段结束后，使用 Pseudo-random Function (PRF) 生成会话密钥进行对称加密通信，以保证数据传输的保密性和完整性：

```plaintext
Session Key = PRF(Master Secret, "key expansion", Server Random + Client Random)
```

### 总结

HTTPS 握手加密的关键在于：

- **数字证书和公钥技术**：用于认证服务器身份和安全交换预主密钥。
- **预主密钥和主密钥**：通过客户端和服务器的随机数生成安全的会话密钥。
- **对称加密和哈希算法**：用于加密会话数据和确保数据传输的完整性。

这整个过程使得 HTTPS 能够提供强大的安全性，保护用户数据免受窃取和篡改。

## https是怎么防止证书被篡改的

HTTPS通过使用数字证书来确保通信的安全性，而防止证书被篡改的机制主要依赖于公钥基础设施（PKI）和相关的信任链系统。以下是HTTPS防止证书被篡改的关键要素：

1. **数字签名**：
   - 数字证书由权威的证书颁发机构（CA）签署。CA使用它们的私钥对证书进行数字签名。客户端在收到证书时，可以使用CA的公钥来验证该签名的有效性，从而确认证书没有被篡改。

2. **证书链与信任链**：
   - 每个证书除了提供自身的信息，还会包含一系列的中间证书，形成了一个信任链，最终指向根证书。操作系统和浏览器通常有一组预装的信任根证书。通过这条链，客户端能够验证证书的合法性。

3. **证书吊销列表（CRL）与在线证书状态协议（OCSP）**：
   - CA可以使用CRL或OCSP来提供证书的吊销信息。用户的浏览器可以通过这些机制检查证书是否已被吊销。如果证书被标记为无效，则可能被认为已被篡改或者失去可信性。

4. **严格的验证与配置**：
   - 浏览器和操作系统会进行严格的证书验证。包括检查证书的有效期、域名（通配符）匹配、使用限制等。这有助于识别和忽略任何存在可疑问题的证书。

5. **HTTP严格传输安全（HSTS）**：
   - HSTS头被配置在服务器上，告诉浏览器必须与服务器进行HTTPS连接，并且不允许降级到不安全的HTTP。这种配置可以防止中间人攻击以及证书劫持风险。

6. **证书透明度**：
   - 这是一个由谷歌主导的机制，要求所有颁发的证书必须在公共日志中记录，使其可被审计和监督，以发现可能存在的错误或恶意签发事件。

## 讲讲常见的状态码

在计算机网络和Web开发中，状态码是HTTP协议的一部分，用于表示由服务器返回的响应结果。状态码一般由三位数字组成，第一位数字标识状态码的类别。以下是一些常见的状态码及其含义：

### 1xx - 信息性响应
- **100 Continue**：客户端应继续请求，如果请求已完成，忽略这个继续响应。
- **101 Switching Protocols**：服务器根据客户端的请求更改协议。

### 2xx - 成功
- **200 OK**：请求成功，服务器已返回请求的数据。
- **201 Created**：请求成功且服务器已创建新资源，通常对于POST请求。
- **202 Accepted**：请求已被接受，但处理尚未完成。
- **204 No Content**：服务器成功处理了请求，但不返回任何内容。

### 3xx - 重定向
- **301 Moved Permanently**：请求的资源已被永久移动到新的URL，后续请求应使用新URL。
- **302 Found**：请求的资源被临时移动到另一个URL。
- **304 Not Modified**：自从上次请求后，请求的资源未修改，可以使用缓存版本。

### 4xx - 客户端错误
- **400 Bad Request**：服务器无法理解请求，因为语法无效。
- **401 Unauthorized**：请求要求用户的身份认证。
- **403 Forbidden**：服务器理解请求但拒绝执行。
- **404 Not Found**：服务器找不到请求的资源。
- **405 Method Not Allowed**：请求中指定的方法不被允许。
- **408 Request Timeout**：请求超时，服务器等待客户端发送请求超时。

### 5xx - 服务器错误
- **500 Internal Server Error**：服务器遇到错误，无法完成请求。
- **501 Not Implemented**：服务器不支持请求的功能。
- **502 Bad Gateway**：服务器作为网关或代理，从上游服务器收到无效响应。
- **503 Service Unavailable**：服务器因过载或停机维护无法处理请求。
- **504 Gateway Timeout**：服务器作为网关或代理，未及时从上游服务器接收到响应。

## 网络请求方式

在 Web 开发中，有多种方式可以用来发起网络请求与服务器进行通信。每种方式都有其特定的用途和适用场景。下面是一些常见的网络请求方式：

### 1. HTTP 方法

HTTP（Hypertext Transfer Protocol）是 Web 上通信的基础协议，常用的方法包括：

- **GET**：用于从服务器获取数据。请求不应产生任何服务器的状态变化。
- **POST**：向服务器发送数据。例如，提交表单数据或上传文件。
- **PUT**：用于更新服务器上的资源。
- **DELETE**：用于删除指定的资源。

### 2. XMLHttpRequest (XHR)

这是较早在 JavaScript 中发起网络请求的接口，支持通过 JavaScript 发起 HTTP 请求和处理响应。

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onload = function() {
    if (xhr.status === 200) {
        console.log(xhr.responseText);
    }
};
xhr.send();
```

### 3. Fetch API

Fetch 是现代浏览器中常用的接口，用于发起网络请求。它是基于 Promise 的，支持更简洁且异步的请求处理。

```javascript
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error('There has been a problem with your fetch operation:', error);
    });
```

### 4. Axios

Axios 是一个流行的、基于 Promise 的 HTTP 客户端库，支持浏览器和 Node.js。它提供更高层的 API，简化请求处理。

```javascript
axios.get('https://api.example.com/data')
    .then(response => {
        console.log(response.data);
    })
    .catch(error => {
        console.error('Error fetching data:', error);
    });
```

### 5. JSONP

由于同源策略的限制，传统的跨域请求通常受到限制。JSONP（JSON with Padding）是一种早期的解决方案，通过动态插入`<script>`标签获取数据。

```html
<script src="https://api.example.com/data?callback=myCallback"></script>
```

```javascript
function myCallback(data) {
    console.log(data);
}
```

### 6. WebSockets

WebSocket 是一种持久化的通信协议，允许在客户端和服务器之间进行实时的双向通信，适用于需要时刻更新的应用（如聊天应用）。

```javascript
let socket = new WebSocket("ws://www.example.com/socketserver");
socket.onmessage = function(event) {
    console.log(event.data);
};
```

### 7. Server-Sent Events (SSE)

这是一个服务器向浏览器推送更新的机制，适合一些实时性需求较强但相对简单的场景。

```javascript
let eventSource = new EventSource('https://api.example.com/stream');
eventSource.onmessage = function(event) {
    console.log(event.data);
};
```

### 选择请求方式时应考虑的因素

在选择请求方式时，开发者应考虑到使用场景、浏览器兼容性、异步处理需求、数据类型和体量、双向通信需要等因素。此外，新技术如 HTTP/2 也在不断影响着 Web 通信的优化和重构。

## 常见的 HTTP 缓存，怎么知道某个资源是不是缓存下来的

HTTP 缓存是一种提升 Web 性能的重要手段，它能减少网络延迟，节省带宽，提高用户体验。判断资源是否被缓存、了解缓存策略以及配置缓存，这些都是 Web 开发中的重要技能。

### 1. HTTP 缓存策略

#### 1.1. 强缓存
**强缓存**并不与服务器进行通信，而是直接从浏览器缓存中获取资源。强缓存通过 HTTP 头部的 `Expires` 和 `Cache-Control` 字段来实现。

- **Expires**:
  ```http
  Expires: Wed, 21 Oct 2021 07:28:00 GMT
  ```
  指定资源在过期时间之前直接从缓存中获取。但它是一个绝对时间，依赖客户端的时间和服务器时间一致性。

- **Cache-Control**:
  ```http
  Cache-Control: max-age=3600
  ```
  表示资源在 3600 秒内有效，是相对时间，更为精确。

#### 1.2. 协商缓存
**协商缓存**在客户端缓存过期后，通过与服务器通讯来确认资源是否被修改。主要依赖 `Last-Modified`/`If-Modified-Since` 和 `ETag`/`If-None-Match` 头部。

- **Last-Modified** 和 **If-Modified-Since**:
  ```http
  Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT
  If-Modified-Since: Wed, 21 Oct 2020 07:28:00 GMT
  ```
  `Last-Modified` 表示资源最后修改时间，`If-Modified-Since` 用于向服务器确认。

- **ETag** 和 **If-None-Match**:
  ```http
  ETag: "abc123"
  If-None-Match: "abc123"
  ```
  `ETag` 是资源的唯一标识符，资源变更时 `ETag` 改变，`If-None-Match` 用于验证。

### 2. 如何查看资源是否缓存

#### 使用 Chrome 开发者工具

1. **打开开发者工具**:
   - 按 `F12` 打开 Chrome 开发者工具，或者右键点击页面选择“检查”。

2. **查看 Network 面板**:
   - 选择 `Network` 面板。
   - 加载特定资源，并找到该资源请求。

3. **查看资源状态**:
   - 资源状态码：
     - `200 OK from cache` 或 `304 Not Modified` 表示资源被缓存。
   - **查看 HTTP 头部信息**:
     - 查看 `Expires`、`Cache-Control`、`Last-Modified`、`ETag` 等缓存相关的头部信息。

   举例：

   ```plaintext
   (从缓存加载示例)
   Request URL: https://example.com/image.png
   Status Code: 200 OK (from disk cache)
   
   (协商缓存示例)
   Request URL: https://example.com/image.png
   Status Code: 304 Not Modified
   Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT
   ETag: "abc123"
   ```
   
   ##### 代码中判断：
   
   - 使用 Performance API：
   
     ```javascript
     const entry = performance.getEntriesByName(url)[0];
     const fromCache = entry.transferSize === 0;
     ```
   
   - 如果 transferSize 为 0，通常意味着资源来自缓存
   
   ##### Service Worker：
   
   - 如果使用 Service Worker 做缓存，可以在 Service Worker 中记录缓存状态
   
   ##### 缓存存储 API：
   
   - 使用 CacheStorage API 检查缓存：
   
     ```javascript
     caches.match(url).then(response => {
       if (response) {
         console.log('Resource is cached');
       }
     });
     ```

### 3. 示例代码和配置

#### 强缓存配置（Nginx）
```nginx
location /static/ {
    root /var/www/site;
    expires 30d;
    add_header Cache-Control "public";
}
```

#### 协商缓存配置（Apache）
```apache
<FilesMatch "\.(jpg|jpeg|png|gif|js|css)$">
    FileETag MTime Size
    Header set Cache-Control "public, must-revalidate"
</FilesMatch>
```

### 4. 实践中的缓存策略
- **静态资源**（如图片、CSS、JavaScript）：通常使用强缓存，并设置 `Cache-Control` 为一个较长的时间，例如一年 (`max-age=31536000`)。
- **动态资源**：使用协商缓存，确保内容最新。如使用 `ETag` 和 `Last-Modified` 来控制。

## ddos攻击

DDoS（分布式拒绝服务）攻击是一种恶意行为，旨在通过大量的流量或请求淹没目标服务器、网络或在线服务，从而使其无法正常服务合法用户。在这种攻击中，攻击者通常会使用庞大的“僵尸网络”——由受感染计算机组成的网络来发起攻击。

### DDoS 攻击的类型

1. **网络层攻击（Volumetric Attacks）**：
   - **UDP 洪泛**：通过发送大量伪造的 UDP 包，使得目标无法处理这些流量。
   - **ICMP 洪泛**：通过发送大量伪造的 ICMP 回显请求（如 ping），使得目标带宽耗尽。

2. **协议攻击（Protocol Attacks）**：
   - **SYN 洪泛**：利用 TCP 三次握手机制，通过发送大量 SYN 请求，但不完成握手，消耗服务器的连接资源。
   - **Ping of Death**：发送畸形或过大的数据包导致目标系统崩溃或重启。

3. **应用层攻击（Application Layer Attacks）**：
   - **HTTP 洪泛**：通过大量的 HTTP 请求，使得目标 Web 服务器资源耗尽。
   - **慢速攻击（如 Slowloris）**：以极慢速度发送请求，使得目标保持连接状态而耗尽资源。

### DDoS 攻击的方式

- **僵尸网络（Botnet）**：攻击者通过恶意软件感染大量计算机，使其成为僵尸网络的一部分。在需要时，攻击者控制这些受感染的电脑发起攻击。

- **反射攻击**：利用开放的服务器（如 DNS 服务器、NTP 服务器）反射流量到受害者。攻击者发送伪造源地址的请求，目标地址是受害者的 IP，服务器会将响应发送到受害者。

### 如何防范 DDoS 攻击

1. **升级基础设施**：
   - 确保有足够的带宽以承受潜在的流量峰值，可以通过接入内容分发网络（CDN）来分散流量。

2. **部署DDoS 保护服务**：
   - 使用专业的 DDoS 保护服务（如 Cloudflare、Akamai 等）来监测和拦截异常流量。

3. **网络配置和防火墙规则**：
   - 适当配置防火墙和路由器以阻止不必要的流量。
   - 实施速率限制，防止单一 IP 地址在短时间内发送过多请求。

4. **反射攻击防护**：
   - 关闭不必要的公开服务端口，防止未授权的反射流量。
   - 确保 DNS 和其他网络服务配置正确，以避免被利用进行反射攻击。

5. **应急响应计划**：
   - 制定和测试应急响应计划，确保在发生攻击时能够及时有效地反应。

通过综合这些措施，组织和个人可以有效降低受到DDoS攻击的风险并提升其网络和服务的可用性。在应对DDoS攻击时，规划和准备是实现持久防御的关键。

## dns劫持

DNS 劫持（DNS Hijacking）是一种网络攻击形式，攻击者**通过篡改域名系统（DNS）解析的过程**，迫使用户访问虚假或不当的互联网地址。它能够影响用户对网络资源的访问，例如网页、电子邮件等，从而导致安全风险和隐私问题。

### DNS 劫持的工作原理

1. **修改用户主机上的 DNS 设置**：攻击者可能通过**恶意软件感染用户设备**，从而更改设备上的 DNS 设置，使其请求不再指向正确的 DNS 服务器，而是攻击者控制的服务器。此外，某些恶意应用程序可以通过用户的网络浏览器实施此类攻击。

2. **篡改 DNS 服务器**：攻击者直接入侵并修改 DNS 服务器上的记录。当用户请求一个域名解析时，篡改后的 DNS 服务器会返回攻击者设定的错误 IP 地址。

3. **通过网络入侵**：攻击者可能会**控制用户与其 DNS 服务器之间的通信上下文**（**如在公共 Wi-Fi 上**），拦截和修改返回的 DNS 响应。

### DNS 劫持的目的

- **流量引导和广告**：攻击者通过劫持 DNS，将用户引导至广告网页，从而从中获利。
- **信息窃取**：通过假冒的登录页面进行钓鱼攻击，用以窃取用户的敏感信息（如用户名、密码、银行信息等）。
- **恶意软件传播**：诱导用户访问恶意网站，这些网站可能会尝试自动下载和执行恶意软件到用户设备。
- **操控网络流量**：有时，互联网服务提供商或政府可能也会使用 DNS 劫持来重定向用户访问特定页面，比如警告或阻止访问某些内容。

### 防范 DNS 劫持的方法

1. **使用安全的 DNS 服务**：选择公共 DNS 解析服务提供商，他们通常更安全，并且提供 DNSSEC 支持（如 Google Public DNS、Cloudflare DNS）。

2. **启用 DNSSEC**：确保使用支持 DNSSEC（域名系统安全扩展）的网站和服务，以验证 DNS 数据的完整性和真实性。

3. **注意并调整网络设备设置**： 经常检查和更新路由器及其他网络设备的固件，确保设置安全，不使用默认的用户名和密码。

4. **防火墙和杀毒软件**：使用最新的防火墙和反恶意软件保护个人计算机及网络设备，以防止恶意软件的安装和传播。

5. **HTTPS 和其他加密协议**：优先访问使用 HTTPS 的网站，以确保网络通信的保密性。

6. **教育和意识增强**：提高用户对钓鱼攻击和恶意网站的警惕性，并教育他们识别和避免潜在的安全威胁。

通过采用这些策略，可以大大降低 DNS 劫持和相关风险的可能性。

## cookie二级作用域共享

在Web开发中，Cookie是一种用于存储用户数据的小型文本文件，存储在用户的浏览器中。通过Cookie，网站可以在用户访问时记住用户的信息，比如用户身份、偏好设置等。Cookie的作用域决定了它可以被哪些域名访问，特别是在涉及二级域名（子域）时，理解Cookie的作用域设置是至关重要的。

### 二级作用域共享

#### 什么是二级作用域？
当谈论域名时，通常以点分作为层次划分，比如：
- 主域名（顶级域）：example.com
- 子域名（一级子域）：sub.example.com，news.example.com 等

二级作用域就是指同一个主域名下的不同子域名共享资源的能力。在Cookie中，这意味着设置在主域（例如`example.com`）的Cookie可以被所有子域（如`sub.example.com`, `news.example.com`）访问。

#### 如何实现Cookie二级作用域共享？

1. **Domain 属性设置**：
   - 要使Cookie在主域和子域之间共享，必须正确设置Cookie的`Domain`属性。
   - 例如，当设置Cookie时，可以将`Domain`设置为`.example.com`（请注意前导点），这意味着该Cookie对所有子域都是可见的。

2. **Path 属性影响**：
   - 虽然`Domain`属性使Cookie跨越不同子域，但`Path`属性则控制从哪个URL路径开始共享。因此，灵活设置`Path`可以精确控制Cookie的可访问性。

3. **安全性和隔离注意事项**：
   - 允许多个子域共享Cookie意味着所有这些子域都可以读取和修改该Cookie，从而可能导致安全问题。如果一个不安全的子域受到攻击，可能使整个域的Cookie面临风险。

4. **设置示例**：
   - 在设置Cookie时，你可以这样指定：
     ```http
     Set-Cookie: mycookie=value; Domain=.example.com; Path=/
     ```
   - 上述设置意味着`mycookie`在所有example.com的子域和路径下都是有效的。

5. **浏览器行为**：
   - 大多数现代浏览器遵循相同的标准来实现Cookie的域共享，但仍需注意不一致性，尤其是在旧版本浏览器中或特殊的安全设置下。

#### 应用场景
- **单点登录（SSO）**：多个子域之间共享认证信息，用户在一个子域登录后，可以访问其他子域而无需再次验证。
- **用户跟踪和分析**：跨子域采集用户行为数据以进行统一的统计分析。
  

总之，通过理解和正确配置Cookie的Domain属性，开发者可以在Web应用中实现灵活的跨子域数据共享，为用户提供一致、流畅的体验，同时需谨慎考虑安全性挑战。

## 输入url，到服务器需要处理请求，到获取资源。网络层面做了什么，服务器做了什么

当你在浏览器中输入一个URL并访问一个网站时，涉及到多层次的网络交互和服务器处理过程。以下是这一过程的详细分解：

### 网络层面:

1. **DNS解析**：
   - **DNS查询**：浏览器会向DNS服务器发起请求，将人类可读的域名转换为IP地址，找到目标服务器的位置。
   - **DNS缓存**：浏览器、操作系统和网络中的DNS服务器缓存可能会存储之前的解析结果以减少延迟。

2. **TCP连接**：
   - **三次握手**：客户端与服务器之间通过TCP进行三次握手，以建立可靠的连接。
   - **TLS握手（如果使用HTTPS）**：如果网站使用的是HTTPS，还需要进行TLS握手以协商加密参数，确保后续数据传输的安全性。

3. **HTTP请求**：
   - **请求发送**：浏览器根据URL构建HTTP请求报文，并发送至服务器。这包括请求行（方法、资源路径、HTTP版本）、头部（如User-Agent、Cookies）和可能会有的请求体。

### 服务器层面:

1. **请求接收与处理**：
   - 服务器接收到请求后，会根据请求头部和路径信息解析出目标资源。
   - **负载均衡**：如果请求经过负载均衡器，它会选择一台最优的应用服务器或后端服务来处理请求。

2. **资源获取**：
   - **静态资源**：对于HTML、CSS、JavaScript、图像等静态资源，服务器直接从文件系统或缓存中读取并返回。
   - **动态生成**：对于需要动态生成的内容（如用户信息），服务器会通过后端逻辑处理请求，可能需要与数据库或其他服务交互获得数据。

3. **数据库查询与后端服务调用**（如果需要）：
   - 服务器可能需要查询数据库以获取动态数据，或者调用其他后端服务。
   - 数据库查询通常涉及SQL执行或NoSQL数据库操作，以检索或更新数据。

4. **响应生成**：
   - 服务器将请求处理结果生成HTTP响应报文，包括状态行（状态码、状态描述、HTTP版本）、头部（如Content-Type，Cache-Control），以及可能的响应体（HTML、JSON、XML等数据）。

5. **发送响应**：
   - 服务器将生成的响应报文通过网络传回客户端。

### 网络层面（再次）：

1. **TCP连接释放**：
   - **四次挥手**：响应数据发送完毕后，客户端和服务器进行四次挥手以释放TCP连接，若开启了`HTTP Keep-Alive`，可以复用连接处理更多请求。

2. **浏览器解析和呈现**：
   - 浏览器接收HTTP响应后，解析HTML/CSS/JavaScript等资源，并展示页面。

在整个过程中，网络优化（如CDN、压缩、缓存）和服务器性能（如高效的I/O处理、合适的线程数配置）也是影响用户体验的重要因素。

## 假设你不用现成的框架，自己去写一个web server框架，你觉得你需要做什么

创建一个Web服务器框架是一个复杂而富有挑战性的任务，因为它需要处理从网络协议到应用逻辑的广泛问题。以下是构建一个从零开始的Web服务器框架所涉及的关键步骤和组件：

1. **网络协议处理**：
   - **TCP/IP通信**：实现底层的套接字编程，以建立和管理TCP/IP连接，包括处理连接的接收、保持和关闭。
   - **HTTP解析**：编写代码解析HTTP请求和响应，处理请求行、头部、和可能存在的请求体。

2. **请求处理机制**：
   - **请求路由**：设计路由机制以将HTTP请求的路径映射到相应的控制器处理函数。
   - **中间件架构**：支持中间件以在请求处理过程中插入特殊行为（例如：验证、日志记录、错误处理等）。

3. **响应生成**：
   - **内容生成**：允许应用程序生成不同的响应类型（如HTML、JSON、静态文件）。
   - **状态管理**：实现设置和返回适当的HTTP状态码和响应头。

4. **并发处理**：
   - **同步与异步机制**：提供处理多个并发请求的能力。可以利用多线程或异步I/O来实现这一点，视编程语言和需求而定。

5. **会话与状态管理**：
   - **Cookie和Session支持**：实现会话管理机制，以在请求间维持状态（如用户认证状态）。
   - **跨域资源共享**：如果需要，支持CORS以允许跨域请求。

6. **安全性**：
   - **输入验证**：防止注入攻击，确保请求数据的安全。
   - **SSL/TLS支持**：实现对HTTPS的支持，以保证数据传输的安全性。
   - **身份验证机制**：提供用户身份验证和授权框架。

7. **静态文件服务**：
   - **静态资源托管**：实现对CSS文件、JavaScript文件和图像等静态资源的高效服务。

8. **模板引擎（可选）**：
   - **视图渲染**：开发或集成模板引擎以支持动态生成HTML页面。

9. **开发工具支持**：
   - **热加载**：在开发环境中支持热重载以便快速迭代。
   - **调试与测试设施**：提供良好的日志记录、错误报告机制，并支持单元测试和集成测试。

10. **文档与示例**：
    - **API文档**：为开发者提供清晰的API文档和使用指南。
    - **示例应用**：提供示例应用程序展示框架的功能。

构建一个Web服务器框架涉及到系统设计、网络编程、安全性、并发处理、应用开发等多个领域的知识。这通常需要时间和团队协作，并需要持续的维护和更新以保持安全和性能的稳定。

## 监听请求你怎么判断是否要给你返回数据

在设计一个Web服务器框架时，判断是否需要返回数据给客户端主要依赖于对HTTP请求的分析和服务器逻辑的处理。以下是一些关键考虑因素和判断流程：

1. **HTTP方法**：
   - 不同的HTTP方法通常对应着不同的处理逻辑。如GET请求通常用于请求数据，POST请求用于提交数据，PUT请求用于更新数据，DELETE请求用于删除数据。了解请求方法能帮助判断是否需要返回数据及其类型。

2. **请求路径（URL）和路由**：
   - 基于请求的URL路径，服务器可以通过预定义的路由规则来确定相应的处理程序。
   - 不同的路径对应不同的逻辑，有些路径可能只返回状态信息而不返回数据。

3. **请求头（Headers）**：
   - 分析请求头部信息可能影响响应。例如，`Accept`头部指示了客户端期望的数据格式（如HTML、JSON、XML等），服务器需要根据这些偏好来决定返回数据的格式。
   - `Authorization`、`Cookies`等头部用于鉴权，可能影响服务器是否返回预期的数据。

4. **认证和授权**：
   - 检查请求中的认证信息（如API key、Token）来决定请求是否合法。
   - 只有在请求通过验证后，才返回相应的数据，否则可能只返回错误状态码（如403 Forbidden或401 Unauthorized）。

5. **业务逻辑与条件判断**：
   - 根据业务逻辑，判断是否满足返回数据的条件。例如，查询请求可能要求查询到的对象存在；更新请求要求提交的数据有效性验证成功。

6. **错误处理**：
   - 错误情况（如资源未找到、服务器错误等）通常只需要返回适当的HTTP状态码及错误信息，而不返回预期的数据。
   - 使用状态码（如200 OK, 404 Not Found, 500 Internal Server Error）来表明请求的结果。

7. **缓存策略**：
   - 在某些情况下，通过判断缓存的有效性（如Last-Modified, ETag头部），服务器可能决定直接返回304 Not Modified而不是新数据。

8. **速率限制和请求频率**：
   - 检查请求频率，并根据速率限制策略决定是否返回数据或拒绝请求（如429 Too Many Requests）。

9. **业务逻辑变化和A/B测试（可选）**：
   - 基于动态的业务逻辑调整或A/B测试策略，可能会决定同一请求向不同用户返回不同的数据。

通过上述步骤，服务器能够细化处理对请求的响应，确保在正确的情况下返回所需的数据，而不符合条件的请求则通过适当的机制予以拒绝或部分处理。

## 起了一个web server之后，一台机器能够建立多少TCP链接受到什么因素影响

一台机器能够建立的TCP连接数量主要受以下几个因素的影响：

1. **操作系统限制**：
   - **文件描述符限制**：每个TCP连接在操作系统中都被表示为一个文件描述符，系统对每个进程和整个系统能够打开的文件描述符数量有限制。在Unix/Linux系统中，可以通过`ulimit`命令来查看和设置用户进程的文件描述符限制。需要注意的是，调整这个限制必须兼顾系统资源并行度，以免负载过高导致性能下降。
   - **可用端口数量**：TCP连接的每个端都需要一个唯一的IP地址和端口组合，而可用的端口范围通常是从1024到65535（1024以下是特权端口），因此理论上每个IP地址最多可以有64511个并发连接。

2. **网络带宽**：
   - 在高并发情况下，网络带宽会成为瓶颈。即便系统允许创建大量连接，有限的带宽可能无法支持这些连接以合理的速度进行数据传输。

3. **内存和CPU资源**：
   - 每个TCP连接需要一定的内存开销来维护连接状态信息，如TCP缓冲区等。如果内存不足，系统将无法再处理更多的连接。
   - CPU资源的限制也很关键。大量并发连接需要大量的计算和上下文切换，容易导致CPU饱和。

4. **TCP参数设置**：
   - **TCP TIME_WAIT状态**：当连接关闭后，TCP连接进入TIME_WAIT状态以确保正确处理迟来的连接包和避免端口复用带来的冲突。默认状态持续时间大约在30-120秒内。过多的连接进入TIME_WAIT会消耗可用端口资源。可以通过调整系统参数来优化（例如缩短TIME_WAIT持续时间）。
   - **连接超时**：配置合适的连接超时时间来释放长时间无活动的连接。

5. **服务器架构和应用设计**：
   - **并发模型**：服务器的并发处理模型（如多线程、进程池、事件驱动）会影响连接的处理能力。
   - **应用程序逻辑**：如果应用程序不能有效地处理请求，即使系统允许多个连接，也可能会因为应用吞吐量限制而影响连接的数量。

6. **网络环境**：
   - **网络延迟和抖动**：不稳定的网络条件会影响建立和维持TCP连接的有效性。
   - **防火墙和其他网络设备限制**：防火墙或负载均衡器可能设有对连接数的限制。

通过合理配置系统资源、优化应用程序和调整网络环境设置，可以增加单机能够容纳的并发TCP连接的数量。弹性扩展、负载均衡和分布式架构也可以用来提升整体系统的连接处理能力。

## http1.1加载多张图片是一张一张加载还是同时加载

HTTP/1.1 协议在加载多张图片时，使用的是“并发连接”的方式，这意味着浏览器会同时发起多个请求来加载图片，但并发连接的数量是有限的。具体行为取决于浏览器的实现和网络环境。以下是一些关键点：

### 并发连接限制

1. **同一个主机的并发连接数**：
   - HTTP/1.1 规定同一时间内对同一个主机（域名）并发连接数通常被限制在 6 到 8 个连接，具体的数量取决于浏览器的实现。例如，一些常见的浏览器设置如下：
     - Chrome：6 个并发连接
     - Firefox：6 个并发连接
     - Safari：6 个并发连接
     - Internet Explorer 11：6 个并发连接

2. **跨域并发**：
   - 对于不同主机（域名），浏览器可以分别建立并发连接。所以如果资源（图片）来自不同的域名，理论上可以有更多的并发连接。

### 加载机制

当浏览器需要加载多个图片资源时，如加载一个包含多张图片的网页，浏览器会按以下策略处理：

1. **先建立连接**：对于同一域名，浏览器会利用其并发连接的限制规则，建立多个 TCP 连接。
2. **并发加载**：一旦连接建立成功，浏览器会在多个连接上并发地请求图片资源。
3. **排队机制**：如果当前已经达到并发连接数的上限，其他资源将暂时排队等待，直到有连接空闲下来为止。
4. **请求复用**：某些浏览器和网络环境可能会利用 HTTP/1.1 的 Keep-Alive 连接复用功能，在同一个 TCP 连接上连续发送多个 HTTP 请求，从而减少建立连接的开销。

### 性能优化

对于大量图片的加载，除了理解浏览器的并发连接限制，还可以考虑以下性能优化方法：

1. **使用 HTTP/2**：
   - HTTP/2 支持多路复用（Multiplexing），意味着在一个单独的 TCP 连接上可以同时并发多个请求和响应，大幅提高了资源加载效率。
   
2. **图片精灵（Sprite）**：
   - 使用 CSS 图片精灵，将多张图片合并到一张图片中，从而减少请求数。

3. **图片延迟加载（Lazy Loading）**：
   - 只有当图片即将出现在视口时才加载，减少初始页面加载时间。

4. **内容分发网络（CDN）**：
   - 使用 CDN 来分发图片资源，减少加载时间并可能增加总的并发连接数。

5. **分域名托管（Sharding）**：
   - 将资源分布在多个子域名下，增加并发连接数。但过多的分域名使用可能导致 TCP 连接建立和 DNS 查询的开销增加，需要权衡。

### 示例

假设一个网页包含了 12 张图片，所有图片都来自同一域名：

```html
<img src="image1.jpg" />
<img src="image2.jpg" />
<img src="image3.jpg" />
...
<img src="image12.jpg" />
```

在 HTTP/1.1 规范下，浏览器可能会按照以下步骤加载：

1. 浏览器会在该域名上建立`6`个并发连接（假设并发连接数限制为 6）。
2. 一开始这 6 个并发连接会同时请求前 6 张图片。
3. 当 6 个连接中的任意一个完成后，请求第 7 张图片，以此类推，直到所有图片加载完毕。

最终的加载顺序和时间取决于图片大小、服务器响应速度、网络状况等多种因素。

### 结论

在 HTTP/1.1 中，浏览器加载多张图片时会尽可能地使用多个并发连接来同时请求多个图片资源，但并发连接的数量是有限的。因此，在实际加载过程中，可能会有少量图片在等待空闲连接的过程中出现“排队”等待的现象。这种限制在 HTTP/2 中通过多路复用得到了很大的改进。

## Vue和React应用可以被搜索引擎直接搜索到吗

Vue 和 React 是两种受欢迎的前端 JavaScript 框架，可以用于构建复杂的单页应用（SPA）。然而，SPA 由于其动态加载内容的特点，在搜索引擎优化（SEO）方面面临一些挑战。以下是关于 Vue 和 React 应用是否可以被搜索引擎直接搜索到的详细解释：

### 搜索引擎抓取和索引动态内容的挑战

#### 1. 对于传统的搜索引擎爬虫

- **传统问题**：大多数搜索引擎爬虫（如早期的 Googlebot）偏向抓取和索引静态 HTML 内容。SPA 应用的内容通常是通过 JavaScript 动态加载的，初始加载时只有少量的 HTML 和 JavaScript 代码，页面内容需要在浏览器执行 JavaScript 后才会出现。
- **初始加载问题**：爬虫在抓取时，如果不能正确执行和解析页面上的 JavaScript，就只能看到一个空白或者非常简陋的页面，导致内容可能不会被索引。

#### 2. 现代搜索引擎对动态内容的处理

- **Google**：Googlebot 可以执行和解析大部分的 JavaScript，大多数情况下能够抓取和索引现代前端框架构建的 SPA。但是，这个过程比传统抓取静态 HTML 更复杂和费时，可能会遇到某些个别情况（如异步数据加载过慢、页面渲染延迟等）导致索引不完全或者滞后。
- **其他搜索引擎**：Bing、百度等搜索引擎对动态 JavaScript 内容的处理能力可能不如 Google，因此有时不能正确索引 SPA 页面内容。

### 如何改进 Vue 和 React 应用的 SEO

为了确保 Vue 和 React 应用能够更好地被搜索引擎抓取和索引，可以采用以下技术和策略：

#### 1. 服务器端渲染（SSR）

- **Vue**：Vue 提供了一个官方解决方案 Vue.js 服务端渲染（Vue SSR），可以渲染 Vue 组件为 HTML 字符串在服务器端输出，从而在初始加载时生成完整的 HTML 内容。常见工具为 Nuxt.js，它是一个基于 Vue.js 的框架，支持服务器端渲染。
- **React**：React 同样提供了服务器端渲染（React SSR）的解决方案，使用 `ReactDOMServer.renderToString` 或 `ReactDOMServer.renderToNodeStream` 方法在服务器端渲染 React 组件。Next.js 是一个基于 React 的流行框架，原生支持服务器端渲染。

#### 2. 预渲染（Prerendering）

预渲染是在构建时生成静态 HTML 文件并部署到服务器上，适合内容不常变动的页面。Prerendering 工具会在构建过程中执行 JavaScript，并输出最终渲染的 HTML。

- **Vue**：可以使用 Prerender SPA Plugin。
- **React**：可以使用 Prerender SPA Plugin 或 React Snap。

#### 3. 动态渲染（Dynamic Rendering）

动态渲染是根据用户代理（User-Agent）决定是向客户端发送客户端渲染版本还是预渲染版本（通常预渲染版本只对爬虫提供）。服务端检测到是搜索引擎爬虫时，返回预渲染的静态 HTML。

- 一些常用的动态渲染服务包括：Prerender.io 和 Rendertron。

### 总结

- **直接抓取和索引**：现代搜索引擎（如 Google）有能力直接抓取和索引由 Vue 和 React 构建的 SPA 应用，但是并不能保证所有内容都能完全和及时被索引。
- **SEO 优化**：使用服务器端渲染（SSR）、预渲染（Prerendering）或动态渲染（Dynamic Rendering）等技术，可以显著提高 SPA 应用的可索引性，确保内容更好地被搜索引擎抓取和索引。

通过适当的优化措施，可以让 Vue 和 React 应用更加友好地呈现给搜索引擎，提高 SEO 效果。选择适合项目需求的优化技术，可以在确保良好用户体验的同时，提升网站的搜索引擎表现。

## 前端CSRF/XSS/SQL 注入等安全问题

### 1. 跨站请求伪造 (CSRF)

**1.1 定义:**

CSRF 攻击利用了 Web 应用信任用户浏览器发出的请求的特点，诱骗用户在其已登录的网站上执行恶意操作。 

**1.2 攻击原理:**

1. **用户登录目标网站:**  受害者登录目标网站 (例如网银)，网站在其浏览器中设置身份验证 Cookie。
2. **访问恶意网站:** 攻击者诱骗受害者访问恶意网站或点击恶意链接。
3. **发送伪造请求:** 恶意网站向目标网站发送请求，该请求可能包含修改用户信息、转账等恶意操作。 由于受害者已登录目标网站，浏览器会自动带上目标网站的 Cookie。
4. **目标网站执行操作:** 目标网站收到请求，根据 Cookie 识别出是受害者发出的，执行了恶意操作，而受害者完全不知情。

**1.3  例子:**

假设您已登录网银，攻击者给您发送一封邮件，其中包含一个隐藏的图片链接：

```html
<img src="https://yourbank.com/transfer?amount=1000&to=attacker" />
```

当您打开邮件时，浏览器会自动加载图片，相当于向网银发送了一个转账请求。如果网银没有 CSRF 防护措施，您的账户就会被盗取 1000 元。

**1.4 前端预防措施:**

*   **Same-Site Cookie 属性:**
    *   `Strict`：Cookie 仅在与设置 Cookie 的网站完全相同的域名下发送，最严格的策略。
    *   `Lax`：Cookie 在大多数情况下仅在相同站点下发送，除了从外部链接导航到目标网站时，例如通过链接打开页面。
    *   `None`：Cookie 可以跨站发送，需要配合其他措施使用。

*   **验证 HTTP Referer 头:**  Referer 头部信息包含了请求来源页面的 URL。服务器可以检查 Referer 是否来自可信域名，但 Referer 可以被篡改或隐藏，不能完全依赖。

*   **使用 Anti-CSRF Token:**
    *   服务器生成一个唯一的、不可预测的 Token，嵌入到表单或请求中。
    *   服务器验证请求中 Token 的有效性，确保请求来自合法的来源。

**1.5  前端代码示例 (Anti-CSRF Token):**

```javascript
// 前端发送请求时添加 Token
fetch('/transfer', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': document.cookie.replace(/(?:(?:^|.*;\s*)csrftoken\s*\=\s*([^;]*).*$)|^.*$/, "$1") 
  },
  body: JSON.stringify({ amount: 1000, to: 'recipient' })
})
```

**1.6  后端需要配合验证 Token:**

```python
# Python Flask 示例
from flask import Flask, request, session

app = Flask(__name__)

@app.route('/transfer', methods=['POST'])
def transfer():
  if request.method == 'POST':
    csrf_token = request.headers.get('X-CSRF-Token')
    if csrf_token and csrf_token == session.get('csrf_token'):
      # 处理转账逻辑
    else:
      return 'Invalid CSRF token', 403
```

### 2. 跨站脚本攻击 (XSS)

**2.1 定义:**

XSS 攻击通过将恶意脚本注入到受害者访问的网站中，在受害者浏览器中执行攻击者预设的代码。

**2.2 攻击原理:**

1. **寻找漏洞:** 攻击者找到网站漏洞，例如没有对用户输入进行过滤和编码的表单、评论区等。
2. **注入恶意脚本:** 攻击者将恶意 JavaScript 代码注入到网站中。
3. **用户访问网站:** 受害者访问受攻击的网站，浏览器解析并执行了恶意脚本。
4. **执行恶意操作:** 恶意脚本可以窃取 Cookie、修改页面内容、发起钓鱼攻击、传播恶意软件等。

**2.3 XSS 类型:**

*   **存储型 XSS:** 恶意脚本存储在服务器数据库中，所有访问受影响页面的用户都会受到攻击。 
*   **反射型 XSS:** 恶意脚本包含在 URL 参数或表单数据中，攻击者需要诱骗用户点击恶意链接。
*   **DOM-based XSS:** 恶意脚本没有发送到服务器，而是直接在浏览器 DOM 中执行。

**2.4  例子:**

假设网站存在评论功能，攻击者提交以下评论：

```html
<script>alert('XSS attack!');</script>
```

如果网站没有对评论内容进行过滤，其他用户访问该页面时，浏览器会执行这段脚本，弹出警告框。

**2.5 前端预防措施:**

*   **输入验证和输出编码:** 
    *   **输入验证:** 对用户输入进行严格的过滤，限制输入长度、字符类型等。
    *   **输出编码:**  将用户输入的内容进行 HTML 编码、JavaScript 编码等，防止浏览器将其解释为代码执行。

*   **使用安全的框架和库:**  使用提供 XSS 防护的框架和库，例如 React、Vue.js 等。这些框架通常会自动对用户输入进行转义，降低 XSS 风险。

*   **设置 Content Security Policy (CSP):**  CSP 是一种安全机制，允许网站开发者控制浏览器加载资源的来源，例如脚本、图片、音频等。通过设置 CSP，可以限制浏览器执行恶意脚本，有效防御 XSS 攻击。

**2.6 前端代码示例 (输出编码):**

```javascript
// 使用 DOM API 创建元素并设置内容
const commentElement = document.createElement('div');
commentElement.textContent = userComment; // 使用 textContent 避免将内容解析为 HTML 

// 使用 innerHTML 时进行转义
const commentElement = document.createElement('div');
commentElement.innerHTML = escapeHTML(userComment); 

function escapeHTML(html) {
  return html.replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
}
```

**2.7  CSP 示例:**

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted.cdn.com">
```

这段代码表示只允许加载来自当前域名和 `https://trusted.cdn.com` 的脚本文件，有效防止加载恶意脚本。

### 3. SQL 注入

**3.1 定义:**

SQL 注入攻击利用 Web 应用程序漏洞，将恶意 SQL 代码注入到数据库查询中，从而窃取数据或控制数据库。

**3.2 攻击原理:**

1. **寻找漏洞:** 攻击者寻找 Web 应用中没有对用户输入进行过滤和转义的漏洞，例如登录表单、搜索框等。
2. **构造恶意 SQL 语句:** 攻击者构造包含恶意代码的 SQL 语句，例如查询敏感信息、修改数据、删除数据等。
3. **注入恶意 SQL:** 攻击者将恶意 SQL 语句注入到 Web 应用的数据库查询语句中。
4. **数据库执行恶意操作:** 数据库执行了包含恶意代码的 SQL 语句，导致数据泄露或数据库被控制。

**3.3  例子:**

假设网站有如下登录逻辑：

```sql
SELECT * FROM users WHERE username = '$username' AND password = '$password'; 
```

攻击者可以在用户名输入框中输入：

```
admin'--
```

这会将 SQL 语句变成：

```sql
SELECT * FROM users WHERE username = 'admin'--' AND password = '$password'; 
```

由于 `--` 后面的内容被注释掉，攻击者无需知道密码即可登录管理员账户。

**3.4 前端预防措施:**

*   **前端无法完全防御 SQL 注入，主要责任在后端！**
*   **前端可以进行输入验证，过滤敏感字符，降低风险，但不能完全依赖前端。**

**3.5 后端防御措施:**

*   **使用参数化查询或预编译语句:** 
    *   参数化查询将 SQL 代码和数据分开处理，数据库会将数据作为参数传入预编译的 SQL 语句中，防止 SQL 注入。
*   **输入验证和转义:** 
    *   对用户输入进行严格的过滤和转义，例如使用数据库提供的转义函数对特殊字符进行转义。
*   **最小权限原则:** 
    *   为数据库用户设置最小权限，避免攻击者获得过高的权限。


### 总结

*   前端安全问题需要前后端共同防御。
*   前端需要关注输入验证、输出编码、安全框架和库、CSP 等方面。
*   后端需要关注 SQL 注入、CSRF Token 验证、数据加密、身份验证等方面。

希望以上信息能够帮助您更全面地理解前端安全问题！如果您还有其他问题，请随时提出。

## http在7层协议的哪层，https呢

在 OSI 七层模型中，HTTP 和 HTTPS 均属于应用层。OSI 模型（开放系统互连模型）将网络通信过程分为七个不同的层次，每个层次都有其特定的功能。这七层自下而上分别是：

1. **物理层**：负责传输原始的比特流。
2. **数据链路层**：负责介质访问控制和检错。
3. **网络层**：负责路径选择和逻辑地址寻址（如 IP 协议）。
4. **传输层**：负责端到端的连接和数据传输（如 TCP、UDP 协议）。
5. **会话层**：负责建立、管理和终止会话。
6. **表示层**：负责数据格式化、加密和解密。
7. **应用层**：负责网络服务和最终用户应用程序交互。

### HTTP 和 HTTPS

- **HTTP（超文本传输协议）**：
  - 位于应用层，用于由客户端（如浏览器）向服务器请求网页和其他资源。
  - 通过明确的请求-响应模式工作。

- **HTTPS（超文本传输协议安全）**：
  - 也是位于应用层，HTTP 的增强版本，通过使用 SSL/TLS（安全套接层/传输层安全）协议来加密数据传输。
  - 加密与解密的过程涉及到传输层及表示层的一些功能（如加密解密、认证等），但作为协议本身，HTTPS 仍属于应用层。

因此，在讨论直接属于应用层的协议时，HTTPS 和 HTTP 都被归类于应用层。但是，HTTPS 引入 SSL/TLS 协议作为附加的安全层，而该安全层也涉及到 OSI 模型的其他层次（例如表示层中的加解密）。

## TTL/SSL是在哪两层之间

TTL（Time to Live）和SSL（Secure Sockets Layer）处于计算机网络模型的不同部分，并且它们有着完全不同的用途。因此，我们不能用相同的标准来讨论它们。然而，我们可以分别讨论它们在网络堆栈中的位置和作用。

### TTL（Time to Live）
TTL是IP包中的一个字段，用于限制包在网络中的生存时间，避免在环路中无限循环。

- **TTL的位置**：TTL字段在IP协议头中，因此它是属于网络层（OSI模型的第三层）。
- **作用**：每当一个IP包通过一个路由器时，TTL值会减少1。当TTL值变为0时，包会被丢弃并且通常会发送一个ICMP消息回到发送方。

### SSL（Secure Sockets Layer）
SSL是一种用于在两个通信应用程序间提供安全通信的协议。

- **SSL的位置**：SSL最初是在传输层（OSI模型的第四层）和会话层（OSI模型的第五层）之间工作，它在TCP之上和应用层协议（如HTTP）之下工作。现代的TLS（Transport Layer Security）协议是SSL的继任者。
- **作用**：SSL/TLS通过加密提供数据的机密性、完整性和认证，确保通信双方可以在不受监听和篡改的情况下交换数据。

### 它们在网络模型中的相对位置

1. **TTL在网络层**：网络层（第三层）
   - 负责包的路由传输。
   - 包含IP地址和TTL等字段信息。

2. **SSL/TLS在传输层和会话层之间**：
   - 传输层（第四层）：负责端到端的通信，如TCP。
   - 会话层（第五层）：负责会话管理。
   - SSL/TLS工作在应用层协议（如HTTP）和传输层协议（TCP）之间。

### 示例
假设我们有一个HTTPS请求：

1. **互联网协议**：数据包在网络层（Layer 3）使用IP进行寻址和路由，其中包含TTL字段。
2. **传输层协议**：在传输层（Layer 4），TCP确保数据按顺序、无错误地传送。
3. **SSL/TLS协议**：SSL/TLS位于会话层（Layer 5）和传输层之间，确保数据加密和安全。
4. **应用层协议**：在应用层（Layer 7），HTTP处理实际的数据请求和响应。

### 总结
- **TTL**：位于网络层（OSI模型的第三层），控制数据包在网络中的生存时间。
- **SSL/TLS**：工作在传输层和会话层之间（OSI模型的第四和第五层），提供安全通信。

它们在网络模型的不同层次上发挥作用，一个用于包传输的时间控制，另一个用于数据加密和安全。

## 图片是哪种缓存，js，html是哪种

在Web开发中，缓存是一种优化技术，用来提高页面加载速度和减轻服务器负载。浏览器主要通过HTTP缓存机制来缓存各种类型的资源。不同类型的资源（如图片、JS、HTML等），浏览器使用相同的缓存机制，但可以根据不同资源类型和其特性进行优化。

以下是对不同类型资源缓存的详细说明：

### 图片资源的缓存
图片资源通常是静态的，并且不频繁变化，因此适合长时间缓存。

- **缓存策略**：常用的策略包括 `Cache-Control: max-age`、`Expires`、`ETag`、`Last-Modified` 等。
- **示例**：
  ```http
  Cache-Control: max-age=31536000
  ```
  上述头部指示浏览器可以缓存图片资源长达1年（31536000秒）。

### JavaScript (JS) 文件的缓存
JavaScript文件通常是站点功能的核心，因此对其缓存策略的控制非常重要。

- **缓存策略**：与图片类似，使用 `Cache-Control`、`Expires`、`ETag` 和 `Last-Modified`。对于经常变更的JS文件，推荐使用版本号或哈希值来控制缓存。
- **示例**：
  ```http
  Cache-Control: max-age=31536000
  ```
  还可以使用文件名中的哈希值，如 `main.abc123.js`，当文件内容变化时哈希值也变化，从而有效地刷新缓存。

### HTML 文件的缓存
HTML文件通常需要经常更新，因为它们包含页面结构和内容。过时的HTML缓存会导致用户看到旧的页面，因此需要较短的缓存时间。

- **缓存策略**：通常使用较短的 `max-age` 或者不使用缓存（`no-cache`）。
- **示例**：
  ```http
  Cache-Control: no-cache
  ```
  这个头部指示浏览器每次都要验证服务器上的文件更新，而不是直接从缓存中读取。

### HTTP 头部对比总结

1. **图片资源（静态，长时间缓存）**：
   ```http
   Cache-Control: max-age=31536000
   Expires: Sun, 31 Dec 2023 23:59:59 GMT
   ```
2. **JavaScript 文件（版本控制或中等时间缓存）**：
   ```http
   Cache-Control: max-age=31536000
   Expires: Sun, 31 Dec 2023 23:59:59 GMT
   ```
   或者更改文件名:
   ```
   main.abc123.js
   ```
3. **HTML 文件（短时间缓存或每次验证）**：
   ```http
   Cache-Control: no-cache
   ```
   或者:
   ```http
   Cache-Control: max-age=0, must-revalidate
   ```

### 浏览器缓存行为
浏览器使用这些HTTP头部指示的策略来缓存不同类型的资源，它会：

- 根据 `Cache-Control` 和 `Expires` 决定是否缓存文件以及缓存时间。
- 根据 `ETag` 和 `Last-Modified` 进行缓存文件的验证，查看缓存的文件是否仍然有效。

### 总结
- **图片** 通常设置为长时间缓存例如一年，因为图片资源一般为静态且不频繁变化。
- **JavaScript文件** 通常设置为中等时间缓存或者版本控制，通过文件名哈希值控制缓存，以确保每次有新版本时缓存自动刷新。
- **HTML文件** 设置为短时间缓存或每次验证，确保页面内容最新。

通过合理设置缓存策略，可以有效利用缓存提高网页响应速度，同时确保用户总是能看到最新的内容。

## js有哪些强制更新GPU的方法

在JavaScript中，尽管开发者通常不直接控制GPU（图形处理单元），但可以通过一些技巧和方法来提示浏览器利用GPU，从而提升图形渲染性能。这些方法通常涉及到Web浏览器的渲染优化，尤其是对于动画和图形密集型任务。

以下是一些在Web开发中强制或提示浏览器使用GPU加速的方法：

1. **使用CSS硬件加速**：
   - 通过特定的CSS属性，可以提示浏览器使用GPU进行渲染。
   - 常用的属性包括`transform`（如`transform: translate3d(0, 0, 0)`）、`will-change`等。使用这些属性可以将元素提升为一个合成层，这样浏览器会尝试使用GPU加速其渲染。

     ```css
     .example {
         transform: translate3d(0, 0, 0); /* 或者 */
         will-change: transform;
     }
     ```

2. **Canvas绘图**：
   - 在使用`<canvas>`进行绘图时，确保合理地使用绘画生命周期，并且减少重绘次数，这样浏览器将更有可能使用GPU进行绘制优化。
   - 对于WebGL（Web Graphics Library）内容，浏览器通常会默认利用GPU，因此通过WebGL API进行的操作直接与GPU交互。

3. **请求动画帧（`requestAnimationFrame`）**：
   - 使用`requestAnimationFrame`来控制动画帧的刷新，它会叙述浏览器用最优化的方式进行重绘和重新布局，这是实现高性能动画的标准做法。
   
    ```javascript
    function animate() {
        // 在这里执行动画更新和渲染逻辑
        requestAnimationFrame(animate);
    }
    animate();
    ```

4. **优化CSS和JavaScript**：
   - 如有可能，减少不必要的CSS重排和重绘。通过最小化和合并CSS和JavaScript，以及避免使用繁重的动画（比如`box-shadow`），可以让浏览器更有效地利用GPU进行渲染。
   
5. **使用合成动画**：
   - 尽量使用不引起布局重排的属性来执行动画。这包括`opacity`和`transform`属性，这些通常会被浏览器优化为合成动画，避免造成整个页面的重绘。

6. **Web Workers**：
   - 尽管WebWorkers本身不直接影响GPU，它们可以被用来处理繁重的计算任务，在不阻塞主线程的情况下，提高UI响应速度，从而间接贡献于渲染效率。

这些方法并不是直接控制GPU的手段，而是通过优化代码，合理使用浏览器特性以及兼顾设备的硬件加速能力，促使浏览器更好地利用系统的GPU资源进行图形渲染。如果你在从事需要直接GPU编程的工作，例如3D图形应用程序，深入学习和使用WebGL会是一个重要的方向。

## 如何避免重复请求

#### 中间变量

```javascript
let isRequesting = false

function requestResource(){
    if(isRequesting) return;
    axios({
        //请求
    })
    .finally{
        isRequesting = true;
    }
}
```

如果两个模块同时请求一个接口, 可以在一个共同组件去请求, 然后这两个地方使用请求下来的缓存

## 请解释一下token登录的实现方式

Token登录是一种常用的用户身份验证和会话管理机制，广泛应用于现代Web应用中。它通常用于替代传统的基于会话（session）的认证方式，以提供更好的可扩展性和安全性。下面是Token登录的基本实现方式和相关概念：

### 基本流程

1. **用户登录**：
   - 用户通过客户端（如浏览器或移动应用）向服务器发送登录请求，通常包含用户名和密码。

2. **验证凭据**：
   - 服务器验证用户提供的凭据（如用户名和密码）。如果验证成功，服务器将生成一个加密的Token。

3. **发送Token**：
   - 服务器将生成的Token返回给客户端。客户端通常会将这个Token存储在Cookie、LocalStorage或SessionStorage中。

4. **请求资源**：
   - 客户端在后续请求中将Token附加到HTTP请求中（通常通过HTTP头部，如`Authorization: Bearer token_value`）来访问受保护的资源。

5. **验证Token**：
   - 服务器接收到请求时，验证Token的有效性。如果Token有效且未过期，则允许访问资源，否则返回认证失败（如401 Unauthorized）。

6. **Token刷新**：
   - 如果使用短期有效的Token解决方案（如JWT），可以实现Token续期或刷新机制，以在用户长时间使用应用时保持会话活跃。

### 关键技术细节

#### 1. Token的生成

- **JWT（JSON Web Token）**：

  - JWT是一种开放标准（RFC 7519），用于在各方之间作为JSON对象安全地传输信息。它由三个部分组成：头部（header）、负载（payload）和签名（signature）。
  - 签名部分通过一个秘密密钥对头部和负载进行加密，确保数据的完整性和真实性。

  ```plaintext
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImphbmVk
  b2UiLCJyb2xlcyI6WyJhZG1pbiIsInVzZXIiXSwiZXhwIjoxNjM4NDg1MzYwfQ
  .hJH_fD9Xs-9To6L5GBw8X3e1QRjBLQ-2vVRYaGto-rk
  ```

#### 2. Token存储

- **浏览器环境**：
  - Cookie：可以设置为HttpOnly和Secure以增强安全性。
  - LocalStorage / SessionStorage：易于存储和访问，但需注意XSS攻击的风险。

#### 3. 安全性

- **HTTPS**：始终通过HTTPS传输Token，以防止Token在传输过程中被拦截。
- **过期时间**：Token应设置过期时间，防止长期有效性被滥用。
- **刷新Token**：实现短期Token+长周期Refresh Token策略，以减少用户重新登录的频率。

#### 4. Token解析与验证

- 服务器在接收请求时需要验证Token的签名，并检查Token头部与负载中的信息（如用户角色、权限等）。

### 优点

- **无状态性**：Token验证是无状态的，不需要服务器保存用户会话数据，方便服务扩展。
- **跨域支持**：适用于不同域之间的认证场景，尤其是前后端分离的应用结构。

通过这种方式，Token登录机制提升了用户体验和系统的安全性，同时简化了后台会话管理的复杂度。这使得Token验证成为现代Web应用中身份认证的不二选择。

## 如果我想在关闭浏览器后仍然保持登录状态，该怎么实现？

如果希望用户在关闭浏览器后仍然保持登录状态，可以采取一些策略来持久化身份验证信息。以下是几种实现方法：

### 1. 使用长期有效的Token

- **Refresh Token机制**：通过使用短期有效的Access Token和长期有效的Refresh Token组合，可以实现持续的用户认证。
  - **Access Token**：短期有效，通常用于具体请求中。
  - **Refresh Token**：长效，用于在Access Token到期后刷新获取新的Access Token。

#### 实现步骤：

1. **用户登录**：在用户初次登录时，服务器返回一个短期的Access Token和一个长期的Refresh Token。
2. **储存Tokens**：将Access Token存储在`LocalStorage`或`SessionStorage`中，而将Refresh Token存储在更安全的方式（如HttpOnly Cookie）。
3. **请求资源**：在请求受保护资源时使用Access Token。如果Access Token过期，使用Refresh Token向服务器请求新的Access Token。
4. **刷新Token**：Refresh Token的使用通常是在后台静默进行，无需用户干预，不过你可能需要处理Refresh Token失效的情况（例如定期提示用户重新登录）。

### 2. 存储Token于Cookie

- **使用HttpOnly和Secure Cookie**：将Token存在带有HttpOnly标志的Cookie中，这种Cookie仅供服务器访问，无法通过JavaScript访问，可以提高安全性。

#### 注意事项：

- 确保通过`Secure`属性强制Cookie仅在HTTPS连接上传输。
- 设置Cookie的`Expires`或`Max-Age`属性为未来某个时间，确保Cookie在浏览器关闭后不被删除。

### 3. 延长Token的过期时间

- **延长Token有效期**：使Token本身的过期时间更长，不过这可能存在安全问题，因为如果Token被恶意获取，其有效期也长。
- 通常与前述Refresh Token机制结合使用，以在用户活动时动态延长有效期间。

### 4. 处理和注意事项

- **安全性**：持久性登录意味着安全风险增加，因为如果用户的设备被盗，Token可能被滥用。因此，用安全机制保护Token至关重要：
  - 实现双重身份验证（2FA）以增加安全性。
  - 在有敏感操作时（比如修改密码、重要交易）始终要求重新输入密码或其他安全验证。

- **用户体验**：在提供持久性登录选项时，确保用户可以选择退出登录（例如提供一个“注销”或“退出”的功能），并在必要时强制用户重新登录（综合考量安全、新设备的接入等因素）。

以上方法结合使用可以有效地保持用户的登录状态，同时注意应用安全实践以保护用户隐私和数据安全。

## 如果 token 失效了但用户页面不刷新，这种情况合理吗

在许多应用场景中，token（如 JWT，OAuth token 等）被用作验证用户身份的手段。这些 token 通常有一个有效期，以确保安全性和控制用户会话的持续时间。当 token 失效时但用户页面不刷新，这种情况在一些应用中是合理且常见的。处理失效 token 的设计因应用的需求而异，但常见的做法包括：

1. **自动刷新 token**：
   - 使用 refresh token 来获取一个新的访问 token。页面可以设置一个定时器，在 token 过期前或检测到过期时自动请求刷新。
   - 保证用户会话的无缝体验，用户不需手动刷新页面或重新登录。

2. **检测 token 过期**：
   - 在每个 API 请求中检查 token 是否有效。如果请求返回401（未授权）或其它指示 token 过期的状态码，前端可以自动引导刷新 token 或引导用户重新登录。
   - 这种方法有助于在用户执行操作时动态地处理 token 过期。

3. **通知用户**：
   - 在检测到 token 失效时，应用可以通知用户他们的会话已过期，并引导其重新登录。显示提醒弹窗或其他用户界面通知来处理这种情况。

4. **安全考虑**：
   - 在处理 token 失效时，确保任何敏感操作在 token 仍有效时完成，并避免在过期后进行不安全的 API 调用。

### 合理性考虑

1. **用户体验**：
   - 为了提供流畅的用户体验，token 失效后不依赖页面刷新是合理的。自动管理会话能够避免用户频繁手动操作，提供更好的用户体验。

2. **安全性**：
   - 自动刷新 token 或引导用户重新登录需要妥善管理，以防止安全漏洞。特别是 refresh token，必须保存在安全位置（如 HttpOnly cookie）以防止 XSS 攻击。

3. **应用复杂性**：
   - 实现自动 token 刷新、检测过期和用户通知机制增加了应用的复杂性和维护成本，需要在开发时予以注意。

综合以上因素，在现代Web应用中，处理 token 失效的机制往往会更多依赖自动后台处理和动态交互，而不是要求用户手动刷新页面。这样可以提高用户的使用体验，而不损失安全性。

## 如何实现无感刷新

实现“无感刷新”主要是指在无需用户干预的情况下自动更新页面数据或状态，以确保用户体验的流畅性。通常，这涉及到应用程序在后台定期或基于事件更新数据而不要求用户刷新页面。以下是实现无感刷新的几种方法：

1. **轮询（Polling）**：
   - 周期性地使用 `setInterval` 或 `setTimeout` 发送 AJAX 请求以检查服务器上的新数据。
   - 优点：实现简单。
   - 缺点：可能增加服务器负担，且频繁的请求可能导致不必要的资源消耗。

2. **长轮询（Long Polling）**：
   - 客户端发起一个请求，服务器在有新数据时才返回响应。如果没有数据，服务器保持连接直到数据可用或超时。
   - 优点：比常规轮询更高效，不需要频繁建立 HTTP 连接。
   - 缺点：实现复杂度高，服务器端需要支持长时间保持连接。

3. **WebSocket**：
   - 使用 WebSocket 协议建立一个持久的双向通信连接，服务器可以实时将新数据推送到客户端。
   - 优点：实时性高，服务器和客户端都能推送消息。
   - 缺点：需要服务器和客户端都支持 WebSocket，网络开销大。

4. **Server-Sent Events (SSE)**：
   - 客户端向服务器发起一个 HTTP 请求后，服务器可以单向推送事件流到客户端。
   - 优点：实现相对简单，比 WebSocket 更加适合服务器->客户端的单向消息传递。
   - 缺点：仅限单向通信，且浏览器兼容性需要考虑。

5. **Reactivity（响应式编程）**：
   - 使用框架（如 React、Vue、Angular）的响应式特性，当数据源变化时自动更新视图。
   - 结合上面的方法之一（如 WebSocket）来获取数据更新，可以实现更完善的无感刷新。
   - 优点：与现代前端框架结合紧密，简化 UI 层面的刷新逻辑。

### 实际应用中的考虑

- **性能和负载**：对于高频率的数据更新，选择 WebSocket 或长轮询可以降低服务器的压力。
- **数据一致性**：在每次更新数据时确保数据的完整性和一致性，可能需要考虑事务性或者差异化更新。
- **用户通知**：当数据更新时，可以通过视觉提示或其他形式告知用户数据已经更新。
- **断线重连机制**：不论使用哪种方法，处理潜在的网络中断并实现自动重连是非常重要的，以保证持久的用户体验。

总之，无感刷新的最终目标是在数据变化时最大化用户体验的连贯性，同时保持应用的性能和可靠性。选择合适的技术手段需要根据具体的项目需求权衡。

## http消息的结构是什么

HTTP（Hypertext Transfer Protocol）消息的结构包括两个主要部分：请求消息和响应消息。这两者各自有特定的格式和组成部分。

### HTTP 请求消息

HTTP 请求消息用于从服务器请求资源，其结构由以下部分组成：

1. **请求行**：

   - 包括 HTTP 方法（如 GET、POST、PUT、DELETE 等）、请求目标（通常是 URL 的路径部分）和 HTTP 版本。
   - 示例：`GET /index.html HTTP/1.1`

2. **请求头（Headers）**：

   - 包含客户端发送的额外信息（如用户代理、主机信息、可接受的内容类型等）。请求头是以`键: 值`对的形式存在的。

   - 示例：

     ```http
     Host: www.example.com
     User-Agent: Mozilla/5.0
     Accept: text/html
     ```

3. **空行**：

   - 请求头之后是一个空行，用于分隔请求头和请求体。

4. **请求体（Body）**（可选）：

   - 包含请求相关的实体数据，通常出现在 POST 或 PUT 请求中。例如，提交表单时发送的数据。

### HTTP 响应消息

HTTP 响应消息是服务器返回的，用来提供客户端请求的资源或反馈请求处理结果。其结构由以下部分组成：

1. **状态行**：

   - 包括 HTTP 版本、状态码（如 200、404、500 等）和状态描述。
   - 示例：`HTTP/1.1 200 OK`

2. **响应头（Headers）**：

   - 包含服务器发送的元数据或控制指令，如内容类型、内容长度、缓存控制指令等。

   - 示例：

     ```http
     Content-Type: text/html
     Content-Length: 1234
     Cache-Control: max-age=3600
     ```

3. **空行**：

   - 响应头之后是一个空行，用于分隔响应头和响应体。

4. **响应体（Body）**（可选）：

   - 包含实际的资源数据，如 HTML 文档、图像或其他文件内容。如果请求失败，响应体可能会包含错误信息或描述。

在 HTTP/2 和 HTTP/3 协议中，虽然消息的传输机制有所不同（如数据帧的引入），基本的消息结构（请求行/状态行、头、体等概念）仍然存在。因此，理解这些基本结构有助于理解更高级的 HTTP 特性。

## http1.1的情况下，一个网页的图片是一张一张加载还是一批一批加载

在 HTTP/1.1 协议的情况下，网页上的图片加载方式主要受限于协议的特性和浏览器的实现方式。

### HTTP/1.1 特性

1. **串行请求**：
   - 原始的 HTTP/1.0 每次只能在一个 TCP 连接上处理一个请求。在 HTTP/1.1 中，支持持久连接（Persistent Connections），允许在单个 TCP 连接上处理多个请求，这样可以降低连接建立的开销。

2. **并行请求限制**：
   - 虽然 HTTP/1.1 支持持久连接，但实际的图片加载依然受到并行请求数量限制。大多数浏览器针对同一域名开设的并行连接数有限（通常是 4 到 8 个并行连接，具体数量取决于浏览器的实现）。

3. **队头阻塞（Head-of-Line Blocking）**：
   - 在 HTTP/1.1 中，同一连接上请求需要依次处理，这可能导致队头阻塞，即前一个请求未完成，后续请求就要排队等待。

### 图片加载过程

在 HTTP/1.1 的环境下，浏览器根据最大并行连接数，对图片请求进行批次加载：

- **批量处理**：
  - 浏览器会根据允许的最大并行连接数，决定同时发起多个（通常是 4 到 8 个）图片请求。
  - 当首批图片加载完成，连接空闲后，会继续加载下一批图片。

- **域名分片（Domain Sharding）**：
  - 开发者有时通过将资源分布到多个子域名，来规避单个域名的连接限制（例如，把图片放在 `img1.example.com` 和 `img2.example.com`）。这在 HTTP/1.1 非常常见，但会增加 DNS 解析负担。

### 现代替代协议

为了优化图片和其他资源的加载，许多网站正在转向使用 HTTP/2 或 HTTP/3：

- **HTTP/2**：
  - 提供多路复用（Multiplexing），允许在单一连接上并行传输多个资源，避免了队头阻塞。
  - 支持服务器推送、头部压缩等功能，进一步提高加载效率。

- **HTTP/3**：
  - 基于 QUIC 协议，进一步改善性能，包括减少连接建立时间和应对网络延迟。

因此，在 HTTP/1.1 环境下，图片的加载通常是一批一批处理的，但开发者可以通过优化域名分片和图像资源的请求策略来提高加载效率。若可能，升级到支持更现代的 HTTP/2 或 HTTP/3 协议则能够显著改善资源加载性能。

## 前后端是怎么做数据交互的

前后端数据交互是 Web 开发的核心，它描述了前端（浏览器端）如何与后端（服务器端）进行通信并交换数据。以下是前后端数据交互的主要方式：

**1. HTTP 请求和响应**

   - 这是最常见、最基础的数据交互方式。
   - **原理:**
     - 前端使用 JavaScript 代码发送 HTTP 请求（例如，GET、POST、PUT、DELETE 等）。
     - 后端接收请求，处理数据，并将结果封装成 HTTP 响应返回给前端。
     - 前端解析响应数据，并更新页面或执行其他操作。
   - **常用技术:**
     - **AJAX (Asynchronous JavaScript and XML):**  使用 JavaScript 的 `XMLHttpRequest` 对象发送异步请求，常与 `fetch` API 或第三方库（如 Axios）结合使用。
     - **Fetch API:** 现代浏览器提供的用于发送网络请求的接口，更简洁易用。
     - **Axios:** 基于 Promise 的 HTTP 客户端，支持浏览器和 Node.js 环境，功能强大且易于使用。
   - **数据格式:**
     - **JSON (JavaScript Object Notation):**  最常用的数据格式，易于阅读和解析。
     - **XML (Extensible Markup Language):**  早期较为流行的数据格式，现在使用较少。

**2. WebSocket**

   - 用于建立持久的双向通信通道。
   - **原理:**
     - 前端和后端建立 WebSocket 连接，双方可以随时互相发送消息。
     - 适用于需要实时更新数据的场景，例如聊天应用、股票行情等。
   - **常用技术:**
     - **WebSocket API:** 浏览器提供的用于建立 WebSocket 连接的接口。
     - **Socket.IO:**  封装了 WebSocket，简化了实时应用开发，提供了更丰富的功能和更好的兼容性。

**3. Server-Sent Events (SSE)**

   - 用于从服务器向客户端推送数据的单向通信机制。
   - **原理:**
     - 服务器使用 SSE 接口向客户端推送数据流。
     - 客户端监听事件，并处理接收到的数据。
   - **常用场景:**
     - 服务器向客户端推送实时数据，例如新闻更新、通知提醒等。

**前后端数据交互流程示例 (使用 AJAX):**

1. **前端发送请求:**

   ```javascript
   fetch('https://api.example.com/users') // 发送 GET 请求获取用户列表
     .then(response => response.json()) // 将响应数据解析为 JSON 格式
     .then(data => {
       // 处理数据，例如更新页面
       console.log(data); 
     });
   ```

2. **后端接收请求并返回数据:**

   ```python
   # 使用 Flask 框架示例
   from flask import Flask, jsonify
   
   app = Flask(__name__)
   
   @app.route('/users')
   def get_users():
       users = [
           {'id': 1, 'name': 'Alice'},
           {'id': 2, 'name': 'Bob'}
       ]
       return jsonify(users) // 返回 JSON 格式的用户列表
   
   if __name__ == '__main__':
       app.run()
   ```

**选择合适的交互方式:**

- **简单数据获取:**  HTTP 请求和响应 (AJAX、Fetch)
- **实时双向通信:**  WebSocket (WebSocket API、Socket.IO)
- **服务器推送数据:**  Server-Sent Events (SSE)

选择合适的技术取决于具体的应用场景和需求。

## JWT, 里面是如何设计的用户凭据是在服务端还是Token

JWT（JSON Web Token）是一种用于在各方之间传递经过数字签名的声明的紧凑、URL安全的令牌格式。它通常用于认证和授权场景中，尤其在无状态的分布式系统中非常常见。实现JWT的过程中涉及了用户凭据的设计问题，这个问题主要是关于用户凭据应存储于服务端还是仅在Token中。

### JWT的结构

JWT由三部分组成：

1. **Header（头部）**：包含令牌类型和所使用的加密算法。
2. **Payload（负载）**：包含声明（即用户信息、权限等），这些声明并未加密，但可以被签名。
3. **Signature（签名）**：用于验证负载的真实性及未被篡改。

JWT样例：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### 用户凭据设计

#### 1. 将用户凭据存放在Token中

在这种设计中，用户的关键信息存储在JWT的Payload部分，如用户ID、用户名、角色等。这些信息通过JWT的签名部分加以校验，确保令牌未被篡改。

**优点**：

- **无状态**：服务器不需要存储和管理会话状态，可以水平扩展。
- **性能高**：每次请求中包含所有的验证信息，无需频繁访问数据库或缓存。

**缺点**：

- **安全性问题**：尽管签名可以防止被篡改，但不能完全防止Token被截取和重放攻击。可以适当设置较短的过期时间和使用HTTPS来增强安全。
- **Token大小问题**：包含较多信息时，JWT会变得很大，从而增加请求的大小。

**示例**：

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "roles": ["admin", "user"]
}
```

#### 2. 将用户凭据存放在服务端

在这种设计中，JWT中存储的只是最小的信息（如用户ID），所有的用户状态和权限信息依然存放在服务端数据库或缓存中。每当需要验证用户状态时，通过JWT中的用户ID查找服务端存储的详细信息。

**优点**：

- **更高安全性**：即使Token被截获，攻击者也无法获取完整的用户凭据。
- **灵活性**：可以随时更新用户信息，无需重新生成Token。

**缺点**：

- **需要服务端状态**：引入了状态，服务端需要存储和管理会话信息。
- **性能开销**：每次验证都需要查询数据库或缓存，可能带来性能瓶颈。

**示例**：

```json
{
  "sub": "1234567890",
  "exp": 1516239022
}
```

### JWT设计的最佳实践

1. **最小化Token内容**：存储尽可能少的信息在JWT中，一般情况下只存储用户ID、身份验证时间、过期时间等。
2. **使用https**：确保通信安全，防止JWT在传输过程中被截取。
3. **设置过期时间**：合理设置Token的过期时间，并实现Token刷新机制。
4. **签名算法**：使用强大的签名算法（如HS256, RS256）来保护Token。
5. **黑名单机制**：在用户登出或权限变更时，将Token列入黑名单以防止继续使用。
6. **Token刷新**：定期刷新Token，以确保Token长期有效性和安全。
7. **使用可控状态机制**：在某些敏感的场景下，通过状态机制（如部署于缓存数据库的会话信息）确保请求的安全性和一致性。

### 结论

JWT的设计是否在Token中包含用户凭据，取决于具体的业务需求和安全要求。对于密钥较注重性能和无状态特性的分布式系统，可以选择将关键信息直接放在Payload中。而对于安全性要求较高的系统，通常将敏感用户凭据存储在服务端，并通过最小权限的Token来进行身份验证和操作授权。

合理权衡性能与安全是设计JWT系统的关键，确保系统在满足性能要求的前提下保证用户数据的安全性。

## 强缓存和协商缓存应用场景

在 Web 开发中，缓存策略对提高性能和用户体验非常重要。缓存策略一般分为强缓存和协商缓存两种，各自有不同的应用场景和优劣。

### 强缓存（强制缓存）

强缓存意味着浏览器会在本地缓存中查找资源，并根据缓存时间来决定是否使用缓存，期间不与服务器沟通。强缓存主要通过 `Expires` 和 `Cache-Control` 头部来设置。

#### `Expires`

设置资源过期时间的绝对时间点，过了这个时间点，浏览器认为缓存过期，需要重新请求。如果本地时间与服务器时间不同步，可能会导致缓存策略失效。

```http
Expires: Wed, 21 Oct 2023 07:28:00 GMT
```

#### `Cache-Control`

更常用，设置相对时间且提供更精细的控制。常用选项有：

- `max-age=<seconds>`：资源在本地缓存多久（以秒为单位）。
- `public`：可以被所有的用户（包括终端用户和中间代理服务器）缓存。
- `private`：只能被终端用户的浏览器缓存，不能被中间代理服务器缓存。
- `no-cache`：资源不可直接使用，需要进行协商缓存。
- `no-store`：资源不应被缓存。

```http
Cache-Control: max-age=3600
```

#### 应用场景

- **静态资源**：如图片、CSS、JavaScript 文件等。经常使用强缓存策略，以减少对服务器的请求。
- **变化不频繁的资源**：例如，公司 logo、长期不变的静态文件。

### 协商缓存

协商缓存是指每次请求资源时，浏览器都会向服务器确认资源是否有更新。如果资源没有更新，服务器会返回 304 Not Modified 状态，浏览器会继续使用本地缓存的资源。这种缓存包括 `Last-Modified/If-Modified-Since` 和 `ETag/If-None-Match`。

#### `Last-Modified/If-Modified-Since`

- `Last-Modified`：服务器在响应头中返回资源的最后修改时间。
- `If-Modified-Since`：浏览器下一次请求时，会带上上次的 `Last-Modified` 时间，服务器对比资源的最后修改时间决定是否返回 304 状态码。

```http
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
```

#### `ETag/If-None-Match`

- `ETag`：返回资源的唯一标识符（一般是内容的哈希值）。
- `If-None-Match`：浏览器下一次请求时，会带上上次的 `ETag` 值，服务器对比资源新的 ETag 值决定是否返回 304 状态码。

```http
ETag: "6849e7b2dc3849e7b2d"
If-None-Match: "6849e7b2dc3849e7b2d"
```

#### 应用场景

- **频繁变化的资源**：如 API 响应、新闻信息等。使用协商缓存能在资源更新时及时反映变化。
- **大型文件**：如大图片、大文件。即使检查是否更新，也能节约带宽。
- **用户生成内容**：如博客文章、社交媒体平台内容。

### 综合应用

一个健全的缓存策略通常在强缓存和协商缓存之间取得平衡。以下提供一个 HTML 页面的示例，展示如何设置缓存策略：

```http
HTTP/1.1 200 OK
Date: Wed, 21 Oct 2023 07:28:00 GMT
Cache-Control: max-age=3600, public
Expires: Wed, 21 Oct 2023 08:28:00 GMT
Last-Modified: Tue, 20 Oct 2023 07:28:00 GMT
ETag: "6849e7b2dc3849e7b2d"
Content-Length: 1234
Content-Type: text/html
```

- 对于很少更新的静态文件（如公司 logo 或常用字体），你可以设置一个较长的 `max-age` 和 `Expires` 时间。
- 对于可能频繁更新但需要频繁访问的资源（如网站首页），你可以使用较短的 `max-age` 或 `no-cache`，并结合 `ETag` 或 `Last-Modified` 检查更新。

通过灵活应用强缓存和协商缓存，你可以显著提高网站的加载速度和响应性能，并减少带宽消耗，提升用户体验。

## 图片加载如何兜底

### img的onerror钩子

```html
<img width='300' src='./image1.png' onerror='this.src='./image2.png'>
```

### 方法中定义img对象在onerror回调兜底处理

```javascript
const src = ref('')
function loadImage(src){
    return new Promise((resolve, reject) => {
        const img = new Image()
        img.src = src
        img.onload = () => resolve(src)
        img.onerror = () => reject(err)
    })
}
loadImage('./image1.png')
	.then(res => {
    	src.value = res
	})
	.catch(err => {
    	src.value  = './image2.png'
	})


<img :src='src'/>
```

## 发出去的请求是否可以被取消

### 不可以

比如发请求删除1条数据, 前端取消请求后, 如果后端以及接收到了请求, 那么前端取消请求终止删除不代表后端知道取消删除数据, 所以数据还是会被删除

## 前端请求到后端的过程的网络链路是怎么样的，有什么环节

前端请求到后端的过程涉及多个网络环节，从客户端（通常是浏览器或移动应用）发出请求，到服务器处理请求并返回响应，整个过程可以概括为以下几个主要步骤：

### 1. DNS解析
- **过程**：浏览器首先检查本地DNS缓存，如果没有找到，会向DNS服务器发送请求，解析目标域名对应的IP地址。
- **作用**：将易于记忆的域名转换为机器可读的IP地址。

### 2. 建立TCP连接
- **过程**：浏览器通过IP地址找到目标服务器，并建立TCP连接。这个过程涉及到三次握手。
- **作用**：确保数据传输的可靠性。

### 3. 发送HTTP请求
- **过程**：浏览器通过TCP连接向服务器发送HTTP请求。请求包括请求方法（如GET、POST）、请求的资源路径、HTTP版本、请求头和请求体（对于POST请求）。
- **作用**：浏览器向服务器请求特定的资源。

### 4. 服务器处理请求
- **过程**：服务器接收到HTTP请求后，根据请求的资源路径和请求方法进行处理。服务器可能涉及到多个组件的协作，如负载均衡器、反向代理、应用服务器等。
- **作用**：服务器根据请求返回相应的资源或执行特定的操作。

### 5. 发送HTTP响应
- **过程**：服务器处理完请求后，生成HTTP响应，包括状态码（如200、404、500等）、响应头和响应体（如HTML页面、JSON数据等）。
- **作用**：服务器将处理结果返回给客户端。

### 6. 浏览器渲染页面
- **过程**：浏览器接收到服务器的HTTP响应后，开始解析HTML文档，构建DOM树。同时，解析CSS样式，构建渲染树，并将渲染树绘制到屏幕上。
- **作用**：将服务器返回的HTML、CSS和JavaScript等资源渲染成用户可以交互的页面。

### 7. 关闭TCP连接
- **过程**：在HTTP/1.1中，默认使用持久连接（Connection: keep-alive），浏览器和服务器可以复用TCP连接进行多次请求和响应。在HTTP/2中，连接更加高效，可以支持多路复用。
- **作用**：释放服务器资源，避免不必要的连接占用。

### 8. 缓存处理
- **过程**：浏览器会根据HTTP响应头中的缓存指令，决定是否缓存资源。如果缓存命中，浏览器可以直接从本地缓存中读取资源，而不需要再次请求服务器。
- **作用**：减少网络请求，提高页面加载速度。

### 9. 重定向处理
- **过程**：如果服务器返回的状态码是301或302，浏览器会根据响应头中的`Location`字段进行重定向，重新发起请求到新的URL。
- **作用**：确保用户访问的是正确的资源。

### 10. 安全机制
- **过程**：在请求和响应过程中，会涉及到多种安全机制，如HTTPS加密、证书验证、跨站请求伪造（CSRF）防护等。
- **作用**：保护数据传输的安全性和用户隐私。

整个过程中，网络链路可能涉及多个中间节点，如DNS服务器、负载均衡器、反向代理等。这些中间节点的作用主要是优化网络性能、提高安全性、实现负载均衡等。

## 如果这个地址是Https的，如何验证对方不是一个伪造的网站

要验证一个HTTPS网站是否真实可信，主要依赖于SSL/TLS证书机制。浏览器和其他客户端软件使用证书来确认服务器的身份，并确保加密通信的安全性。以下是验证网站真实性的关键步骤：

1. **证书颁发机构（CA）验证**：
   证书由受信任的CA颁发，CA会对申请证书的实体进行身份验证。浏览器和操作系统内置了受信任的CA列表，用于验证网站提供的证书是否由这些CA签发。

2. **证书有效性检查**：
   浏览器会检查证书是否在有效期内，以及证书中的域名是否与请求的域名匹配。

3. **证书吊销检查**：
   浏览器还会检查证书是否被吊销。这可以通过证书吊销列表（CRL）或在线证书状态协议（OCSP）来完成。

4. **证书链验证**：
   证书链从服务器证书一直到根证书，浏览器会验证整个证书链的每个环节是否有效和可信。

5. **证书透明度**：
   证书透明度（CT）是一个提高TLS/SSL证书安全性的系统，它要求CA公开他们颁发的证书，以便任何人都可以审计和监控证书。这有助于防止和及时发现伪造或恶意证书。

6. **使用在线工具进行验证**：
   可以使用在线工具如MySSL、CSR Checker或SSL Check来检测SSL证书是否已正确安装并受到浏览器的信任。

7. **手动验证**：
   用户可以通过浏览器查看证书详情，手动检查证书信息，包括颁发机构、有效期、公钥等。

通过这些步骤，用户和客户端软件可以验证HTTPS网站的真实性，确保数据的安全传输，并避免中间人攻击。
