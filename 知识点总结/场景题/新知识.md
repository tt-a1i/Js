## 常见的排序算法

当然，可以为你总结一些常见的排序算法，包括其特点、原理、时间复杂度和空间复杂度。

### 1. 冒泡排序 (Bubble Sort)
- **原理**：重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就交换它们。走访数列的工作是重复地进行直到不再需要交换，即数列已经排序。
- **特点**：简单易懂，但效率低。
- **时间复杂度**：
  - 最好情况：\(O(n)\) （已排序）
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)
- **空间复杂度**：\(O(1)\) （原地排序）

### 2. 选择排序 (Selection Sort)
- **原理**：首先在未排序序列中找到最小（或最大）元素，然后将其放到已排序序列的末尾。将该过程不断重复。
- **特点**：简单易于实现，但效率较低。
- **时间复杂度**：\(O(n^2)\) （无论什么情况）
- **空间复杂度**：\(O(1)\) （原地排序）

### 3. 插入排序 (Insertion Sort)
- **原理**：构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- **特点**：对于小规模数据效率高，且是稳定排序。
- **时间复杂度**：
  - 最好情况：\(O(n)\) （已排序）
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)
- **空间复杂度**：\(O(1)\) （原地排序）

### 4. 归并排序 (Merge Sort)
- **原理**：基于分治法，将数组分成两个子数组进行排序，然后将两个已排序的子数组合并成一个。
- **特点**：稳定排序，适合大数据量排序。
- **时间复杂度**：\(O(n \log n)\) （所有情况）
- **空间复杂度**：\(O(n)\) （需额外空间）

### 5. 快速排序 (Quick Sort)
- **原理**：选择一个基准元素，重新排序数列，所有小于基准值的元素放在基准前面，所有大于基准值的元素放在基准后面。
- **特点**：性能好，是一种不稳定排序。
- **时间复杂度**：
  - 最好情况：\(O(n \log n)\)
  - 平均情况：\(O(n \log n)\)
  - 最坏情况：\(O(n^2)\) （已有序列或每次选的基准值导致均分不均）
- **空间复杂度**：\(O(\log n)\) （递归栈空间）

### 6. 希尔排序 (Shell Sort)
- **原理**：通过将比较的全部元素分为几个区域来提升插入排序的性能。随后逐渐减少区域间的间隔。
- **特点**：是一种不稳定的排序，通常快于简单插入排序和冒泡排序。
- **时间复杂度**：依赖于步长序列，通常为 \(O(n^{1.3})\) 到 \(O(n^2)\)
- **空间复杂度**：\(O(1)\)

### 7. 堆排序 (Heap Sort)
- **原理**：将数组构建成一个最大堆，取出堆顶元素，将其放到数组的末尾，将剩余元素重新构建成最大堆，重复直至所有元素有序。
- **特点**：是一个不稳定排序，排序性能不受数据分布影响。
- **时间复杂度**：\(O(n \log n)\) （所有情况）
- **空间复杂度**：\(O(1)\) （原地排序）

这些排序算法各有其应用场景和适用条件，选择合适的算法可以有效提高排序效率。



## 千分位

如果不用正则表达式实现千分位格式化，可以使用字符串操作和数组方法来手动实现。这种实现方法虽然比正则表达式稍复杂，但也是有效的。以下是一个不使用正则表达式的实现：

### 方法：自定义实现千分位格式

```javascript
function toThousands(num) {
    if (typeof num !== 'number') {
        num = parseFloat(num);
    }
    if (isNaN(num)) {
        return '';
    }

    let [integerPart, decimalPart] = num.toString().split('.');

    let digits = integerPart.split('');
    let resultArray = [];

    for (let i = 0; i < digits.length; i++) {
        let position = digits.length - i;

        resultArray.push(digits[i]);

        if (position > 1 && position % 3 === 1) {
            resultArray.push(',');
        }
    }

    let formattedNumber = resultArray.join('');

    return decimalPart ? `${formattedNumber}.${decimalPart}` : formattedNumber;
}

// 示例
console.log(toThousands(1234567)); // 输出 "1,234,567"
console.log(toThousands(1234.567)); // 输出 "1,234.567"
console.log(toThousands('abc')); // 输出 ""
console.log(toThousands('1234567')); // 输出 "1,234,567"
```

### 解释

1. **检测并转换输入**：首先，确保输入是一个数字，如果不是则尽量将其转换为数字。如果仍然无效则返回空字符串。

2. **分离整数和小数部分**：将数字转换为字符串后，使用 `split` 方法分离整数和小数部分。

3. **处理整数部分**：
    - 将整数部分逐位拆分成数组形式。
    - 逐位处理整数部分数组中的元素，并根据其在数字中的位置插入逗号。

4. **拼接结果**：将处理后的整数部分数组转换回字符串，并拼接小数部分，形成最终格式化结果。

这样，通过手动处理字符串和数组，不使用正则表达式，也可以实现数字的千分位格式化。这种方法可以灵活处理不同类型的输入，并确保结果符合预期。









## publicPath的意义

`publicPath` 是一个常见的概念，特别是在前端构建工具和模块打包工具（如 Webpack、Vite 等）中。它的设置和意义有助于正确配置应用程序中静态资源（如 JavaScript、CSS、图片等）的路径，确保这些资源在各种环境（开发、生产等）下都能被正确加载。以下是 `publicPath` 的详细解释。

### 什么是 `publicPath`？

`publicPath` 定义了应用程序中的静态资源在构建和运行时所访问的基础路径。它通常被用来设置加载打包生成文件的 URL 前缀。

### 为什么需要 `publicPath`？

当你的应用需要通过不同的 URL 路径访问静态资源时，`publicPath` 可以帮助你灵活地处理这种需要。具体来说：

1. **统一路径管理**：通过 `publicPath` 可以统一管理所有静态资源的路径前缀，避免在多个文件中手动设置路径前缀。

2. **跨环境适用**：在开发、测试和生产环境中，静态资源的路径可能会有所不同，使用 `publicPath` 可以根据环境动态设置路径，确保资源在任何环境都可以被正确加载。

3. **内容分发网络（CDN）**：当你使用 CDN 来分发静态资源时，你可以通过设置 `publicPath` 将资源路径指向 CDN 域名，从而加快资源加载速度。

### 如何使用 `publicPath`？

以下是一些在不同工具中配置和使用 `publicPath` 的示例。

#### Webpack

在 Webpack 中，`publicPath` 可以在 `output` 中进行配置，通常在 `webpack.config.js` 文件中进行设置。

```javascript
const path = require('path');

module.exports = {
  // 其他配置省略
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js',
    publicPath: '/assets/' // 这里配置 publicPath
  }
};
```

这样，生成的文件路径将会是 `/assets/` 作基础路径，比如 `/assets/main.bundle.js`。

你也可以在运行时动态配置 `publicPath`：

```javascript
__webpack_public_path__ = process.env.PUBLIC_URL || '/';
```

#### Vite

在 Vite 中，`base` 配置项类似于 `publicPath`，可以在 `vite.config.js` 文件中进行设置。

```javascript
export default {
  base: '/assets/', // 配置 publicPath 相当于 Vite 的 base 选项
};
```

#### Vue CLI

如果你使用的是 Vue CLI，它提供了一个简单的配置选项来设置 `publicPath`，即 `vue.config.js` 文件中的 `publicPath`。

```javascript
module.exports = {
  publicPath: process.env.NODE_ENV === 'production' ? '/production-sub-path/' : '/'
};
```

### 示例和应用场景

#### 本地开发

在本地开发环境中，你可能希望静态资源直接从根目录加载：

```javascript
module.exports = {
  // For development
  publicPath: '/'
};
```

#### 生产环境

在生产环境中，你可能希望静态资源通过 CDN 加载：

```javascript
module.exports = {
  // For production
  publicPath: 'https://cdn.example.com/assets/'
};
```

#### 动态设置

有时你需要根据不同环境动态设置 `publicPath`，这可以通过环境变量或配置文件实现：

```javascript
module.exports = {
  publicPath: process.env.NODE_ENV === 'production' ? 'https://cdn.example.com/assets/' : '/'
};
```

### 总结

`publicPath` 是一个用于配置静态资源路径的非常重要的设置，它使得前端资源管理更加灵活和高效。通过合理配置 `publicPath`，你可以确保你的应用在不同环境下都能正确加载静态资源，并且可以轻松实现资源的托管和分发（比如使用 CDN）。无论是开发环境还是生产环境，使用 `publicPath` 都可以帮助你更好地管理和优化前端资源。











1. 

## for in 和 for of 的区别

`for...in` 和 `for...of` 是两种在 JavaScript 中用于迭代的语法结构，它们有不同的用途和行为。

### `for...in`

`for...in` 迭代的是对象的可枚举属性，包括继承的属性。它适用于遍历对象的键（属性名）。

#### 使用示例：

```javascript
const obj = {
  a: 1,
  b: 2,
  c: 3
};

for (let key in obj) {
  console.log(key, obj[key]);
}
```

#### 输出：
```
a 1
b 2
c 3
```

#### 特点：

1. **迭代对象的可枚举属性**：包括对象自身的和从原型链继承的属性。
2. **不适用于数组**，尤其是当数组有非数值的可枚举属性时。

### `for...of`

`for...of` 迭代的是可迭代对象（如数组、字符串、`Map`、`Set`、`arguments` 对象等），并直接获取每次迭代的值。

#### 使用示例：

```javascript
const arr = [1, 2, 3];

for (let value of arr) {
  console.log(value);
}
```

#### 输出：
```
1
2
3
```

#### 特点：

1. **迭代可迭代对象**：如数组、字符串、`Map`、`Set` 等。
2. **适用于数组**：直接访问数组元素的值。
3. **不能用于普通对象**，因为对象不是可迭代的。

### 比较

- **for...in**：
  - 用于遍历对象的属性（包括继承的）。
  - 遍历对象的键名（属性名）。
  - 适合用于对象，而不推荐用于遍历数组，因为可能会遍历到数组的非数值属性和继承的属性。

- **for...of**：
  - 用于遍历可迭代对象的元素。
  - 直接获取每次迭代的值。
  - 推荐用于数组、集合、字符串等其他可迭代对象，而不是普通对象。

### 具体的示例对比

下面的例子展示了 `for...in` 和 `for...of` 的不同用法和适用场景：

```javascript
// Example for for...in
const person = {
  name: 'John',
  age: 30
};

for (let key in person) {
  console.log(key);    // 输出属性名：name, age
  console.log(person[key]); // 输出属性值：John, 30
}

// Example for for...of
const numbers = [10, 20, 30];

for (let num of numbers) {
  console.log(num); // 输出元素值：10, 20, 30
}
```

如果尝试对一个对象使用 `for...of`，将会报错：

```javascript
const person = {
  name: 'John',
  age: 30
};

for (let value of person) {
  console.log(value); 
}

// TypeError: person is not iterable
```

而如果对一个数组使用 `for...in`，会遍历索引：

```javascript
const arr = [10, 20, 30];

for (let index in arr) {
  console.log(index);    // 输出索引：0, 1, 2
  console.log(arr[index]); // 输出值：10, 20, 30
}
```

总结：`for...in` 用于遍历对象的属性名，而 `for...of` 用于遍历可迭代对象的元素值。根据具体场景选择合适的迭代方式可以编写出更清晰、有效的代码。





## 除了array.isarray 还可以怎么判断数组

除了使用 `Array.isArray()` 方法，可以使用以下几种方式来判断一个值是否为数组：

### 1. **`instanceof` 操作符**

使用 `instanceof` 检查一个对象是否是 `Array` 的实例。

```javascript
let arr = [1, 2, 3];
console.log(arr instanceof Array); // true
```

注意：`instanceof` 检查对于不同的 JavaScript 环境（如浏览器和 Node.js）可能会失败，因为跨帧或跨窗口的 Array 会导致实例关系失效。

### 2. **`Object.prototype.toString` 方法**

通过调用 `Object.prototype.toString` 获取对象类型信息。

```javascript
let arr = [1, 2, 3];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
```

这个方法对于几乎所有类型检测都适用，且可以避免 `instanceof` 的环境问题。

### 3. **`constructor` 属性**

检查对象的 `constructor` 属性是否指向 `Array`。

```javascript
let arr = [1, 2, 3];
console.log(arr.constructor === Array); // true
```

需要注意的是，直接修改对象的 `constructor` 属性可能影响这种方式的准确性，因此在一些特殊情况下不太可靠。

### 4. **ES6 的 Proxy**

虽然不是直接用于判断数组的方法，但通过 Proxy 可以实现自定义检测逻辑。

```javascript
let handler = {
    get(target, property, receiver) {
        if (property === 'isArray') {
            return true;
        }
        return Reflect.get(target, property, receiver);
    }
};

let arr = new Proxy([], handler);
console.log(arr.isArray); // true
```

这种方式更多地用于增强现有对象而不是简单类型检测。

### 结论

上述方法各有优缺点。
- `Array.isArray()` 是最推荐的，因为它是专门为此目的设计的现代方法。
- `instanceof` 在普通情况下有效，但在不同全局环境下可能失败。
- `Object.prototype.toString.call()` 是非常可靠的，通过揭示对象的基本类型信息来判断类型。
- 使用 `constructor` 则需要谨慎使用，因为可能会被篡改。

在选择方法时，应考虑应用场景和执行环境，以选择最合适的检测方式。







## 关于函数作用域和全区作用域var声明变量的提升问题

```javascript
var a = 100;
function fn() {
alert(a);
var a = 200;
alert(a);
}
fn();
alert(a);
var a;
alert(a);
var a = 300;
alert(a);
```

var声明的变量，声明会提升，赋值（初始化）不会提升

如果重复声明，且没有赋值，如果之前有赋值，值就是之前的赋值

## 对象中的this输出题

```javascript
var obj1 = {
	name: "obj1",
	fn: function () {
		console.log(this.name);
	},
};
var obj2 = { name: "obj2" };
var obj3 = { name: "obj3" };
obj1.fn();
var newFn = obj1.fn;
newFn();
newFn.call(obj2);
obj3.fn = newFn;
obj3.fn();

```

## babel和ast抽象语法树

Babel 是一个广泛使用的 JavaScript 编译器，它的主要功能是将现代 JavaScript 代码转换为兼容性更好的旧版本 JavaScript 代码。Babel 可以处理包括 ES6、ES7 以及更高版本的 JavaScript 特性，使得开发者可以使用最新标准的 JavaScript 编写代码，而不必担心在旧环境下的兼容性问题。

### 什么是 Babel？

Babel 是一个工具链，它的主要组成部分包括：

1. **Babel 核心 (`@babel/core`)**：负责解析和转换代码。
2. **Babel 插件**：转换代码的功能插件。
3. **Babel 预设 (`@babel/preset-env`)**：一组常用的 Babel 插件，用于特定环境的转换。
4. **Babel CLI (`@babel/cli`)**：命令行工具，用于运行 Babel 转换。

#### 工作原理

Babel 的工作原理可以分为三个步骤：

1. **解析（Parsing）**：将源代码解析为抽象语法树 (AST)。
2. **转换（Transforming）**：对 AST 进行变换。
3. **生成（Generation）**：将变换后的 AST 转回代码。

### 什么是 AST（抽象语法树）？

抽象语法树（Abstract Syntax Tree, AST）是表示源代码结构的一种抽象数据结构。每个节点表示源代码中的一种构造。AST 的使用不仅限于 Babel，还广泛应用于编译器、解释器和代码分析工具中。

#### 具体作用

- **代码解析**：将代码解析为语法树，使得代码的结构和内容更容易分析和操作。
- **语法检查**：确定代码的语法是否正确。
- **代码转换**：例如，ES6 的箭头函数转换为 ES5 的普通函数。
- **代码生成**：将 AST 转换回代码。

### Babel 与 AST 的关系

Babel 是基于 AST 的编译器。它通过 AST 来实现对源代码的各种转换，可以让你用最新的 JavaScript 特性编写代码，Babel 会负责将这些代码转换为兼容更广泛环境的代码。

### AST 的结构

AST 由节点组成，每个节点对应一种 JavaScript 结构。常见节点包括：

- **Program**：表示整个代码程序。
- **FunctionDeclaration**：函数声明。
- **VariableDeclaration**：变量声明。
- **ExpressionStatement**：表示一个表达式语句。

### Babel 插件与 AST 转换

Babel 通过插件来实现 AST 转换。一个 Babel 插件基本函数结构如下：

```javascript
module.exports = function(babel) {
  return {
    visitor: {
      Identifier(path) {
        // 对 AST 特定类型的节点进行转换
      }
    }
  };
};
```

下面是一个示例，用于将所有的变量名从 "let" 转换为 "var"：

```javascript
module.exports = function(babel) {
  const { types: t } = babel;

  return {
    visitor: {
      VariableDeclaration(path) {
        if (path.node.kind === "let") {
          path.node.kind = "var";
        }
      }
    }
  };
};
```

在这个示例中，我们访问 AST 中的 `VariableDeclaration` 节点，并检查节点类型 `kind` 是否为 "let"，如果是，就将其改为 "var"。

### Babel 使用示例

1. **安装 Babel CLI 和预设**

```bash
npm install --save-dev @babel/core @babel/cli @babel/preset-env
```

2. **配置 Babel** (`.babelrc` 或 `babel.config.json`)

```json
{
  "presets": ["@babel/preset-env"]
}
```

3. **转换代码**

假设你有如下代码文件 `script.js`：

```javascript
const sayHello = () => {
  console.log("Hello, world!");
};
```

你可以用 Babel 转换它：

```bash
npx babel script.js --out-file script-compiled.js
```

转换后的 `script-compiled.js` 可能类似这样：

```javascript
"use strict";

var sayHello = function sayHello() {
  console.log("Hello, world!");
};
```

### 深入理解 AST

为了更好地理解 AST，可以借助一些工具。例如，`astexplorer.net` 是一个非常有用的在线工具，能将 JavaScript 代码解析成 AST。

一个简单的 JavaScript 示例：

```javascript
const x = 1 + 2;
```

在 AST 中表示为：

```json
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "x"
          },
          "init": {
            "type": "BinaryExpression",
            "operator": "+",
            "left": {
              "type": "Literal",
              "value": 1,
              "raw": "1"
            },
            "right": {
              "type": "Literal",
              "value": 2,
              "raw": "2"
            }
          }
        }
      ],
      "kind": "const"
    }
  ],
  "sourceType": "module"
}
```

### 总结

- **Babel** 是一个 JavaScript 编译器，用于将现代 JavaScript 代码转换成具有更好兼容性的旧版本代码。
- Babel 的核心是基于 **AST（抽象语法树）** 实现代码转换的。
- **AST** 是一种抽象数据结构，用于表示源代码中的语法结构。
- **Babel 插件** 通过操作 AST 来实现代码转换。
- 使用 Babel，可以编写并使用最新标准的 JavaScript，而不必担心支持问题。

希望通过这些解释和示例，你能更好地理解 Babel 和 AST 之间的关系，以及如何使用它们来进行代码转换。

## 从字符串到ast转换的过程

将字符串代码转换为抽象语法树（AST）是编译器和代码分析工具的基本步骤之一。在这一步中，解析器（parser）将源代码转换为结构化的树形数据结构（即 AST），这些结构可以更方便地进行分析和转换。以下是详细的步骤说明：

### 转换过程概述

1. **词法分析（Lexical Analysis）**
2. **语法分析（Syntax Analysis）**
3. **AST 生成（AST Generation）**

### 具体步骤

1. **词法分析（Lexical Analysis）**

词法分析的目的是将源代码拆分成更小的词法单元（tokens）。每个 token 是源代码中的一个原子结构。这一步骤由词法分析器（Lexer）完成。

举个例子，对于如下代码：

```javascript
const x = 5 + 3;
```

词法分析器会生成如下的 tokens：

- `const`（关键字）
- `x`（标识符）
- `=`（赋值操作符）
- `5`（数字字面量）
- `+`（加法操作符）
- `3`（数字字面量）
- `;`（分号）

这是编译器理解代码的第一步，将代码分解为最小语法单元。

2. **语法分析（Syntax Analysis）**

语法分析的目的是将 tokens 重新组合成具有层次结构的抽象语法树（AST），代表程序的结构和逻辑。这一步骤由解析器（Parser）完成。

基于上述的 tokens，解析器会生成如下的 AST：

```json
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "x"
          },
          "init": {
            "type": "BinaryExpression",
            "operator": "+",
            "left": {
              "type": "Literal",
              "value": 5
            },
            "right": {
              "type": "Literal",
              "value": 3
            }
          }
        }
      ],
      "kind": "const"
    }
  ]
}
```

3. **AST 生成（AST Generation）**

在语法分析的过程中，解析器会构建出完整的 AST，表示代码的层次结构。在接下来的编译或代码转换中，这一结构将被反复操作和分析。

### Babel 的具体实现

Babel 是一个流行的 JavaScript 编译器，它也遵循上述的步骤，通过词法分析和语法分析生成 AST。我们可以通过使用 Babel 提供的 API，将 JavaScript 代码字符串转换为 AST。

以下是使用 Babel 的示例：

#### 安装 Babel 相关模块

```bash
npm install @babel/parser @babel/traverse @babel/types
```

#### 使用示例

```javascript
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const t = require('@babel/types');

const code = 'const x = 5 + 3;';

// Step 1: Parse the source code into an AST
const ast = parser.parse(code);

console.log(JSON.stringify(ast, null, 2));

// Step 2: Traverse the AST and manipulate nodes if needed
traverse(ast, {
  enter(path) {
    if (t.isIdentifier(path.node, { name: 'x' })) {
      path.node.name = 'y'; // Rename variable x to y
    }
  }
});

// Step 3: Generate new code from the modified AST (if needed)
// Note: This step requires babel-generator, normally used within Babel plugins

const generator = require('@babel/generator').default;
const result = generator(ast, /* options */ {}, code);

console.log(result.code); // Output modified code
```

### 过程详解

1. **词法分析和语法分析**

   `parser.parse` 函数将代码字符串解析成 AST：

   ```javascript
   const ast = parser.parse(code);
   ```

2. **AST 遍历和操作**

   使用 `@babel/traverse` 遍历和操作 AST 节点：

   ```javascript
   traverse(ast, {
     enter(path) {
       if (t.isIdentifier(path.node, { name: 'x' })) {
         path.node.name = 'y'; // Rename variable x to y
       }
     }
   });
   ```

3. **生成新代码**

   使用 `@babel/generator` 从 AST 生成新的代码：

   ```javascript
   const generator = require('@babel/generator').default;
   const result = generator(ast, /* options */ {}, code);
   console.log(result.code);
   ```

### 小结

以上就是将源代码字符串转换为 AST，并对 AST 进行操作的详细过程。Babel 和其他编译器、代码转换工具借助 AST 可以实现复杂的代码分析和转换。这种把源码拆解成树形结构再进行操作的方法，是编译器、代码静态分析、优化、格式化工具的重要基础。

## vue模板解析器的解析过程

Vue.js 是一个用于构建用户界面的 JavaScript 框架。在其内核中，Vue 模板解析器负责将模板转换为渲染函数，这些函数在运行时生成实际的 DOM 结构。Vue 模板解析器的解析过程相当复杂，通常包含以下几个阶段：

1. **模板解析（Parsing）**：将模板字符串解析为抽象语法树（AST）。
2. **AST 转换（Transformation）**：对 AST 进行必要的变换和优化。
3. **代码生成（Code Generation）**：将转化后的 AST 转换为渲染函数。

下面详细描述每个阶段：

### 1. 模板解析（Parsing）

在这个阶段，Vue 模板解析器将模板字符串转换为 AST。AST 是模板的结构化表示，它更容易进行后续操作和转换。

#### 示例模板：

```html
<div id="app">
  <p>{{ message }}</p>
</div>
```

对应的 AST 结构可能如下所示：

```json
{
  "type": "Root",
  "children": [
    {
      "type": "Element",
      "tag": "div",
      "props": [
        {
          "type": "Attribute",
          "name": "id",
          "value": "app"
        }
      ],
      "children": [
        {
          "type": "Element",
          "tag": "p",
          "children": [
            {
              "type": "Interpolation",
              "content": {
                "type": "Expression",
                "content": "message"
              }
            }
          ]
        }
      ]
    }
  ]
}
```

这个过程通常由解析器完成，解析器会进行词法分析（Lexical Analysis）和语法分析（Syntax Analysis），将模板字符串解析为 AST。

举例来说，对于 Vue 模板解析器，解析阶段是由函数 `parse` 实现的。

### 2. AST 转换（Transformation）

在 AST 转换阶段，对生成的 AST 进行一些必要的转换和优化。这包括对指令（如 `v-if`、`v-for`）、事件绑定、双向数据绑定（如 `v-model`）等元素的处理。

#### 转换示例：

- 处理模板指令，如 `v-if`、`v-for`。
- 绑定事件，例如 `@click`。
- 处理传递属性和类名绑定。

Vue 模板解析器会使用一些转换插件来实现这个过程。例如，处理 `v-for` 的转换器会将：

```html
<li v-for="item in items">{{ item.name }}</li>
```

转换为：

```json
{
  "type": "Element",
  "tag": "li",
  "props": [],
  "children": [
    {
      "type": "Interpolation",
      "content": {
        "type": "Expression",
        "content": "item.name"
      }
    }
  ],
  "directives": [
    {
      "name": "for",
      "exp": "item in items"
    }
  ]
}
```

### 3. 代码生成（Code Generation）

在代码生成阶段，Vue 模板解析器会将优化过的 AST 转换为渲染函数（render function）。渲染函数是 JavaScript 函数，负责在运行时生成虚拟 DOM（Virtual DOM）。

#### 渲染函数示例：

基于上面的 AST，生成的渲染函数类似如下：

```javascript
function render() {
  return h('div', { id: 'app' }, [
    h('p', null, [ this.message ])
  ]);
}
```

这个函数使用了虚拟 DOM 库（如 Vue 的 `h` 函数）来创建虚拟 DOM 节点。

### 具体实现代码

让我们一行行地看一个简化版实现：

1. **模板解析**

```javascript
const { parse } = require('@vue/compiler-dom');

const template = `<div id="app"><p>{{ message }}</p></div>`;
const ast = parse(template);
console.log(JSON.stringify(ast, null, 2));
```

`parse` 函数将模板字符串解析为 AST。

2. **AST 转换**

虽然 Vue 内部有一系列的转换插件，但这里我们略过实现，只展示如何应用转换插件的机制。

3. **代码生成**

```javascript
const { compile } = require('@vue/compiler-dom');

const { code } = compile(template);
console.log(code);
```

`compile` 函数执行解析和转换，并生成渲染函数的代码。

### 完整的简化流程

集成这些步骤，实现一个完整的简化版流程：

```javascript
const { compile } = require('@vue/compiler-dom');

const template = `<div id="app"><p>{{ message }}</p></div>`;
const { code } = compile(template);

console.log('Generated Render Function Code:');
console.log(code);

/*
  Expected Output:
  function render() {
    return _ctx._c('div', { id: 'app' },
      [_ctx._c('p', [_ctx._v(_ctx._s(_ctx.message))])]
    );
  }
*/
```

### 实际使用中的细节

- **指令处理**：如 `v-if`、`v-for`、`v-bind` 等需要特殊处理。
- **编译缓存**：为了提高性能，Vue 会缓存编译结果。
- **SSR（服务器端渲染）**：生成的渲染函数可能会有不同的优化，以适应服务器端渲染。

### 总结

Vue 的模板解析器从模板字符串到 AST，再从 AST 到渲染函数，经历了三个核心步骤：

1. **模板解析**：将模板字符串解析为 AST。
2. **AST 转换**：对 AST 进行必要的转换和优化。
3. **代码生成**：将优化后的 AST 转换为渲染函数。

这样的设计使得模板编译器在保持高效性的同时，具有很好的扩展性和灵活性。

## vue对ast做了哪些优化

在 Vue 的模板编译过程中，对抽象语法树 (AST) 进行了一系列的优化。这些优化是为了提高渲染性能，包括减少虚拟 DOM 的创建频率、动态节点的追踪、静态节点的标记等。下面是 Vue 对 AST 进行的一些关键优化：

### 1. 静态节点标记（Static Node Marking）

静态节点是那些在每次渲染时不需要改变的节点。Vue 通过标记这些节点，使得它们在后续的渲染中可以被跳过，从而提升性能。

1. **标记静态节点**：在第一次编译过程中，Vue 会遍历 AST 节点，并标记所有的静态节点。
2. **标记静态根节点**：Vue 会进一步标记静态根节点，这些节点作为静态子树的根节点。

#### 示例

如果模板如下：

```html
<div>
  <p class="static">Static Text</p>
  <p :class="dynamicClass">Dynamic Text</p>
</div>
```

经过静态节点标记，AST 上的第一个 `<p>` 节点会被标记为静态节点，因为它的内容和属性都是静态的。第二个 `<p>` 节点不会被标记为静态，因为它依赖于动态属性 `dynamicClass`。

### 2. 静态根提升（Hoisting Static Roots）

为了减少渲染时静态节点的创建频率，编译器会尝试将整个静态子树提升到渲染函数外部。这使得在每次重新渲染时，不需要重复创建这些静态节点。

#### 示例

将静态子树提升的过程可以用下面的伪代码表示：

```javascript
// 假设静态子树被提升为 const 变量
const staticNode = /* 静态子树 AST */;

render() {
  return h('div', [
    staticNode,  // 直接使用提升的静态节点
    h('p', { class: this.dynamicClass }, 'Dynamic Text')
  ]);
}
```

### 3. 动态节点追踪（Tracking Dynamic Nodes）

在标记静态节点之后，Vue 会知道哪些节点是动态的，在每次渲染时需要更新。在渲染函数中，这些动态节点会被追踪，以便在数据变化时可以有效地更新它们。

#### 示例

在生成渲染函数时，Vue 会生成以下代码来追踪动态节点：

```javascript
render() {
  return h('div', [
    _ctx._v('Static Text'),
    h('p', { class: _ctx.dynamicClass }, 'Dynamic Text')
  ]);
}
```

在这个例子中，Vue 清楚地知道第二个 `<p>` 节点是动态的，并需要在每次渲染时根据 `dynamicClass` 的值进行更新。

### 4. v-once 指令优化

对于使用了 `v-once` 指令的枝条，Vue 只会渲染一次，并缓存它的结果。之后的渲染将直接使用这个缓存值。

#### 示例

```html
<p v-once>This will not change</p>
```

经过编译后：

```javascript
const onceNode = /* 缓存节点 */;

render() {
  return onceNode;
}
```

### 5. Slot 优化

在 Vue 3 中，为了优化插槽 (slots) 的性能，Vue 使用了动态的插槽生成方式，同时确保在父组件更新时，子组件的插槽内容能够高效地更新。

#### 示例

假设一个组件使用了插槽：

```html
<ChildComponent>
  <template #slotName>
    <p>Static Content</p>
  </template>
</ChildComponent>
```

经过编译后，Vue 会生成高效的插槽更新逻辑：

```javascript
render() {
  return _ctx.$slots.slotName ? _ctx.$slots.slotName() : null;
}
```

### 6. 编译缓存

当一个模板被编译成渲染函数后，Vue 会缓存编译结果。这样相同的模板字符串在多次使用时，编译过程只需进行一次，大幅度提升了性能。

### 7. 代码生成优化

在生成的渲染函数中，Vue 尽量减少创建临时变量和冗余的代码，生成高度优化的 JavaScript 代码，以确保在运行过程中具有最佳的执行效率。

### 8. 片段（Fragment）优化

Vue 3 引入了片段（Fragments）支持，这使得一个组件可以有多个根节点。对于片段，Vue 会优化其创建和更新逻辑，确保多根节点在渲染时具有最小的开销。

### 结论

Vue 对 AST 的优化不仅限于标记静态节点，还包括提升静态根、动态节点追踪、插槽优化、编译缓存等多方面的优化。这些优化相辅相成，使得 Vue 在运行时具有高效的渲染性能。在实际使用中，这些优化在无感知的情况下提升了应用的性能，提供了流畅的用户体验。

## 前端性能优化指标、工具

在前端开发中，性能优化是至关重要的一环。良好的性能不仅能提供优质的用户体验，还能提高网站的搜索引擎排名。以下是一些常见的性能优化指标和工具，可以帮助开发者评估和优化前端性能。

### 性能优化指标

以下是关键的性能优化指标（KPIs），这些指标有助于量化和评估网页的性能：

1. **页面加载时间（Page Load Time）**:
   - **指标**：从请求网页到完全加载完成所花费的时间。
   - **改进方法**：减少 HTTP 请求、使用内容分发网络（CDN）、压缩和最小化资源。

2. **首屏时间/首次内容绘制（First Paint, First Contentful Paint, FCP）**:
   - **指标**：浏览器首次将内容绘制在屏幕上的时间。
   - **改进方法**：内联关键 CSS、减少 JavaScript 阻塞渲染的时间。

3. **时间互动（Time to Interactive, TTI）**:
   - **指标**：浏览器渲染出可交互的页面所需的时间。
   - **改进方法**：优化 JavaScript 加载顺序和减少复杂计算。

4. **首次输入延迟（First Input Delay, FID）**:
   - **指标**：用户第一次交互（点击、输入等）到页面响应之间的延迟时间。
   - **改进方法**：减少主线程的阻塞时间、优化长任务。

5. **最大内容绘制时间（Largest Contentful Paint, LCP）**:
   - **指标**：最大可见内容元素在屏幕上渲染所需的时间。
   - **改进方法**：优化服务器响应时间、用预加载关键资源。

6. **累积布局偏移（Cumulative Layout Shift, CLS）**:
   - **指标**：网页加载过程中可见元素的布局偏移量。
   - **改进方法**：为所有媒体元素预留空间、避免动态内容的插入。

7. **DOM 处理时间**
   - **指标**：浏览器构建和处理 DOM 树所需的时间。
   - **改进方法**：优化和精简 HTML 结构、减少 DOM 元素的数量。

### 性能优化工具

有各种工具可以帮助开发者评估和优化前端性能：

1. **Google Lighthouse**:
   - **描述**：一个开源的自动化工具，用于改进网页质量。可以在 Chrome DevTools 中使用。
   - **功能**：提供性能、可访问性、最佳实践、SEO 和 Progressive Web App (PWA) 报告。
   - **网址**：[Lighthouse](https://developers.google.com/web/tools/lighthouse)

2. **WebPageTest**:
   - **描述**：提供详细的网页性能测试，支持不同的地点和浏览器。
   - **功能**：支持视频记录、瀑布流图、内容分发网络检测等，提供详细的性能报告。
   - **网址**：[WebPageTest](https://www.webpagetest.org/)

3. **Chrome DevTools**:
   - **描述**：浏览器自带的开发工具，提供全面的性能评估和调试功能。
   - **功能**：网络请求分析、JavaScript 性能分析、内存和时间线分析。
   - **网址**：[Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools)

4. **PageSpeed Insights**:
   - **描述**：由 Google 提供，通过 Lighthouse 提供性能评分和优化建议。
   - **功能**：适用于桌面和移动设备，提供详细的性能报告和优化建议。
   - **网址**：[PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)

5. **GTmetrix**:
   - **描述**：提供网页性能分析、页面加载详情和优化建议。
   - **功能**：提供 YSlow 和 Google PageSpeed 的评分，详细的瀑布流图和性能建议。
   - **网址**：[GTmetrix](https://gtmetrix.com/)

6. **Pingdom Website Speed Test**:
   - **描述**：提供网页加载时间测试和改进建议。
   - **功能**：具备详细的瀑布图、性能打分和优化建议。
   - **网址**：[Pingdom](https://tools.pingdom.com/)

7. **Webpack Bundle Analyzer**:
   - **描述**：可视化分析 Webpack 打包资源。
   - **功能**：帮助分析项目的 bundle 文件大小，找出需要优化的部分。
   - **网址**：[Webpack Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)

8. **Fiddler**:
   - **描述**：抓包工具，用于分析网络请求和响应。
   - **功能**：详尽的 HTTP/HTTPS 流量查看和分析。
   - **网址**：[Fiddler](https://www.telerik.com/fiddler)

### 实践中的优化策略

1. **减少 HTTP 请求**：
   - 合并 CSS 和 JavaScript 文件。
   - 使用 CSS Sprites 技术合并图像。

2. **使用 CDN 加速资源加载**：
   - 缩短资源负载时间。
   - 提供地理位置接近用户的服务器资源。

3. **资源压缩和最小化**：
   - 使用工具如 UglifyJS、CSSNano。
   - 启用 Gzip 或 Brotli 压缩。

4. **懒加载图像和延迟加载内容**：
   - 使用 `loading="lazy"` 属性或 JavaScript 懒加载方案。

5. **预加载关键资源**：
   - 使用 `<link rel="preload">` 或 `<link rel="prefetch">` 提前加载关键资源。

6. **优化 CSS 和 JavaScript 的加载顺序**：
   - 尽量内联关键 CSS，推迟非关键 CSS 的加载。
   - 将 JavaScript 文件放置在页面底部，或使用 `async` 和 `defer` 属性。

7. **缓存策略**：
   - 利用浏览器缓存，配置合理的 `Cache-Control`、`ETag` 等 HTTP 头。

8. **代码分割**：
   - 使用 Webpack、Rollup 等工具进行代码分割，只加载必要的代码。

### 总结

前端性能优化是一个多方面的工程，涉及到页面加载时间、渲染时间、交互响应时间等多个方面。通过使用合适的性能指标和工具，开发者可以有效识别和解决性能瓶颈，从而提升用户体验和网站性能。







## 前端你有做过什么性能优化

前端性能优化是一个多层次、多方面的工作，涉及到从服务器响应时间到浏览器渲染的各个环节。以下是一些常用的前端性能优化手段和策略，我在实际项目中有应用过的部分：

### 1. 资源压缩和优化

#### 压缩 HTML/CSS/JavaScript
- **工具**：使用 UglifyJS、Terser 或 Webpack 等工具压缩 JavaScript，使用 CSSNano 压缩 CSS，尽量减少这些文件的大小。
- **案例**：在一个电子商务网站项目中，通过 Webpack 对 JavaScript 和 CSS 进行压缩，最终减少了约 30% 文件大小，提高了页面加载速度。

#### 图片优化
- **工具**：使用 ImageOptim、TinyPNG 等工具压缩图片，尽量减少图片文件大小。
- **案例**：在一个博客平台上，通过压缩图片，减少了页面整体加载时间，改善了用户体验。

#### 选择合适的图片格式
- **策略**：对于矢量图像使用 SVG，对于照片类图片使用 JPEG/PNG，根据情况选择 WebP 格式。
- **案例**：在一个项目中，将部分图片转换为 WebP 格式，显著提高了页面加载速度。

### 2. 资源加载优化

#### 延迟加载（Lazy Loading）
- **策略**：对于不在首屏的图片和模块可以使用懒加载，延迟加载资源，减少初始加载时间。
- **工具**：使用 `IntersectionObserver` API 或者一些库如 `react-lazyload`。
- **案例**：在一个电商项目中，对首页的商品图片和评论模块使用懒加载，减少了首屏加载时间，提高了用户体验。

#### 预加载（Preloading）和预获取（Prefetching）
- **策略**：对于用户很可能会访问的资源，提前加载；对于一些依赖于其他资源的模块，可以使用预获取，提高页面切换速度。
- **工具**：使用 `<link rel="preload">` 和 `<link rel="prefetch">` 标签。
- **案例**：在一个单页应用中，对用户登陆后的首页资源做了预加载，减少了用户等待时间。

### 3. 代码分割和模块化

#### 按需加载（Code Splitting）
- **工具**：使用 Webpack 或 Parcel 进行代码分割，按需加载模块。
- **策略**：将代码拆分为多个小包，按需加载，减少初始加载时间。
- **案例**：在一个多页面应用中，对不同部分进行代码分割，提升了整体性能和加载速度。

#### 动态导入（Dynamic Import）
- **工具**：使用 ES6 Dynamic Import 语法（`import()`）动态加载模块。
- **案例**：在一个单页应用中，使用动态导入加载一些不常用的功能模块，有效减少了初始加载时间。

### 4. 网络优化

#### 使用 CDN
- **策略**：将静态资源（如 JS/CSS/图片）托管到 CDN 上，利用 CDN 的分布式网络加速资源加载。
- **案例**：在多个项目中使用 CDN 托管静态资源，显著减少了资源加载时间，提升了用户体验。

#### HTTP/2 和 HTTP 缓存
- **策略**：使用 HTTP/2 提供的多路复用和头部压缩特性，优化网络请求性能；配置好缓存策略，减少不必要的网络请求。
- **案例**：为一个新闻网站配置 HTTP/2，并通过合适的缓存策略，减少了多次请求带来的开销。

### 5. 渲染优化

#### 使用虚拟滚动（Virtual Scrolling）
- **策略**：对于长列表或大量数据展示，使用虚拟滚动只渲染可视区域，提高渲染性能。
- **工具**：使用 `react-virtualized`、`react-window` 等库。
- **案例**：在一个数据可视化平台中，使用虚拟滚动渲染大量数据，提高了页面滚动和渲染性能。

#### 减少重绘和重排
- **策略**：减少 DOM 操作，避免频繁的重绘和重排，优化浏览器渲染性能。
- **案例**：在一个复杂表单应用中，通过减少 DOM 操作和使用 `requestAnimationFrame`，优化了交互性能。

### 6. 其他优化策略

#### 浏览器缓存和Service Worker
- **策略**：利用浏览器缓存和 Service Worker 提高页面加载速度和离线访问能力。
- **案例**：在一个 PWA 项目中，通过 Service Worker 缓存静态资源和 API 请求，提高了应用的性能和离线功能。

#### 代码性能优化
- **策略**：进行代码优化，减少不必要的计算和逻辑，优化复杂算法，提高代码执行效率。
- **技术手段**：使用 Chrome DevTools 分析性能瓶颈，优化关键算法。
- **案例**：在一个数据处理项目中，通过优化算法和减少不必要的计算，显著提升了性能。

通过以上这些优化策略，可以显著提升前端应用的性能，改善用户体验。在实际项目中，根据具体情况组合应用这些策略，能取得较好的效果。

## 微前端是什么概念，子应用之间如何实现环境隔离？

微前端是一种将微服务理念引入到前端开发中的架构模式。它允许大型前端应用拆分成多个独立的、可部署的小型应用，每个小型应用由不同的团队独立开发、测试和部署。这种方式不仅提高了开发效率，还增强了应用的灵活性和可维护性。

### 微前端的核心概念

1. **模块化架构**：将一个大型应用拆分为多个独立的子应用，每个子应用负责某个特定的业务功能。
2. **独立部署**：每个子应用可以独立构建和部署，彼此之间没有直接的依赖。
3. **技术栈无关**：不同子应用可以使用不同的技术栈（如 React、Vue、Angular 等）开发。
4. **共同协作**：子应用可以通过事件总线、共享状态或 API 进行通信和协作。

### 子应用之间实现环境隔离的方法

当有多个子应用时，实现环境隔离非常重要，以确保各个子应用互不干扰，尤其是在样式和脚本方面。以下是实现子应用之间环境隔离的几种常用方法：

#### 1. 样式隔离

- **命名空间和CSS模块**：
  - 为每个子应用定义唯一的 `CSS` 命名空间，通过前缀或 `CSS Modules` 来确保样式不会冲突。
  - 示例：使用 postCSS 或 CSS Modules 自动添加前缀。

- **Shadow DOM**：
  - 通过 Web Components 的 Shadow DOM 能力实现样式和 DOM 的隔离。
  - 案例：一些微前端框架（如 single-spa）支持通过 Shadow DOM 实现隔离。

#### 2. 脚本隔离

- **独立的 JavaScript 作用域**：
  - 使用例如 `IIFE（立即调用函数表达式）` 方法来封装每个子应用的全局变量和函数，防止它们泄漏到全局作用域。
  - 示例：
    ```javascript
    (function() {
      // 子应用代码
      var localVariable = 'I am isolated';
    })();
    ```

- **Web Workers**：
  - 对于需要进行大量计算的子应用，可以通过 Web Workers 来实现与主线程的隔离。
  - 示例：子应用通过 Web Workers 执行后台任务，并通过消息传递与主应用通信。

#### 3. DOM 隔离

- **独立的根节点**：
  - 为每个子应用提供独立的挂载点（根节点），每个子应用只能操作自己的挂载点。
  - 示例：微前端框架如 qiankun 会为每个子应用创建独立的 `div` 容器。

- **Web Components**：
  - 使用 Web Components 自定义元素和 Shadow DOM 来实现 DOM 隔离。
  - 案例：通过自定义元素（如 `<my-micro-app></my-micro-app>`），将子应用封装在独立的 DOM 中。

#### 4. 网络请求和 API 隔离

- **独立配置和缓存**：
  - 为每个子应用配置各自独立的 API 端点和缓存策略，确保它们的网络请求和缓存不会互相干扰。
  - 示例：在每个子应用中，使用不同的全局配置或创建独立的实例（如 axios 实例）进行 API 调用。

#### 微前端实现工具和框架

以下是一些常用的微前端实现工具和框架，这些工具能够帮助开发者构建和管理微前端应用，同时支持环境隔离：

1. **single-spa**：
   - 允许使用不同前端框架（如 React、Vue、Angular）构建独立的子应用，并在主应用中动态加载和激活。
   - 提供不同子应用间的事件总线和通信机制。

2. **qiankun**：
   - 基于 single-spa 进行封装，提供了更加完善和易用的微前端解决方案。
   - 支持子应用的样式隔离和 JS 作用域隔离。

3. **Module Federation（Webpack 5）**：
   - 允许多个独立构建的应用共享模块，支持动态加载和共享依赖。
   - 常用于构建独立开发、独立部署的微前端应用。

4. **import maps**：
   - 通过浏览器原生支持的 `import maps` 机制，定义各子应用模块的别名和路径，支持动态加载和隔离。

以下是一个简单的使用 single-spa 和 qiankun 实现微前端的示例：

```javascript
// main.js (主应用)
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:7100',
    container: '#container',
    activeRule: '/app1',
  },
  {
    name: 'app2',
    entry: '//localhost:7101',
    container: '#container',
    activeRule: '/app2',
  },
]);

start();
```

通过以上方法和工具，可以实现微前端架构，并在确保子应用之间实现环境隔离的前提下，提升前端应用的可扩展性和可维护性。

## 在eval里this指向哪里？如何改变eval的this？

在 JavaScript 中，`eval` 函数的 `this` 指向取决于它被调用的上下文。这是一个比较复杂的话题，因为 `eval` 的行为在严格模式和非严格模式下有所不同。让我们详细探讨一下：

1. 非严格模式下的 `eval`：

   在非严格模式下，`eval` 中的 `this` 通常指向全局对象（在浏览器中是 `window`，在 Node.js 中是 `global`）。

   ```javascript
   console.log(eval('this')); // 在浏览器中输出 window 对象
   ```

2. 严格模式下的 `eval`：

   在严格模式下，`eval` 中的 `this` 保持为 `undefined`。

   ```javascript
   'use strict';
   console.log(eval('this')); // 输出 undefined
   ```

3. 改变 `eval` 的 `this`：

   要改变 `eval` 中 `this` 的指向，你可以使用以下几种方法：

   a. 使用 `Function` 构造函数：

   ```javascript
   const obj = { name: 'John' };
   const result = Function('return this.name').call(obj);
   console.log(result); // 输出: John
   ```

   b. 使用 `bind`、`call` 或 `apply`：

   ```javascript
   const obj = { name: 'John' };
   const evalWithCustomThis = eval.bind(obj);
   console.log(evalWithCustomThis('this.name')); // 输出: John
   ```

   c. 使用箭头函数（注意：箭头函数不会创建自己的 `this` 上下文）：

   ```javascript
   const obj = { name: 'John' };
   const result = eval('(() => this.name)()');
   console.log(result); // 输出: undefined（因为箭头函数捕获了全局 this）

   const boundEval = (code) => eval(code);
   console.log(boundEval.call(obj, 'this.name')); // 输出: John
   ```

4. 间接调用 `eval`：

   当 `eval` 被间接调用时（即不是直接使用 `eval()` 语法），它会在全局作用域中执行，而不是当前作用域。这也会影响 `this` 的指向。

   ```javascript
   const indirectEval = eval;
   console.log(indirectEval('this')); // 总是指向全局对象，即使在严格模式下
   ```

5. 使用 `new Function`：

   这是一种更安全和可控的方式来执行动态代码，同时可以明确指定 `this`：

   ```javascript
   const obj = { name: 'John' };
   const dynamicFunction = new Function('return this.name');
   console.log(dynamicFunction.call(obj)); // 输出: John
   ```

需要注意的是，使用 `eval` 通常被认为是不安全的，因为它可以执行任意 JavaScript 代码，可能导致安全漏洞。在实际开发中，应尽量避免使用 `eval`，而是寻找更安全的替代方案。

如果你确实需要动态执行代码，考虑使用 `new Function()` 或其他更安全的方法。同时，始终确保你完全信任要执行的代码源，并对输入进行严格的验证和清理。

### 上面说的那种方式没办法直接改变eval的this，因为eval的this永远指向外部函数的上下文，怎么直接改变？

你说的没错，用 `call`、`apply` 或 `bind` 方法并不能直接改变 `eval` 内部代码执行时 `this` 的指向。因为 `eval` 函数本身并没有 `this` 指向，它只是简单地在其调用上下文中执行代码。

**无法真正改变 eval 的 this:**

当我们使用 `eval.call(obj, 'console.log(this)')` 时，我们实际上改变的是 `eval` 函数本身执行时的 `this`，而不是 `'console.log(this)'` 这段代码在 `eval` 内部执行时的 `this`。

**变通方案：**

虽然无法直接改变 `eval` 内部 `this` 的指向，但我们可以通过一些变通的方式达到类似的效果：

1. **传递参数：**  将外部 `this` 作为参数传递给 `eval` 代码：

```javascript
const obj = { name: 'Alice' };

function foo() {
  eval(`console.log(arguments[0].name)`); // Alice
}

foo.call(obj); 
```

2. **使用箭头函数：**  箭头函数不绑定 `this`，它会捕获外部作用域的 `this`。

```javascript
const obj = { name: 'Bob' };

function foo() {
  eval(`(() => console.log(this.name))()`); // Bob
}

foo.call(obj); 
```

3. **使用 with 语句（不推荐）：**  `with` 语句可以改变代码执行时的作用域链，但不推荐使用，因为它会降低代码可读性和性能。

```javascript
const obj = { name: 'Charlie' };

function foo() {
  with (obj) {
    eval(`console.log(this.name)`); // Charlie
  }
}

foo();
```

**再次强调：**

虽然以上方法可以实现类似改变 `eval` 内部 `this` 的效果，但 **强烈建议避免使用 `eval`**，因为它存在安全风险和性能问题。如果需要动态执行代码，可以使用更安全的替代方案，例如 `Function` 构造函数或 `setTimeout` 函数。

希望这些解释能够帮助你理解 `eval` 中 `this` 的指向问题！

## eval执行的返回值是什么？如果传入一个字符串“undefined”，返回什么？

`eval` 函数在执行传入的字符串时，会将其解析为 JavaScript 代码并执行，并返回执行结果。具体返回值取决于传入的字符串所表示的代码。

### 1. 立即表达式的结果

如果传入的字符串是一个立即表达式，`eval` 返回该表达式的结果：

```javascript
console.log(eval('2 + 2'));  // 输出 4
console.log(eval('"Hello, world!"'));  // 输出 "Hello, world!"
```

### 2. 变量或函数声明的结果

如果传入的字符串是变量或函数声明，`eval` 返回 `undefined`，因为声明语句本身没有返回值：

```javascript
console.log(eval('var x = 10'));  // 输出 undefined
console.log(eval('function foo() { return 42; }'));  // 输出 undefined
console.log(eval('foo()'));  // 输出 42
```

### 3. 返回 `undefined`

如果传入的字符串是 `"undefined"`，`eval` 返回 `undefined`，因为 `"undefined"` 是 JavaScript 中的一个值：

```javascript
console.log(eval('undefined'));  // 输出 undefined
console.log(eval('"undefined"'));  // 输出 "undefined"
```

区别在于：
- `eval('undefined')`：这是对 JavaScript 中 `undefined` 值的引用，返回 `undefined`。
- `eval('"undefined"')`：这是一个字符串字面量，返回字符串 `"undefined"`。

### 4. 语句块的结果

对于代码块，`eval` 返回最后一个表达式的结果，或者 `undefined` 如果代码块没有返回值：

```javascript
console.log(eval('{ var a = 1; var b = 2; a + b; }'));  // 输出 3

console.log(eval('{ var x = 10; var y = 20; }'));  // 输出 undefined
```

### 5. 语法错误

如果传入的字符串包含语法错误，`eval` 会抛出 `SyntaxError` 异常：

```javascript
try {
  eval('var x = ;');  // 语法错误
} catch (e) {
  console.error(e.message);  // 输出 SyntaxError: Unexpected token ';'
}
```

### 总结

`eval` 的返回值取决于传入字符串所表示代码的实际执行结果：

- 对于表达式，返回表达式的计算结果。
- 对于变量或函数声明，返回 `undefined`。
- 对于字符串 `"undefined"`，返回 `undefined`。
- 对于语法错误，会抛出异常。

使用 `eval` 时应特别谨慎，因为它引入了潜在的安全风险和性能问题。尽量避免使用 `eval`，如果必须使用，确保传入的代码是可信和安全的。

## 项目中人员轨迹如何记录，怎么把轨迹点连成线？有看过底层实现吗？了解webGL吗

在项目中记录人员轨迹和将轨迹点连成线通常涉及以下步骤和技术，尤其是在使用 WebGL 的情况下：

### 记录人员轨迹

1. **数据收集：**
   - **GPS数据**：通过设备的 GPS 传感器获取连续的地理坐标（经纬度）。
   - **时间戳**：每个坐标点附带一个时间戳，以确保轨迹的时序性。
   - **其他传感器**：如加速计、陀螺仪等，用于更精细的位置信息和移动方向。

2. **数据存储：**
   - **本地存储**：临时保存到设备本地缓存。
   - **服务器存储**：定期同步到服务器以便持久化存储和后续分析。

### 将轨迹点连成线

1. **数据处理：**
   - **过滤和清理数据**：去除噪音数据和不合理的跳跃，比如瞬间产生的巨大位移。
   - **插值**：在低频率采样的情况下，可能需要对点之间进行插值以增加连线的平滑性。

2. **线条绘制：**
   - **Canvas API**：使用 HTML5 的 Canvas API 绘制简单的轨迹线。
   - **WebGL**：选择 WebGL 可以实现更复杂、性能更高的 3D 绘制。

### WebGL 底层实现概述

1. **着色器编程**：
   - **顶点着色器**：负责处理每个顶点的属性（比如位置、颜色）。
   - **片段着色器**：负责计算每个像素的颜色。

2. **缓冲区对象**：
   - **顶点缓冲区（VBO）**：存储所有的轨迹点坐标信息。
   - **索引缓冲区（IBO）**：在需要绘制线条时，通过索引用顶点创建线段。

3. **绘制线条**：
   - 使用 `gl.LINE_STRIP` 来连接一系列顶点以画出连贯的线。
   - 可根据数据动态更新缓冲区并重新渲染，以实时显示轨迹。

4. **变换和投影**：
   - 使用透视和模型视图矩阵，以便在地图或者场景中正确显示轨迹线。

### WebGL 优势

- **高性能**：利用 GPU 加速，可以处理大量的点和复杂的图形需求。
- **3D 支持**：能够将轨迹以3D形式呈现，提供沉浸式的用户体验。

### 实现建议

- 初学者可以先从熟悉 Canvas API 开始，逐步迁移到 WebGL，以理解底层渲染机制。
- 对于复杂3D场景，可以借助现成的 WebGL 库如 Three.js 来加速开发过程。

您是否有需要进一步探讨的特定方面，或是在 WebGL 实现中遇到具体问题？

## 流程可视化编辑如何实现，canvas

流程可视化编辑器是一个允许用户以图形化方式创建和修改流程图或工作流的工具。使用 HTML5 的 Canvas 是一种常见的方法，用于实现这一类的编辑器，因为 Canvas 提供了低级的绘图操作接口，允许在单一图形区域内进行复杂的渲染。以下是一个详细的实现指南：

### 基本结构

1. **Canvas 元素**：
   - HTML5 标准中提供，通过 `<canvas>` 标签定义。
   - 需要 JavaScript 操作其 `2D` 或 `webgl`（3D）上下文。

2. **数据结构**：
   - **节点（Node）**：代表流程图中的个体操作或状态。
   - **连线（Edge/Connection）**：连接不同节点以表示流程路径。
   - **属性（Properties）**：例如节点的类型、尺寸、位置等。

### 实现步骤

1. **初始化 Canvas**：
   - 设置 Canvas 的宽度和高度。
   - 获取渲染上下文（通常为 2D）。

   ```html
   <canvas id="flowchartCanvas" width="800" height="600"></canvas>
   ```

   ```javascript
   const canvas = document.getElementById('flowchartCanvas');
   const ctx = canvas.getContext('2d');
   ```

2. **绘制元素**：
   - **节点绘制**：绘制矩形、圆形或其他图形表示节点。
     - 设置填充和边框颜色。
     - 标记节点 ID 或名称以便区分。
   - **连线绘制**：使用 `moveTo` 和 `lineTo` 进行节点间的连接。
     - 可以添加箭头以指示方向。

   ```javascript
   function drawNode(ctx, x, y, width, height, label) {
     ctx.fillStyle = '#CCCCCC';
     ctx.fillRect(x, y, width, height);
     ctx.strokeStyle = '#000';
     ctx.strokeRect(x, y, width, height);
     ctx.fillStyle = '#000';
     ctx.fillText(label, x + 10, y + 20);
   }
   
   function drawLine(ctx, startX, startY, endX, endY) {
     ctx.beginPath();
     ctx.moveTo(startX, startY);
     ctx.lineTo(endX, endY);
     ctx.stroke();
   }
   ```

3. **交互操作**：
   - **拖动**：实现鼠标拖动事件监听，以支持节点的移动操作。
     - 监听鼠标的 `mousedown`、`mousemove` 和 `mouseup` 事件。
     - 计算鼠标位置与节点的偏移以实时更新绘制。
   - **连接**：通过双击或其他操作方式开始和结束节点连接线的绘制。

   ```javascript
   // 示例：简单的拖动效果
   let dragging = false;
   let dragStartNode = null;
   
   canvas.addEventListener('mousedown', (e) => {
     const mousePos = getMousePos(canvas, e);
     dragStartNode = checkNodeHit(mousePos);
     if (dragStartNode) {
       dragging = true;
     }
   });
   
   canvas.addEventListener('mouseup', () => {
     dragging = false;
     dragStartNode = null;
   });
   
   canvas.addEventListener('mousemove', (e) => {
     if (dragging && dragStartNode) {
       const mousePos = getMousePos(canvas, e);
       // Update node position based on mousePos and redraw
     }
   });
   
   function getMousePos(canvas, event) {
     const rect = canvas.getBoundingClientRect();
     return {
       x: event.clientX - rect.left,
       y: event.clientY - rect.top
     };
   }
   
   function checkNodeHit(pos) {
     // Iterate over nodes and return the node that's hit
   }
   ```

4. **更新与重绘**：
   - 图形界面需要在动作结束后重绘。
   - 可以通过 `requestAnimationFrame` 或简单地在鼠标事件后调用重绘功能。

5. **性能优化**：
   - 使用双缓冲技术：先在离屏 Canvas 绘制，然后一次性更新屏幕。
   - 在节点和线条数目多时，可以使用简单的碰撞检测算法优化渲染区域更新。

### 高级功能

- **缩放与平移**：实现对画布的缩放和平移，使得用户可以调整视图。
- **撤销与重做**：记录用户操作以实现撤销和重做功能。
- **多选与组合**：支持对多个元素的同时操作，包括选中、移动、连接等。

通过 Canvas 实现流程可视化编辑器需要对图形、事件处理、绘图逻辑方面有比较深入的理解，并且对于不同的交互细节进行优化处理。根据项目需求，可能还需要结合其他技术或库（例如 React、Vue 结合 Canvas），以实现更加动态和响应式的用户界面。



## 程序的设计模式有哪些，以及使用场景有哪些

设计模式是软件开发中经过验证的解决方案，旨在解决常见的设计问题并提高代码的可维护性、可重用性和可扩展性。设计模式主要分为三大类：创建型模式、结构型模式和行为型模式。以下是常见的设计模式及其典型使用场景：

### 创建型模式

1. **单例模式（Singleton Pattern）**
   - **用途**：确保一个类只有一个实例，并提供全局访问点。
   - **场景**：控制对共享资源的访问，如配置类、日志记录器。

2. **工厂方法模式（Factory Method Pattern）**
   - **用途**：定义创建对象的接口，让子类决定实例化哪一个类。
   - **场景**：当类的实例化过程比较复杂或需要在运行时进行决策时使用。

3. **抽象工厂模式（Abstract Factory Pattern）**
   - **用途**：提供一个接口，用于创建一组相关或依赖的对象，而无需指定它们的具体类。
   - **场景**：适用于需要创建多个系列相关产品的系统。

4. **建造者模式（Builder Pattern）**
   - **用途**：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。
   - **场景**：构建复杂的对象，特别是当对象需要一步步创建时。

5. **原型模式（Prototype Pattern）**
   - **用途**：通过复制现有实例来创建新对象，避免重新初始化。
   - **场景**：用于创建代价昂贵或动态配置的对象。

### 结构型模式

1. **适配器模式（Adapter Pattern）**
   - **用途**：使接口不兼容的对象能够协同工作。
   - **场景**：整合遗留系统，或者需要使用已有接口实现新的功能时。

2. **桥接模式（Bridge Pattern）**
   - **用途**：将抽象部分与实现部分分离，使它们都可以独立变化。
   - **场景**：需要跨越多个平台的图形和窗口系统。

3. **组合模式（Composite Pattern）**
   - **用途**：将对象组合成树形结构以表示“部分-整体”的层次结构。
   - **场景**：表示层次结构或部分-整体关系，如文件系统。

4. **装饰者模式（Decorator Pattern）**
   - **用途**：向对象添加新的职责（附加功能），而不改变其结构。
   - **场景**：动态地增加一组功能给对象，类似于 Java I/O 类中的装饰者。

5. **外观模式（Facade Pattern）**
   - **用途**：为子系统中的一组接口提供一个统一的接口。
   - **场景**：简化复杂系统的接口，使客户端与子系统的类交互更简单。

6. **享元模式（Flyweight Pattern）**
   - **用途**：通过共享尽可能多的相似对象节省内存。
   - **场景**：用于系统中有大量对象并消耗过多内存。

7. **代理模式（Proxy Pattern）**
   - **用途**：为其他对象提供一种代理以控制对这个对象的访问。
   - **场景**：控制实例化、控制访问权限和网络资源。

### 行为型模式

1. **责任链模式（Chain of Responsibility Pattern）**
   - **用途**：将请求沿着处理者链传递，直到有对象处理它。
   - **场景**：审批流程或事件传递机制。

2. **命令模式（Command Pattern）**
   - **用途**：将请求封装为对象，从而使可用不同的请求、队列或日志来参数化其他对象。
   - **场景**：事务、撤销和日志请求的处理。

3. **解释器模式（Interpreter Pattern）**
   - **用途**：为语言创建解释器。
   - **场景**：开发编程语言或者对现有语言的扩展。

4. **迭代器模式（Iterator Pattern）**
   - **用途**：在不暴露对象内部结构的情况下遍历集合。
   - **场景**：遍历各种集合（如列表、树等），适用于标准化遍历过程。

5. **中介者模式（Mediator Pattern）**
   - **用途**：用一个中介对象来封装一系列对象的交互。
   - **场景**：用于对象的交互行为复杂且难以维护时。

6. **备忘录模式（Memento Pattern）**
   - **用途**：在不破坏封装的前提下捕获和恢复对象的内部状态。
   - **场景**：实现对象状态的撤销和恢复。

7. **观察者模式（Observer Pattern）**
   - **用途**：定义对象之间的一对多依赖，当一个对象改变状态时通知其所有依赖者。
   - **场景**：事件处理系统，如 GUI 或者数据绑定。

8. **状态模式（State Pattern）**
   - **用途**：允许对象在内部状态改变时修改其行为。
   - **场景**：对象需要根据内部状态改变行为时，如状态机。

9. **策略模式（Strategy Pattern）**
   - **用途**：定义一系列算法，将每一个算法封装起来，并让它们可以互换。
   - **场景**：需要在运行时动态选择算法或策略的地方。

10. **模板方法模式（Template Method Pattern）**
    - **用途**：定义算法骨架，并将一些步骤的实现延迟到子类。
    - **场景**：有固定流程但部分实现会变化的行为。

11. **访问者模式（Visitor Pattern）**
    - **用途**：为对象结构中的每个元素添加新能力。
    - **场景**：需要对对象结构中的元素执行多种不同且不相关的操作。

### 总结

设计模式为软件开发提供了一种抽象的思维工具，帮助开发者以一种已知的、可维护的方式解决复杂设计问题。选择合适的模式，能极大改善软件的可维护性、灵活性和可扩展性。在实践中，经常会结合多种模式，形成应用程序的整体架构。





## border-box和content-box，边长各是多少

```css
.box{
    width:10px;
    height:10px;
    padding:2px;
    margin:2px;
    border:1px;
    background:blue;
}
```

## 采用原生HTML+CSS+JS搭建一个简易的前端项目

### 实现页面中有表格数据展示并支持输入框关键词进行搜索查询，比如通过姓名筛选班级同学，其中CSS和JS通过独立文件进行引入

当然，可以创建一个简易的前端项目来展示表格数据并支持通过关键词进行搜索。以下是一个简单的实现：

### 目录结构

假设你的项目目录结构如下：

```
project/
│
├── index.html
├── styles.css
└── script.js
```

### `index.html`

我们先创建一个基本的 HTML 文件，它包含一个输入框、一个按钮以及一个用于展示数据的表格。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Search</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>Classmates</h1>
        <input type="text" id="searchInput" placeholder="Search by name...">
        <button onclick="search()">Search</button>
        <table id="dataTable">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Class</th>
                </tr>
            </thead>
            <tbody>
                <!-- Rows will be dynamically inserted here -->
            </tbody>
        </table>
    </div>
    <script src="script.js"></script>
</body>
</html>
```

### `styles.css`

接下来，我们添加一些基本的样式来美化页面。

```css
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    padding: 20px;
}

.container {
    max-width: 600px;
    margin: auto;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
    text-align: center;
}

input {
    display: block;
    width: calc(100% - 22px);
    padding: 10px;
    margin: 10px 0;
    border: 1px solid #ccc;
    border-radius: 4px;
}

button {
    display: block;
    width: 100%;
    padding: 10px;
    background: #007BFF;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 10px;
}

button:hover {
    background: #0056b3;
}

table {
    width: 100%;
    border-collapse: collapse;
}

table, th, td {
    border: 1px solid #ddd;
}

th, td {
    padding: 10px;
    text-align: left;
}
```

### `script.js`

最后，我们实现 JavaScript 逻辑，用于处理表格数据的动态渲染和搜索功能。

```js
// 定义表格数据
let students = [
    { name: 'Alice', class: '1A' },
    { name: 'Bob', class: '1B' },
    { name: 'Charlie', class: '1A' },
    { name: 'David', class: '1C' },
    { name: 'Eva', class: '1B' }
];

// 初始化表格
window.onload = function() {
    populateTable(students);
};

// 填充表格数据
function populateTable(data) {
    const tableBody = document.querySelector("#dataTable tbody");
    tableBody.innerHTML = ""; // 清空表格内容

    data.forEach(student => {
        const row = document.createElement("tr");
        const nameCell = document.createElement("td");
        const classCell = document.createElement("td");
        
        nameCell.textContent = student.name;
        classCell.textContent = student.class;

        row.appendChild(nameCell);
        row.appendChild(classCell);

        tableBody.appendChild(row);
    });
}

// 搜索功能
function search() {
    const searchInput = document.getElementById("searchInput").value.toLowerCase();
    const filteredStudents = students.filter(student => 
        student.name.toLowerCase().includes(searchInput)
    );
    populateTable(filteredStudents);
}
```

### 注意事项

- **数据刷新：** 填充表格时，先清空表格内容，再添加新的行。
- **大小写处理：** 在搜索时，将输入关键词和学生姓名均转为小写，以实现不区分大小写的搜索。
- **事件绑定：** 搜索按钮点击事件通过 `onclick` 属性绑定到 `search` 函数。

通过以上步骤，你就可以创建一个简单的前端项目，实现基本的数据展示和搜索功能。你可以根据需求进一步扩展和美化这个项目。

## 蔚来二面手写

// 实现一个_get函数，它接受三个参数object, keypath, defaultValue
// object是个对象
// keypath是你的对象object的调用路径，它可能是属性的获取，可能是方法的调用，也有可能是数组元素的获取，调用的格式如有右所示：a.b[1].c(1,2)
// defaultValue是默认值，当获取的值为undefined时返回它。
// 最后返回通过keypath的调用路径获取的对象中的某个属性值或某个方法调用结果。
type _get = (object: Object, keypath: string, defaultValue: any) => any;

```javascript
function _get(object, keypath, defaultValue) {
    try {
        // Preprocess keypath for dynamic property access
        let funcBody;

        // Check if keypath starts with '[' to avoid prepending '.'
        if (keypath.charAt(0) === '[') {
            funcBody = `return obj${keypath}`;
        } else {
            funcBody = `return obj.${keypath}`;
        }

        // Create a function that accesses the path inside the object
        const func = new Function('obj', funcBody);
        const result = func(object);

        // If the result is undefined, return defaultValue. Otherwise, return the result.
        return result === undefined ? defaultValue : result;
    } catch (err) {
        // If anything goes wrong, return defaultValue.
        return defaultValue;
    }
}

// Example usage:
const obj = {
    a: {
        b: [
            { c: (x, y) => x + y },
            { d: 42 }
        ]
    }
};

const result1 = _get(obj, 'a.b[0].c(1, 2)', 'default'); // Should return 3
const result2 = _get(obj, 'a.b[1].d', 'default'); // Should return 42
const result3 = _get(obj, 'a.b[2]', 'default'); // Should return 'default'

console.log(result1); // Output: 3
console.log(result2); // Output: 42
console.log(result3); // Output: 'default'
```

这段代码实现了一个通用的函数 `_get`，它用于在一个对象中通过给定的路径访问属性或调用方法，并在值为 `undefined` 的情况下提供一个默认值。以下是对代码的详细解释：

### 函数定义

```javascript
function _get(object, keypath, defaultValue) {
```

- **`object`**：要在其上查找值的对象。
- **`keypath`**：一个字符串，指定对象中要访问的属性或方法的路径。
- **`defaultValue`**：如果通过 `keypath` 找到的值为 `undefined`，则返回该默认值。

### 核心逻辑

```javascript
try {
    // Preprocess keypath for dynamic property access
    let funcBody;

    // Check if keypath starts with '[' to avoid prepending '.'
    if (keypath.charAt(0) === '[') {
        funcBody = `return obj${keypath}`;
    } else {
        funcBody = `return obj.${keypath}`;
    }
    
    // Create a function that accesses the path inside the object
    const func = new Function('obj', funcBody);
    const result = func(object);
```

- **`try` 块**：用于捕获可能的异常，尤其是路径访问出错时。
- **`funcBody` 的构建**：
  - 如果路径以 `[` 开头，预示着路径从数组元素开始，不需要在前面加上 `.`。
  - 否则，我们假设路径从对象的顶层属性开始，因此需要在前面加上 `.`。
  
- **`new Function`**：用于创建一个能够在给定对象上动态链式调用路径的 JavaScript 函数。`funcBody` 是该函数的主体，返回对象沿着路径访问的结果。

```javascript
    const result = func(object);
```

- 执行动态创建的函数，这会在给定的对象上尝试访问路径所指定的属性或方法，并将结果存储到 `result` 中。

### 返回值

```javascript
    // If the result is undefined, return defaultValue. Otherwise, return the result.
    return result === undefined ? defaultValue : result;
} catch (err) {
    // If anything goes wrong, return defaultValue.
    return defaultValue;
}
```

- **`result === undefined` 检查**：如果通过路径找到的结果是 `undefined`，则返回提供的 `defaultValue`。
- **`catch` 块**：在路径访问过程中可能发生的任何异常都将导致返回 `defaultValue`。

### 示例用法

```javascript
const obj = {
    a: {
        b: [
            { c: (x, y) => x + y },
            { d: 42 }
        ]
    }
};

// 使用示例
const result1 = _get(obj, 'a.b[0].c(1, 2)', 'default'); // 期待返回 3
const result2 = _get(obj, 'a.b[1].d', 'default'); // 期待返回 42
const result3 = _get(obj, 'a.b[2]', 'default'); // 期待返回 'default'

console.log(result1); // 输出: 3
console.log(result2); // 输出: 42
console.log(result3); // 输出: 'default'
```

1. **`result1`**：通过路径 `a.b[0].c(1, 2)` 调用方法 `c` 结果是 `3`。
2. **`result2`**：通过路径 `a.b[1].d` 访问到的属性 `d` 是 `42`。
3. **`result3`**：路径 `a.b[2]` 不存在，因此返回默认值 `'default'`。



const func = new Function('obj', funcBody);
        const result = func(object);详细讲讲这两句是什么意思

这两句代码利用 JavaScript 的动态函数构造能力，以便从给定对象中动态访问或调用指定路径上的属性或方法。这是 JavaScript 的一个高级特性，允许在运行时创建和执行代码。

### 详细解释

#### `new Function`

```javascript
const func = new Function('obj', funcBody);
```

- **`new Function`**：
  - JavaScript 中的 `Function` 构造器是一种特殊的构造方法，允许我们动态创建一个函数。提供的字符串参数被解析为函数体，从而可以在运行时生成和执行函数代码。
  - 在该行中，`new Function('obj', funcBody)` 创建了一个新的函数对象。
  - **第一个参数 `'obj'`** 是新函数的参数名。也就是说，这个动态创建的函数接受一个名为 `obj` 的参数。
  - **第二个参数 `funcBody`** 是函数的主体。它是一段包含 JavaScript 代码的字符串，决定了新函数的行为。在 `_get` 函数中，这段代码通常是 `return obj.somePath` 或 `return obj[somePath]` 的形式。

- **为什么使用 `new Function`**：
  - 这种方法很强大，因为它提供了运行时动态生成函数的能力，可以使用字符串输入来按需构造逻辑。
  - 使用动态函数生成技术可以实现更灵活和动态的编程模式，特别是在路径或表达式需要根据输入实时变化的情况下。

#### 执行动态函数

```javascript
const result = func(object);
```

- **`func(object)`**：
  - 在这一步，我们调用之前创建的动态函数，并传入一个具体的对象 `object` 作为参数。这意味着函数中的 `obj` 参数被实际的 `object` 替换。
  - `funcBody` 中定义的返回语句将根据传入的 `object` 执行，从而实现从对象访问路径或进行方法调用。
  - **返回值**：该表达式返回路径指定的对象属性或方法的结果，该结果被存入变量 `result`。

### 为何使用这种方法

使用 `new Function` 而不是直接进行对象访问（如通过 `obj[key]` 的形式），是因为：
- 可以处理更复杂的路径和方法调用。
- 可以非常灵活地支持嵌套属性和动态构建的复杂表达式。
- 代码构建时路径未知时，这种动态方式非常方便。

### 注意事项

使用 `new Function` 有其局限性和风险：
- **性能问题**：由于是动态编译和执行代码，可能会有性能损失，特别是在循环中重复创建新函数时。
- **安全性问题**：如果 `funcBody` 的内容来自不受信任的输入，可能会导致代码注入攻击。因此，在处理外部或不可信数据时应格外小心。

## 微前端

[介绍 - qiankun (umijs.org)](https://qiankun.umijs.org/zh/guide)

简单地说就是把一个完整的应用拆分成不同的模块，每个模块只负责自己部分的实现，模块之间使用什么技术，用什么写法，甚至用什么语言完全都是无所谓的

- 方便大项目的开发维护
- 子模块可以使用不同的技术栈
- 这种技术也不是适合所有项目的
- 你光听你就得想到这种东西的肯定涉及到模块之间的通信问题
- 那么你如何保证模块儿之间的通信延迟和数据一致性就是一个点，数据一致性可能框架能帮你解决，但是延迟问题是致命的，所以延迟敏感类的业务就不合适
