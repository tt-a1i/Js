


### **数组去重**



1. **ES6 Set**

   ``` javascript
   let arr = [1, 2, 3, 4, 4, 5, 5, 6];
   
   let uniqueArr = [...new Set(arr)];
   //...运算符将可迭代对象展开为单独元素
   ```

2. **Array.from + Set**

   ```javascript
   let uniqueArr = Array.from(new Set(arr));
   ```

   ​	在JavaScript中，`Array.from()` 方法用于将类数组对象或可迭代	对象转换为一个新的数组实例。结合 `Set` 对象，可以用来创建一个不包含重复元素的新数组。

   ​	`	Set` 是一种特殊的类型，它不允许有重复的值。当你用一个数组初始化 `Set` 时，它会自动去除所有重复的元素。

3. **indexOf**

   ```javascript
   //双重循环splice
   for(let i = 0; i < arr.length; i++) {
     for(let j = i + 1; j < arr.length; j++) {
       if(arr[i] === arr[j]) {
         arr.splice(j, 1);
         j--; // 因为删除了一个元素，需要回溯j，否则可能跳过一个//元素
       }
     }
   }
   // 此处arr已经去重，但请注意，原数组被修改了
   ```

   4.**对象键名唯一性**

   ```javascript
   let obj = {};
   let uniqueArr = [];
   for(let i = 0; i < arr.length; i++) {
     if(!obj.hasOwnProperty(arr[i])) {
       obj[arr[i]] = true;
       uniqueArr.push(arr[i]);
     }
   }
   ```

### **防抖**

`防抖是指短时间内大量触发同一事件，只会在最后一次事件完成后延迟执行一次函数`。例如，在输入用户名的过程中，需要反复验证用户名。此时，您应该等待用户停止输入，然后进行验证，否则将影响用户体验。 防抖实现的原理是在触发事件后设置计时器。在计时器延迟过程中，如果事件再次触发，则重置计时器。在没有触发事件之前，计时器将再次触发并执行相应的功能。

    声明定时器
    
    返回函数
    
    一定时间间隔，执行回调函数
    
    回调函数
        已执行：清空定时器
        未执行：重置定时器

下面是一个简单的JavaScript防抖函数实现：

``` javascript
function debounce(fn, delay) {
        let timer = null
        return function (...args) {
                if (timer) clearTimeout(timer)
                timer = setTimeout(() => {
                        timer = null
                        fn.apply(this, args)
                }, (delay + '') | 0 || 1000 / 60)
        }
}
1000 / 60 的计算结果大约是 16.666666666666668 毫秒（ms）。这个数值代表每秒60帧动画的理论间隔时间，也就是通常计算机屏幕刷新率的标准值之一。在动画、游戏开发或者性能优化时，尤其是当需要处理连续触发但希望限制执行频率的情况时，会用到这个时间间隔来实现节流（throttling）或防抖（debounce）的效果。

详细解释代码逻辑：

    定义内部闭包变量 timer，用于存储 setTimeout 返回的句柄，以便后续清除定时器。

    返回一个新的函数（闭包），该函数接收任意数量的参数（通过剩余参数语法 ...args 表示）。

    在返回的闭包函数中：

首先检查 timer 是否存在（即是否已有待执行的定时任务）。如果存在，调用 clearTimeout(timer) 来清除当前的定时器，防止重复执行目标函数fn。

然后设置新的 setTimeout 调用，将目标函数包装在一个匿名函数内，并传入之前收集的所有参数 args。这里使用了 .apply(this, args) 以确保在调用 fn 时保持正确的上下文和参数列表。

delay 参数经过 (delay + '') | 0 || 1000 / 60 处理：
先将其转换为字符串加上空字符串，确保可以处理非数值类型。
`使用按位操作符 | 0 进行强制转换为整数`。这一步是为了确保 delay 是一个有效的整数值，如果不是可转换为整数的数值（如NaN），则会变为0。
如果上述转换结果为 falsy 值（比如转换后是0或者原本就是非数字），则使用默认值 1000 / 60 作为延迟时间。

当 setTimeout 到期时，会清除当前的 timer 变量（设为 null），然后实际调用 fn 函数并传入之前缓存的参数 args。

```

### **节流**

用于限制某个函数在特定时间段内的执行频率。当某个事件频繁触发时（比如用户滚动页面、窗口大小调整、连续按键等），节流函数确保在单位时间内，无论事件触发了多少次，目标函数至多仅执行一次。即使事件处理程序原本会被连续快速地调用，经过节流处理后，会在每个预设的时间间隔内至少等待指定的延迟时间，然后才执行回调函数。

- 声明定时器
- 返回函数
- 一定时间间隔，执行回调函数
- 回调函数
  - 已执行：清空定时器
  - 未执行：返回

```javascript
function throttle(fn, interval) {
        let timer = null
        return function (...args) {
                if (timer) return
                timer = setTimeout(() => {
                        timer = null
                        fn.apply(this, args)
                }, (interval +'')| 0 || 1000 / 60)
        }
}

```

​	

### 浅拷与深拷贝

浅拷贝类似于C中的数组，赋值是指向数组的内存首地址，对赋值后数组的操作同样会影响到原数组

深拷贝相当于重新生成一个新的值，二者互不影响

#### 为什么要使用深拷贝？

我们希望在创建新的数组（对象）的时候，不改变原数组（对象）

#### 赋值和浅拷贝的区别？

当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。

浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。

```javascript
//浅拷贝
let arr = [1,2,3]
//[1, 2, 3]
let arr2 = arr
//arr2 [1, 2, 3]
arr2[0] = 0
arr2
//[0, 2, 3]
arr
//[0, 2, 3]
/*深拷贝方法*/
arr = [1,2,3]
let arr2 = JSON.parse(JSON.stringify(arr);
arr2[0] = 0
//arr2   [0, 2, 3]
//arr    [1, 2, 3]
```

![e3cd27af0fb8d57652500f104255abc6](D:\QQ\锟斤拷息锟斤拷录\2801884530\nt_qq\nt_data\Pic\2024-03\Ori\e3cd27af0fb8d57652500f104255abc6.png)

Json方法有局限性，如日期对象的转化，可以使用==window.structuredClone==

但是有兼容性问题，所以如果有严格的场景，我们一般还是要封装一个递归的函数来做，或者用第三方库来做

![7008c6b5f9404bda45d517b8d9b5e5ac](D:\QQ\锟斤拷息锟斤拷录\2801884530\nt_qq\nt_data\Pic\2024-03\Ori\7008c6b5f9404bda45d517b8d9b5e5ac.png)

### 加减乘除的处理

![8ea7bbeb83394a4ee2a54053386d78e5](D:\QQ\锟斤拷息锟斤拷录\2801884530\nt_qq\nt_data\Pic\2024-03\Ori\8ea7bbeb83394a4ee2a54053386d78e5.png)

![bfaa138f01496492b0a55066a7f0d2fd](D:\QQ\锟斤拷息锟斤拷录\2801884530\nt_qq\nt_data\Pic\2024-03\Ori\bfaa138f01496492b0a55066a7f0d2fd.png)

![57f907721bc7ecddff055ec884efff70](D:\QQ\锟斤拷息锟斤拷录\2801884530\nt_qq\nt_data\Pic\2024-03\Ori\57f907721bc7ecddff055ec884efff70.png)

![efd93a0721580e7536f63e7421529c6c](D:\QQ\锟斤拷息锟斤拷录\2801884530\nt_qq\nt_data\Pic\2024-03\Ori\efd93a0721580e7536f63e7421529c6c.png)



### v-model原理

1. **v-bind绑定value属性的值；**
2. **v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；**

```html
<input type="text" :value="textValue" @input="textValue = $event.target.value">
```

### 数组扁平化

#### ES6 的 flat 方法

```javascript
const arr = [1,[2,[3,[4,5]]],6]
//  方法一：数组自带的扁平化方法,flat的参数代表的是需要展开几层，如果是Infinity的话，就是不管嵌套几层，全部都展开
console.log(arr.flat(Infinity))
//还可以去除数组中的空项。
const array = [1,2,3,4,5,[6,7],,8,]
console.log(array.flat())//1,2,3,4,5,6,7,8

```

#### 递归

```javascript
const array = []
const  fn = (arr)=>{
    for(let i = 0;i<arr.length; i++){
        if(Array.isArray(arr[i])){
            fn(arr[i])
        }
        else {
            array.push(arr[i])
        }
    }
}
fn(arr)
console.log(array)
```

#### 使用 reduce

reduce 方法: 可以用来给数组求和

concat() 方法用于`连接两个或多个数组`。

concat() 方法不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。

```javascript
const newArr = (arr)=>{
            return arr.reduce((pre,cur)=>{
                return pre.concat(Array.isArray(cur) ? newArr(cur) : cur)
            },[])
        }
console.log(newArr(arr),"reduce方法")
```

### 数据类型

数据分为基本数据类型 (String, Number, Boolean, Null, Undefined，Symbol) 和Object,JS的7种数据类型。

基本数据类型的特点：直接存储在栈 (stack) 中的数据

引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里

引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。

ES11新增了==BigInt==

### for in 与 for of

#### For...in

For...in语句用于遍历对象的可枚举属性，例如对象的属性和原型链上的属性。它的语法如下：

```javascript
const person = {firstName: "John", lastName: "Doe", age: 25};

for (let property in person) {
  console.log(`${property}: ${person[property]}`);
}

firstName: John
lastName: Doe
age: 25

```

#### For...of

Q: ES6 的 for of 可以遍历对象吗?

A: ES6 的 “for of” 不能遍历对象。

原因：ES6 中引入了 Iterator 接口，只有提供了 Iterator 接口的数据类型才可以使用 “for-of” 来循环遍历；而普通对象默认没有提供 Iterator 接口，因此无法用 “for-of” 来进行遍历。

For...of语句用于遍历可迭代对象，例如数组、字符串、Map、Set等。它的语法如下：

```javascript
const colors = ["red", "green", "blue"];

for (let color of colors) {
  console.log(color);
}

输出：
red
green
blue

```

#### 区别：

区别

**For...in和For...of之间最大的区别在于它们遍历的内容不同。For...in遍历对象的属性名，而For...of遍历可迭代对象的值。**

**此外，For...in遍历的是对象的所有可枚举属性，包括它的原型链上的属性，而For...of只遍历可迭代对象中的值。**

**最后，For...in返回的是属性名，是一个字符串，而For...of返回的是值，可以是任何类型的值。**

### 查找数组指定元素

#### filter

```javascript
function isBigEnough(element) {
  return element == 2;
}
var filtered = [1,2,3,4,5,6].filter(isBigEnough);

//filter筛选出符合判定条件的元素返回一个新数组
```

#### find()

find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。

```javascript
var arr = [1, 2, 3, 4, 5, 6];
function finds(x) {
    return x === '2';
}
console.log(arr.find(finds));
```

![数组方法](F:\360MoveData\Users\28018\Desktop\知识点图片\数组方法.png)

### 两栏布局和三栏布局

#### **两栏**

方法一：

#### 浮动布局

使用 `float 左浮左边栏`

右`边模块使用 margin-left 撑出内容块做内容展示`

为父级元素添加 BFC，防止下方元素飞到上方内容

```html
<style>
    .box{
        overflow: hidden; 添加BFC
    }
    .left {
        float: left;
        width: 200px;
        background-color: gray;
        height: 400px;
    }
    .right {
        margin-left: 210px;
        background-color: lightgray;
        height: 200px;
    }
</style>
<div class="box">
    <div class="left">左边</div>
    <div class="right">右边</div>
</div>
```

BFC（Block Formatting Context，块级格式化上下文）是Web页面的可视化CSS渲染的一部分，是一个独立的渲染区域，使得元素在这个区域内的布局不会影响到区域外的元素。BFC有助于处理元素的浮动、清除浮动、避免边距重叠等问题。

#### 创建BFC的方法

以下是一些创建BFC的常见方法：

1. 使用 `overflow` 属性，值为 `auto`、`hidden`、`scroll` 等。
2. 使用 `display` 属性，值为 `flow-root`、`inline-block`、`flex`、`inline-flex`、`grid`、`inline-grid`。
3. 使用 `position` 属性，值为 `absolute` 或 `fixed`。
4. 使用 `float` 属性，值为 `left` 或 `right`。

方法二：

#### flex 弹性布局

flex 容器的一个默认属性值: align-items: stretch;

这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start

```html
<style>
    .box{
        display: flex;
    }
    .left {
        width: 100px;
    }
    .right {
        flex: 1;
    }
</style>
<div class="box">
    <div class="left">左边</div>
    <div class="right">右边</div>
</div>
```

1. **`display: flex;`**: 将 `.container` 设置为 Flex 容器，使其子元素可以使用 Flex 布局。
2. **`.sidebar`**: 设置固定宽度 `200px`，并设置背景颜色以便区分。
3. **`.content`**: 使用 `flex-grow: 1` 使其占据剩余空间。`flex-grow` 属性指定了元素如何在 Flex 容器中扩展，以填满容器的剩余空间。

通过这种方式，左边栏会保持固定宽度，而右边的内容块会自动调整宽度以填充容器的剩余空间，从而实现两栏布局。

#### 三栏布局

方法一：

#### 两边使用 float，中间使用 margin

需要将中间的内容放在 `html` 结构最后，否则右侧会沉在中间内容的下方

```html
<style>
    .wrap {
        background: #eee;
        overflow: hidden; <!-- 生成BFC，计算高度时考虑浮动的元素 -->
        padding: 20px;
        height: 200px;
    }
    .left {
        width: 200px;
        height: 200px;
        float: left;
        background: coral;
    }
    .right {
        width: 120px;
        height: 200px;
        float: right;
        background: lightblue;
    }
    .middle {
        margin-left: 220px;
        height: 200px;
        background: lightpink;
        margin-right: 140px;
    }
</style>
<div class="wrap">
    <div class="left">左侧</div>
    <div class="right">右侧</div>
    <div class="middle">中间</div>
</div>
```

方法二：

#### 两边使用 absolute，中间使用 margin

```html
<style>
  .container {
    position: relative;
  }
  
  .left,
  .right,
  .main {
    height: 200px;
    line-height: 200px;
    text-align: center;
  }

  .left {
    position: absolute;
    top: 0;
    left: 0;
    width: 100px;
    background: green;
  }

  .right {
    position: absolute;
    top: 0;
    right: 0;
    width: 100px;
    background: green;
  }

  .main {
    margin: 0 110px;
    background: black;
    color: white;
  }
</style>

<div class="container">
  <div class="left">左边固定宽度</div>
  <div class="right">右边固定宽度</div>
  <div class="main">中间自适应</div>
</div>

```

方法三：

#### 两边使用 float 和负 margin

实现过程：

```html
中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示

左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧

右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧
```

缺点：

    增加了 .main-wrapper 一层，结构变复杂
    
    使用负 margin，调试也相对麻烦

```html
<style>
  .left,
  .right,
  .main {
    height: 200px;
    line-height: 200px;
    text-align: center;
  }

  .main-wrapper {
    float: left;
    width: 100%;
  }

  .main {
    margin: 0 110px;
    background: black;
    color: white;
  }

  .left,
  .right {
    float: left;
    width: 100px;
    margin-left: -100%;
    background: green;
  }

  .right {
    margin-left: -100px; /* 同自身宽度 */
  }
</style>

<div class="main-wrapper">
  <div class="main">中间自适应</div>
</div>
<div class="left">左边固定宽度</div>
<div class="right">右边固定宽度</div>
```

方法四：使用 flex 实现

#### 利用 flex 弹性布局，可以简单实现中间自适应。

实现过程：

    仅需将容器设置为 display:flex; ，
    
    盒内元素两端对其，将中间元素设置为 100% 宽度，或者设为 flex:1 ，即可填充空白
    
    盒内元素的高度撑开容器的高度

优点：

    结构简单直观
    
    可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间

```html
<style type="text/css">
    .wrap {
        display: flex;
        justify-content: space-between;
    }

    .left,
    .right,
    .middle {
        height: 100px;
    }

    .left {
        width: 200px;
        background: coral;
    }

    .right {
        width: 120px;
        background: lightblue;
    }

    .middle {
        background: #555;
        width: 100%;
        margin: 0 20px;
    }
</style>
<div class="wrap">
    <div class="left">左侧</div>
    <div class="middle">中间</div>
    <div class="right">右侧</div>
</div>
```

方法五：

#### grid 网格布局

跟 `flex` 弹性布局一样的简单

```html
<style>
    .wrap {
        display: grid;
        width: 100%;
        grid-template-columns: 300px auto 300px;
    }

    .left,
    .right,
    .middle {
        height: 100px;
    }

    .left {
        background: coral;
    }

    .right {
        background: lightblue;
    }

    .middle {
        background: #555;
    }
</style>
<div class="wrap">
    <div class="left">左侧</div>
    <div class="middle">中间</div>
    <div class="right">右侧</div>
</div>
```

### 实现多行文本溢出的省略

方法一：使用定位伪元素遮盖末尾文字

给父元素设置:

```css
overflow: hidden;/* 溢出隐藏 */
line-height: 20px;/* 设置行高与容器高度成倍数关系，这样避免文本溢出时，文字显示一半 */
text-align: justify;/* 设置文本对齐方式为两端对齐，这样在伪元素内容遮盖末尾文字时才能对齐*/
position: relative;/* 子绝父相，这里是为了给伪元素设置定位*/   
```



给父元素设置伪元素 ::after ，并为其设置属性：

```css
 content: "...";/* 省略号是放在文本最后面的 */
 width: 1em;/* 设置伪元素的宽度为1em，是为了遮盖的时候正好遮盖中原来的一个字的大小*/
 background-color: pink;/* 设置与父元素相同的背景颜色，同理，也是为了和原来的内容样式保持一致*/
 position: absolute;/*设置定位，其位置就是文本的右下角 */
 right: 0;bottom: 0;
```

方法二： 利用旧版弹性盒

步骤：

    给容器元素类型转换为 display:-webkit-box ;
    
    设置弹性盒子垂直排列 -webkit-box-orient:vertical ;
    
    控制要显示的行数 -webkit-line-clamp:数值 ；
    
    溢出隐藏 overflow:hidden ;

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* 多行文本溢出隐藏显示省略号方法二：
          兼容性写法,因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端
        */
        .box{
            width: 200px;
            /* height: 100px; 如果设置了高度，且高度超过文本显示行数，在第三行会正常出现省略号，但是三行之后的仍然正常显示*/
            background-color: pink;
            /* 设置高度是行高的倍数，防止文本露出一半 */
            line-height: 20px;
            /* 旧版弹性盒 */
            display: -webkit-box;
            /* 弹性盒子元素垂直排列 */
            -webkit-box-orient: vertical;
            /* 控制要显示的行数 */
            -webkit-line-clamp: 3;
            overflow: hidden;
        }
        
    </style>
</head>
<body>
    <div class="box">
        我是文本我是文本我是文本我是文我是文我是文我是文我是文我是文我是文我是是文本我是文本我是文本我是文本我是文本我是文本我是文本我是文本我是文本
    </div>
</body>
</html>
```



### 用 CSS 实现三角符号

```css
//上三角
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}

//下三角
#triangle-down {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-top: 100px solid red;
}


//左三角
#triangle-left {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-right: 100px solid red;
    border-bottom: 50px solid transparent;
}


//右三角
#triangle-right {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-left: 100px solid red;
    border-bottom: 50px solid transparent;
}


//左下三角
#triangle-bottomleft {
    width: 0;
    height: 0;
    border-bottom: 100px solid red;
    border-right: 100px solid transparent;
}


//右下三角
#triangle-bottomright {
    width: 0;
    height: 0;
    border-bottom: 100px solid red;
    border-left: 100px solid transparent;
}


//右上三角
#triangle-topright {
    width: 0;
    height: 0;
    border-top: 100px solid red;
    border-left: 100px solid transparent; 
}


//左上三角
#triangle-topleft {
    width: 0;
    height: 0;
    border-top: 100px solid red;
    border-right: 100px solid transparent;
}

```



### 九宫格布局

![九宫格布局](F:\360MoveData\Users\28018\Desktop\知识点图片\九宫格布局.png)



#### 基本布局样式

```css
<div class="box">
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>9</li>
    </ul>
</div>
.box {
    background: #e4f7fd61;
    border: 2px solid #0786ada1;
    border-radius: 8px;
}
 
ul {
    padding: 0; 
    margin: 0;
}
 
.box li {
    list-style: none;
    text-align: center;
    line-height: 200px;
    background: skyblue;
    border-radius: 8px;
    font-size: 20px;
    color: black;
}

```

方法一：

#### flex

使用 `flex` 布局实现需要注意一个点，就是需要用 `flex-wrap` 属性来使其换行。

```css
.box {
    width: 100%;
    overflow: hidden;
}
 
ul {
    width: 100%;
    height: 100%;
    display: flex;
    flex-wrap: wrap;
}
 
.box li {
    width: 30%;
    height: 30%;
    margin-right: 5%;
    margin-bottom: 5%;
}
 
.box li:nth-of-type(3n) {
    margin-right: 0;
}
 
.box li:nth-of-type(n+7) {
    margin-bottom: 0;
}
```

方法二：

#### float

使用 float 来实现需要注意一个点，浮动会造成浮动崩塌，因此可以设置 overflow: hidden; 把 box 设置成 BFC 来解决浮动崩塌。

```css
.box {
    width: 100%;
    overflow: hidden;
}
 
ul {
    width: 100%;
    height: 100%;
}
 
.box li {
    width: 30%;
    height: 30%;
    margin-right: 5%;
    margin-bottom: 5%;
    float: left;
}
 
.box li:nth-of-type(3n) {
    margin-right: 0;
}
 
.box li:nth-of-type(n+7) {
    margin-bottom: 0;
}
```



#### grid

```css
<div class="grid">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
    <div>7</div>
    <div>8</div>
    <div>9</div>
</div>
box {
    background: #e4f7fd61;
    border: 2px solid #0786ada1;
    border-radius: 8px;
}
 
.grid {
    display: grid;
    width: 100%;
    grid-template-rows: repeat(3, 1fr);
    grid-template-columns: repeat(3, 1fr);
    grid-gap: 5%;
    grid-auto-flow: row;
}
 
.grid>div {
    list-style: none;
    text-align: center;
    line-height: 200px;
    background: skyblue;
    border-radius: 8px;
    font-size: 20px;
    color: black;
}

```

#### table

使用表格来实现会存在一些缺陷，table 单元格之间的间隔是使用 border-spacing 属性来实现的，且不支持百分比的形式，而且单元格四周都有类似于 margin 的外边距的效果。

```css
<div class="box">
    <ul>
        <li>
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </li>
        <li>
            <div>4</div>
            <div>5</div>
            <div>6</div>
        </li>
        <li>
            <div>7</div>
            <div>8</div>
            <div>9</div>
        </li>
    </ul>
</div>

.box {
    width: 100%;
    overflow: hidden;
}
 
ul {
    width: 100%;
    height: 100%;
    display: table;
    border-spacing: 10px;
}
 
.box li {
    display: table-row;
}
 
.box li div {
    display: table-cell;
    text-align: center;
    border-radius: 10px;
}
```

### 单行多行文字隐藏显示省略号

#### 单行文字实现

文字单行隐藏：给它设定一个宽和高，对于文字超出部分进行隐藏，多余的部分用省略号来表示。

```css
text-overflow: ellipsis;
overflow: hidden ;
white-space: nowrap;
```

#### 多行文字实现

多行隐藏：多行隐藏的 div 的高度不能设置，让其自动 3 行隐藏即可。

```css
overflow : hidden;
-webkit-line-clamp: 3;
-webkit-box-orient: vertical;
display: -webkit-box;q
```

### 函数柯里化

#### 什么是函数柯里化

- 函数柯里化是指将使用多个参数的函数转化成一系列使用一个参数的函数的技术, 它返回一个新的函数, 这个新函数去处理剩余的参数

  ```javascript
  // ex:
  function add(a, b) {
      return a + b;
  }
  add(1, 2) // 3
  // 柯里化const addCurry = curry(add);addCurry(1)(2) // 3
  ```

  #### 函数柯里化的实现

  - 实现思路: 通过函数的 length 属性获取函数的形参个数, 形参的个数就是所需参数的个数

    ```javascript
    function curry(fn) {
      return _curry.call(this, fn, fn.length);
    }
    function _curry(fn, len, ...args) {
      return function(...params) {
        const _args = args.concat(params);
        if (_args.length >= len) {
          return fn.apply(this, _args);
        } else {
          return _curry.call(this, fn, len, ..._args);
        }
      }
    }
    // test
    function add (a, b, c, d) {
      return a + b + c + d;
    }
    const addCurry = curry(add);
    console.log(addCurry(1)(2)(3)(4)) // 10
    console.log(addCurry(1, 2, 3)(4)) // 10
    
    ```

    这段代码实现了一个名为 `curry` 的柯里化（Currying）函数，它接受一个多参数的函数作为输入，并返回一个新的可连续调用的函数。柯里化是指将一个多参数函数转换为一系列接受单个参数的函数的过程。

    `curry` 函数内部调用了 `_curry` 函数，并传入了原函数 `fn` 和原函数的参数长度 `fn.length`。

    `_curry` 函数是实际进行柯里化的辅助函数，它接收三个参数：

    1. `fn`：需要被柯里化的原始函数。
    2. `len`：原始函数期望接收的参数总数。
    3. `...args`：已经传递给新生成的柯里化函数的参数列表。

    在 `_curry` 函数内部定义了一个新的匿名函数，这个匿名函数可以接受任意数量的参数 `...params`，并将这些参数与之前已收集到的参数 `args` 合并成新的 `_args` 数组。

    接下来判断 `_args` 的长度是否达到了原始函数 `fn` 需要的参数总数 `len`，如果达到或超过，则使用 `apply` 方法调用原始函数 `fn` 并传入所有收集到的参数 `_args`，从而执行原函数并返回结果。

    如果没有达到参数总数，则继续返回一个新的柯里化函数实例，这次携带的参数是合并后的 `_args`。

    最后是测试部分：

    ```javascript
    
    function add (a, b, c, d) {
      return a + b + c + d;
    }
    
    const addCurry = curry(add);
    ```
    
    这里对 `add` 函数进行了柯里化处理，得到 `addCurry` 函数。由于 `add` 需要四个参数，所以可以通过连续调用 `addCurry` 函数四次来逐步传递参数，或者分两次调用传递所有参数。
    
    - `addCurry(1)(2)(3)(4)`：
      - 第一次调用：`addCurry(1)`，此时 `_args` 包含 `[1]`。
      - 第二次调用：`addCurry(1)(2)`，此时 `_args` 包含 `[1, 2]`。
      - 第三次调用：`addCurry(1)(2)(3)`，此时 `_args` 包含 `[1, 2, 3]`。
      - 第四次调用：`addCurry(1)(2)(3)(4)`，此时 `_args` 包含 `[1, 2, 3, 4]`，满足参数个数条件，因此调用原始 `add` 函数计算结果并返回 `10`。
    - `addCurry(1, 2, 3)(4)`：
      - 第一次调用：`addCurry(1, 2, 3)`，此时 `_args` 包含 `[1, 2, 3]`。
      - 第二次调用：`addCurry(1, 2, 3)(4)`，此时 `_args` 包含 `[1, 2, 3, 4]`，满足参数个数条件，因此调用原始 `add` 函数计算结果并返回 `10`。

#### 函数柯里化的作用

    参数复用: 本质上来说就是降低通用性, 提高适用性
        假如一个函数需要两个参数, 其中一个参数可能多次调用并不会发生更改, 比如商品打折的力度, 此时可以根据折扣进行封装
    提前返回
        经典实例: 元素绑定事件监听器, 区分 IE 浏览器的 attachEvent 方法
    延迟计算: 柯里化函数不会立即执行计算，第一次只是返回一个函数，后面的调用才会进行计算

#### 经典面试题

实现一个add方法，使计算结果能够满足如下预期：

```javascript
console.log(add(1)(2)(3)(4, 5)()) //15
console.log(add(1)(2)(3, 4, 5)()) //15
console.log(add(1)(2, 3, 4, 5)()) //15
function add1(...args) {
       //求和
       return args.reduce((a, b) => a + b)
   }
   function currying(fn, ...args) {
       return function (...rest) {
           if (rest.length) {
               return currying(fn, ...args, ...rest)
           } else {
               return fn.call(this, ...args)
           }
       }
   }
   let add = currying(add1)
   console.log(add(1)(2)(3)(4, 5)())  //15
   console.log(add(1)(2)(3, 4, 5)())  //15
   console.log(add(1)(2, 3, 4, 5)())  //15
```

### 图片懒加载

#### 滚动监听 + scrollTop + offsetTop + innerHeight

scrollTop：指网页元素被滚动条卷去的部分。

offsetTop：元素相对父元素的位置

innerHeight：当前浏览器窗口的大小。需要注意兼容性问题。

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        img {
            background: url('./img/loading.gif') no-repeat center;
            width: 250px;
            height: 250px;
            display: block;
        }
    </style>
</head>

<body>
    <img src="./img/pixel.gif" data-url="./img/1.jpeg">
    <img src="./img/pixel.gif" data-url="./img/2.jfif">
    <img src="./img/pixel.gif" data-url="./img/3.jfif">
    <img src="./img/pixel.gif" data-url="./img/4.jfif">
    <img src="./img/pixel.gif" data-url="./img/5.jfif">
    <img src="./img/pixel.gif" data-url="./img/6.webp">

    <script>
        let imgs = document.getElementsByTagName('img')
        // 1. 一上来立即执行一次
        fn()
        // 2. 监听滚动事件
        window.onscroll = lazyload(fn, true)
        function fn() {
            // 获取视口高度和内容的偏移量
            let clietH = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
            var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
            console.log(clietH, scrollTop);
            for (let i = 0; i < imgs.length; i++) {
                let x = scrollTop + clietH - imgs[i].offsetTop //当内容的偏移量+视口高度>图片距离内容顶部的偏移量时，说明图片在视口内
                if (x > 0) {
                    imgs[i].src = imgs[i].getAttribute('data-url'); //从dataurl中取出真实的图片地址赋值给url
                }
            }
        }
          // 函数节流
        function lazyload(fn, immediate) {
            let timer = null
            return function () {
                let context = this;
                if (!timer) {
                    timer = setTimeout(() => {
                        fn.apply(this)
                        timer = null
                    }, 200)
                }
            }
        }
    </script>
</body>

</html>
```

#### 滚动监听 + getBoundingClientRect()

```javascript
rectObject.top：元素上边到视窗上边的距离;

rectObject.right：元素右边到视窗左边的距离;

rectObject.bottom：元素下边到视窗上边的距离;

rectObject.left：元素左边到视窗左边的距离;

rectObject.width：元素自身的宽度;

rectObject.height：元素自身的高度;

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        img {
            background: url('./img/loading.gif') no-repeat center;
            width: 250px;
            height: 250px;
            display: block;
        }
    </style>
</head>

<body>
    <img src="./img/pixel.gif" data-url="./img/1.jpeg">
    <img src="./img/pixel.gif" data-url="./img/2.jfif">
    <img src="./img/pixel.gif" data-url="./img/3.jfif">
    <img src="./img/pixel.gif" data-url="./img/4.jfif">
    <img src="./img/pixel.gif" data-url="./img/5.jfif">
    <img src="./img/pixel.gif" data-url="./img/6.webp">

    <script>

        let imgs = document.getElementsByTagName('img')
        // 1. 一上来立即执行一次
        fn()
        // 2. 监听滚动事件
        window.onscroll = lazyload(fn, true)
        function fn() {
            // 获取视口高度和内容的偏移量
            let offsetHeight = window.innerHeight || document.documentElement.clientHeight
            Array.from(imgs).forEach((item, index) => {
                let oBounding = item.getBoundingClientRect() //返回一个矩形对象，包含上下左右的偏移值
                console.log(index, oBounding.top, offsetHeight);
                if (0 <= oBounding.top && oBounding.top <= offsetHeight) {
                    item.setAttribute('src', item.getAttribute('data-url'))
                }
            })
        }
        // 函数节流
        function lazyload(fn, immediate) {
            let timer = null
            return function () {
                let context = this;
                if (!timer) {
                    timer = setTimeout(() => {
                        fn.apply(this)
                        timer = null
                    }, 200)
                }
            }
        }


    </script>
</body>

</html>
```

#### intersectionObserve()

```javascript
IntersectionObserver : 浏览器原生提供的构造函数，接收两个参数

IntersectionObserver API 是异步的，不会与目标元素的滚动同步触发
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        img {
            background: url('./img/loading.gif') no-repeat center;
            width: 250px;
            height: 250px;
            display: block;
        }
    </style>
</head>

<body>
    <img src="./img/pixel.gif" data-url="./img/1.jpeg">
    <img src="./img/pixel.gif" data-url="./img/2.jfif">
    <img src="./img/pixel.gif" data-url="./img/3.jfif">
    <img src="./img/pixel.gif" data-url="./img/4.jfif">
    <img src="./img/pixel.gif" data-url="./img/5.jfif">
    <img src="./img/pixel.gif" data-url="./img/6.webp">

    <script>

        let imgs = document.getElementsByTagName('img')
        // 1. 一上来立即执行一次
        let io = new IntersectionObserver(function (entires) {
            //图片进入视口时就执行回调
            entires.forEach(item => {
                // 获取目标元素
                let oImg = item.target
                // console.log(item);
                // 当图片进入视口的时候，就赋值图片的真实地址
                if (item.intersectionRatio > 0 && item.intersectionRatio <= 1) {
                    oImg.setAttribute('src', oImg.getAttribute('data-url'))
                }
            })
        })
        Array.from(imgs).forEach(element => {
            io.observe(element)  //给每一个图片设置监听
        });
    </script>
</body>

</html>
```

### bind、apply、call 的用法

```javascript
1、相同点

    三个都是用于改变 this 指向；

    接收的第一个参数都是 this 要指向的对象；

    都可以利用后续参数传参。

2、不同点

    call 和 bind 传参相同，多个参数依次传入的；

    apply 只有两个参数，第二个参数为数组；

    call 和 apply 都是对函数进行直接调用，而 bind 方法不会立即调用函数，而是返回一个修改 this 后的函数。
```

#### call的用法

```javascript
fn.call(thisArg, arg1, arg2, arg3, ...)

调用 fn.call 时会将 fn 中的 this 指向修改为传入的第一个参数 thisArg；将后面的参数传入给 fn,并立即执行函数 fn。

let obj = {
        name: "xiaoming",
        age: 24,
        sayHello: function (job, hobby) {
            console.log(`我叫${this.name},今年${this.age}岁。我的工作是: ${job}，我的爱好是: ${hobby}。`);
        }
    }
    obj.sayHello('程序员', '看美女'); // 我叫xiaoming,今年24岁。我的工作是: 程序员，我的爱好是: 看美女。


    let obj1 = {
        name: "lihua",
        age: 30
    }
    // obj1.sayHello(); // Uncaught TypeError: obj1.sayHello is not a function
    obj.sayHello.call(obj1, '设计师', '画画'); // 我叫lihua,今年30岁。我的工作是: 设计师，我的爱好是: 画画。


手撕call的写法：

    第一参数接收 this 对象

    改变 this 指向：将函数作为传入 this 对象的方法

    展开语法，支持传入和调用参数列表

    调用并删除方法，返回结果

Function.prototype.myCall = function(_this, ...args) {
        if (!_this) _this = Object.create(null)
        _this.fn = this
        const res = _this.fn(...args)
        delete _this.fn
        return res
}
// 使用
function sum (a, b) {
        return this.v + a + b
}
sum.myCall({v: 1}, 2, 3) // 6

```



#### apply的用法

```javascript
apply(thisArg, [argsArr])
fn.apply 的作用和 call 相同：修改 this 指向，并立即执行 fn。区别在于传参形式不同， apply 接受两个参数，第一个参数是要指向的 this 对象，第二个参数是一个数组，数组里面的元素会被展开传入 fn , 作为 fn 的参数。

let obj = {
        name: "xiaoming",
        age: 24,
        sayHello: function (job, hobby) {
            console.log(`我叫${this.name},今年${this.age}岁。我的工作是: ${job}，我的爱好是: ${hobby}。`);
        }
    }
    obj.sayHello('程序员', '看美女'); // 我叫xiaoming,今年24岁。我的工作是: 程序员，我的爱好是: 看美女。
    let obj1 = {
        name: "lihua",
        age: 30
    }
    obj.sayHello.apply(obj1, ['设计师', '画画']); // 我叫lihua,今年30岁。我的工作是: 设计师，我的爱好是: 画画。

手撕 apply 的写法：

    第一参数接收 this 对象

    改变 this 指向：将函数作为传入 this 对象的方法

    第二个参数默认数组

    展开语法，支持调用参数列表

    调用并删除方法，返回结果

Function.prototype.myApply = function(_this, args = []) {
        if (!_this) _this = Object.create(null)
        _this.fn =this
        const res = _this.fn(...args)
        delete _this.fn
        return res
}
// 使用
function sum (a, b) {
        return this.v + a + b
}
sum.myApply({v: 1}, [2, 3]) // 6

```

#### bind 的用法

```javascript
bind(thisArg, arg1, arg2, arg3, ...)

fn.bind 的作用是只修改 this 指向，但不会立即执行 fn ；会返回一个修改了 this 指向后的 fn 。需要调用才会执行: bind(thisArg, arg1, arg2, arg3, ...)()。bind 的传参和 call 相同。

手撕bind的写法：

    第一个参数接收 this 对象

    返回函数，根据使用方式

Function.prototype.myBind = function(_this, ...args) {
        const fn = this
        return function F(...args2) {
                return this instanceof F ? new fn(...args, ...args2)
                : fn.apply(_this, args.concat(args2))
        }
}
//使用
function Sum (a, b) {
        this.v= (this.v || 0)+ a + b
        return this
}
const NewSum = Sum.myBind({v: 1}, 2)
NewSum(3) // 调用：{v: 6}
new NewSum(3) // 构造函数：{v: 5} 忽略 myBind 绑定this


```



### 手写 new

```javascript

    第一参数作为构造函数，其余参数作为构造函数参数

    继承构造函数原型创建新对象

    执行构造函数

    结果为对象，返回结果，反之，返回新对象
function myNew(...args) {
        const Constructor = args[0]
        const o = Object.create(Constructor.prototype)
        const res = Constructor.apply(o, args.slice(1))
        return res instanceof Object ? res : o
}
// 使用
function P(v) {
        this.v = v
}
const p = myNew(P, 1) // P {v: 1}

```

### promise 的用法

#### promise 相关概念

回调方法：就是将一个方法 func2 作为参数传入另一个方法 func1 中，当 func1 执行到某一步或者满足某种条件的时候才执行传入的参数 func2

Promise 是 ES6 引入的异步编程的新解决方案。

Promise 对象三种状态：初始化、成功、失败 pending-进行中、resolved-已完成、rejected-已失败

就好像，你跟你女朋友求婚，她跟你说她要考虑一下，明天才能给你答案，这就是承诺（promise）。同时，这也是一个等待的过程（pending），然后你就等，等到明天你女朋友给你答复，同意（resolved）或者拒绝（rejected），如果同意就准备结婚了，如果不同意就等下次再求婚，哈哈哈。

promise 是用来解决两个问题的：

```
回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象

promise 可以支持多个并发的请求，获取并发请求中的数据

这个 promise 可以解决异步的问题，本身不能说 promise 是异步的
```

#### promise 基本用法

```javascript
let p = new Promise((resolve, reject) => {      //    调用了Promise构造函数
  // 做一些事情
  // 然后在某些条件下resolve，或者reject
  if (/* 条件随便写^_^ */) {
    resolve()
  } else {
    reject()
  }
})

p.then(() => {                                 //    调用了promise实例的.then方法
    // 如果p的状态被resolve了，就进入这里
}, () => {
    // 如果p的状态被reject
})
```

```javascript
new Promise((resolve, reject) => {     // 这两个方法主要是用来修改状态的
    console.log("开始求婚。")
    console.log("。。。。。")
    console.log("考虑一下。")
    setTimeout(() => {
        if (isHandsome || isRich) { // 当我们调用 resolve 函数的时候，Promise 的状态就变成 resolved
            resolve('我同意！')
        } else { // 当我们调用 reject 函数的时候，Promise 的状态就变成 reject
            reject("拒绝：我们八字不合")
        }
    }, 2000)
})
// 如果一个 promise 已经被兑现（resolved）或被拒绝（rejected），那么我们也可以说它处于已敲定（settled）状态。

```

#### Promise.prototype.then 方法

```javascript
// 调用 Promise 对象的then方法，两个参数为函数
p.then(function(value){ // 成功
     console.log(value);
}, function(season){ // 失败
     console.log(season);
});

getNumber()
.then(function(data){
    console.log('resolved');
    console.log(data);
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);
});

```

#### Promise.prototype.catch 方法

catch() 的作用是捕获 Promise 的错误

其实它和 then 的第二个参数一样，用来指定 reject 的回调，用法是这样：

在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js，而是会进到这个 catch 方法中。请看下面的代码：

```javascript
promise.then(
    () => { console.log('this is success callback') }
).catch(
    (err) => { console.log(err) }
)
```

效果和写在 then 的第二个参数里面一样。不过它还有另外一个作用：在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js ，而是会进到这个 catch 方法中。请看下面的代码：

<img src="F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240320112441657.png" alt="image-20240320112441657" style="zoom: 50%;" />

#### Promise.all() 方法

有了 all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。

「谁跑的慢，以谁为准执行回调」

Promise 的 all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调

```javascript
Promise
.all([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});

//手写实现
const myPromiseAll =(arr)=>{
     let result = [];
     return new Peomise ((resolve,reject)=>{
         for (let i=0;i<arr.length;i++){
             arr[i].then(data=>{
                 result[i] = data;
                 if(result.length === arr.length)//所有的都成功才执行成功的回调
                 {
                     resolve(result)
                   }//这里可以用计数器更好点
             },reject)//有一个失败则执行失败的回调
         }
     })
}
```

#### Promise.race()  方法

「谁跑的快，以谁为准执行回调」

1 秒后 runAsync1 已经执行完了，此时then里面的就执行了

在 then 里面的回调开始执行时，runAsync2() 和 runAsync3() 并没有停止，仍旧再执行。

于是再过 1 秒后，输出了他们结束的标志。

```javascript
//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
            resolve(img);
        }
        img.src = 'xxxxxx';
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});



Promise.race()手撕代码用法：
function promiseRace(promises) {
     if (!Array.isArray(promises)) {
         throw new Error("promises must be an array")
     }
    return new Promise(function (resolve, reject) {
         promises.forEach(p =>
             Promise.resolve(p).then(data => {
                 resolve(data)
                 }, err => {
                 reject(err)
             })
         )
     })
 }
```

#### Promise.any() 方法

```javascript
any() 方法还接受一组 promise 作为参数，并将它们打包到新的 promise 对象中。只要一个参数实例处于成功状态，新的 promise 就处于成功状态。参数实例均处于拒绝状态。新承诺处于拒绝状态。

Promise.any(promises).then(
    (first) => {
    // Any of the promises was fulfilled.
    },(error) => {
    // All of the promises were rejected.
    }
);
```

```javascript
function myPromiseAny(arr) {
    if (!Array.isArray(arr)) {
        throw new Error('arguments must be a array');
    }
    let rejectCount = 0;
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arr.length; i++) {
            arr[i].then(data => {
                resolve(data);
            }, () => {
                rejectCount++;
                if (rejectCount === arr.length) {
                    reject(new AggregateError('All promises were rejected'))
                }
            });
        }
    })
}
```

#### Promise.prototype.finally() 方法

```javascript
finally 方法用于指定无论 Promise 对象的最终状态如何，都将执行 finally。Finally 不接受参数。Finally 独立于先前的执行状态，不依赖于先前的运行结果。

    const promise4 = new Promise((resolve, reject) => {
      console.log(x + 1);});
    promise4
      .then(() => {
        console.log("你好");}).catch((err) => {
        console.log(err);}).finally(() => {
        console.log("finally");});// finally
```

### 解析 URL

```javascript
js解析url，就是将如下url： const url = https://www.baidu.com/m?f=8&ie=utf-8&rsv_bp=1&tn=monline_3_dg&wd=session 解析为：image.png

```

![1670548660-IOrLAw-image](F:\360MoveData\Users\28018\Desktop\知识点图片\1670548660-IOrLAw-image.png)

#### 利用 splice 分割 + 循环依次取出

```javascript
    解析 url 并将其存储在新对象中，因此初始化一个空对象，让 obj = {}

    首先判断 url 后面是否有 ？传参, 如果没有 ? 传参，直接返回空对象

if (url.indexOf('?') < 0) return obj

    用 ？ 进行参数分割 let arr = url.split('?')
function queryURLparams(url) {
    let obj = {}
    if (url.indexOf('?') < 0) return obj
    let arr = url.split('?')
    url = arr[1]
    let array = url.split('&')
    for (let i = 0; i < array.length; i++) {
        let arr2 = array[i]
        let arr3 = arr2.split('=')
        obj[arr3[0]] = arr3[1]
    }
    return obj

}
console.log(queryURLparams(url));
 var url = "https://www.baidu.com/m?f=8&ie=utf-8&rsv_bp=1&tn=monline_3_dg&wd=session"; 
  function getURL(url){
      let str = url.split("?")[1];
      let str1 = str.split("&");
      let obj = {};
      for(let i = 0; i<str1.length; i++){
          let str2 = str1[i].split("=");
          let key = str2[0];
          let value = str2[1];
          obj[key] = value;

      }
      return obj;
  }
  console.log(getURL(url))
```

#### 正则 + arguments

```javascript
    正则匹配规则 /([^?=&]+)=([^?=&]+)/g

    利用 replace 替换

    用伪数组进行键值对拼接

function queryURLparamsRegEs5(url) {
    let obj = {}
    let reg = /([^?=&]+)=([^?=&]+)/g
    url.replace(reg, function() {
        obj[arguments[1]] = arguments[2]
    })
    return obj
}
```

####  正则 + ..arg

```javascript
    就是用 ES6 的 …arg

    其实和 arguments 差不多 ，就是 arguments 是伪数组，…arg 是真数组

function queryURLparamsRegEs6(url) {
    let obj = {}
    let reg = /([^?=&]+)=([^?=&]+)/g
    url.replace(reg, (...arg) => {
        obj[arg[1]] = arg[2]
    })
    return obj
}
```

### 跨域

跨域（Cross-Origin）是Web开发中的一种安全策略，主要由浏览器实施，基于“同源策略”（Same-Origin Policy,  SOP）。同源策略规定，出于安全原因，一个域（domain）内的文档或脚本只能请求或操作来自同一域的资源，这里的同源指的是协议、域名、端口均相同。换句话说，当一个网页尝试通过JavaScript发起HTTP请求访问另一个域上的资源时，如果协议、域名、端口有任何一项不匹配，则浏览器会阻止这个请求，这就是所谓的“跨域”。

**出现跨域的原因**：

- 防止恶意网站通过脚本读取另一可信网站的敏感数据（例如cookie、localStorage等）。
- 保护用户的隐私和安全，防止跨站请求伪造（Cross-Site Request Forgery, CSRF）等攻击。

**解决跨域的方法**：

1. **CORS (Cross-Origin Resource Sharing)**： CORS是W3C标准，服务器端通过在响应头中添加`Access-Control-Allow-Origin`等相关字段，允许指定来源的跨域请求。客户端（浏览器）在收到这些响应头后，根据其中的指示决定是否允许此次跨域请求。
2. **JSONP (JSON with Padding)**： JSONP利用<script>标签不受同源策略限制的特点，通过动态创建script标签，请求跨域服务器提供的JSONP格式的数据。服务器返回的不再是JSON，而是一个可以直接调用的函数包裹着JSON数据。
3. **WebSocket**： WebSocket协议可以在建立连接时允许跨域，服务器需要设置响应头允许指定源的WebSocket连接。
4. **降级到非AJAX方式**： 如果不需要实时交互，可以通过表单提交（form POST）、图片ping（img标签加载图片资源）等方式绕过同源策略，不过这种方式一般不适合复杂的数据交换。
5. **反向代理**： 在服务器端设置反向代理，使得原本跨域的请求变成同源请求。例如，前端应用和后端API服务器不在同一域名下时，可以在前端服务器上配置反向代理，将请求转发至API服务器。
6. **Nginx等服务器配置**： 通过调整服务器配置文件，允许特定的跨域请求。

### HTML5 新特性有哪些

```javascript
语义化标签

音视频处理API(audio,video)

canvas / webGL

拖拽释放(Drag and drop) API

history API

requestAnimationFrame

地理位置(Geolocation)API

webSocket

web存储 localStorage、SessionStorage

表单控件，calendar、date、time、email、url、search
```

### HTTP 状态码

    1xx：指示信息类，表示请求已接受，继续处理（临时响应）
    
    2xx：指示成功类，表示请求已成功接受
    
    3xx：指示重定向，表示要完成请求必须进行更进一步的操作
    
    4xx：指示客户端错误，请求有语法错误或请求无法实现
    
    5xx：指示服务器错误，服务器未能实现合法的请求

常见状态码

【403】表示【服务器拒绝执行客户端的请求】

【404】表示【服务器找不到客户端所请求的资源（网页）】

【304】表示【所请求的资源并未修改（命中协商缓存）

### HTML5 语义化的优点:

    在没CSS样式的情况下，页面整体也会呈现很好的结构效果
    
    代码结构清晰，易于阅读，
    
    利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
    
    有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重

==缓存过期后向服务器发起请求验证缓存是否有效，有效的话则返回304==。304多出现在对于静态资源的请求上面。对于静态资源来说：

当浏览器第一次发起请求时（请求头中没有If-Modified-Since），server会在响应中告诉浏览器这个资源最后修改的时间（响应头中的Last-Modified）。当你再次请求这个资源时，浏览器会询问server这个资源有没有被修改（请求头中If-Modified-Since）。

如果资源没有被修改，server返回304状态码，浏览器使用本地的缓存文件。

### 数组的常用方法有哪些?

```javascript
join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符

push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)

pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）

shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined

unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）

slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变

splice(start,deleteCount,val1,val2,…):从start位置开始删除deleteCount项，并从该位置起插入。（修改原数组）

fill()：使用特定值填充数组中的一个或多个元素(修改原数组)

filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组

concat()：可以将两个数组合并在一起，如果是使用ES6语法也可以用扩展运算符…来代替

indexOf()：返回当前值在数组中第一次出现位置的索引

lastIndexOf()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。

every()：判断数组中每一项是否都符合条件

some()：判断数组中是否存在满足的项

includes()：判断一个数组是否包含指定的值

sort(orderfunction):按指定的参数对数组进行排序(修改原数组)

reverse()：将数组反序(修改原数组)

forEach()：循环遍历数组每一项（没有返回值）

map()：循环遍历数组的每一项（有返回值）

copyWithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）

find(): 返回第一个匹配的值，并停止查找

findIndex(): 返回第一个匹配值的索引，并停止查找

toLocaleString()、toString():将数组转换为字符串

flat()、flatMap()：扁平化数组

entries() 、keys() 、values():遍历数组
```

### CSS 选择器及优先级

选择器

    id选择器(#myid)
    
    类选择器(.myclass)
    
    属性选择器(a[rel="external"])
    
    伪类选择器(a:hover, li:nth-child)
    
    标签选择器(div, h1,p)
    
    相邻选择器（h1 + p）
    
    子选择器(ul > li)
    
    后代选择器(li a)
    
    通配符选择器(*)

优先级：

    !important
    
    内联样式（1000）
    
    ID选择器（0100）
    
    类选择器/属性选择器/伪类选择器（0010）
    
    元素选择器/伪元素选择器（0001）
    
    关系选择器/通配符选择器（0000）

带!important 标记的样式属性优先级最高； 样式表的来源相同时： !important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性

### 强缓存和协商缓存

浏览器缓存的特点：

    浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
    
    浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。

协商缓存

    协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。
    
    协商缓存主要有以下两种情况：
        协商缓存生效，返回304
        协商缓存失效，返回200和请求结果结果

### == 和 === 区别

    == 和 === 区别
    
    == 表示相等 （值相等）
    
    ===表示恒等（类型和值都要相等）
    
    js在比较的时候如果是 == 会先做类型转换，再判断值得大小，如果是===类型和值必须都相等。

2.== === 和 Object.is() 区别

    == 相等，如果两边类型不一致，进行隐式转换后，再比较。+0 和 -0 相等， NaN 不等于任何数
    
    === 严格相等，如果类型不一致，就不相等。 +0 和 -0 相等， NaN 不等于任何数
    
    Object.is() 严格相等，+0 和 -0 不相等， NaN 等于自身

switch中的匹配就是===不会进行隐式类型转换

### script 标签放在 header 里和放在 body 底部里有什么区别？

放在 header 中

你能看到 html 第一时间被加载进来，但页面 body 内容迟迟没有渲染出来。因为在等待 header 标签中 script 脚本的加载，3 秒后，整个页面渲染完成。

放在 body 底部

这次 html 内容第一时间渲染完成，随后等待 js 的加载。

总结：

脚本会阻塞页面的渲染，所以推荐将其放在 body 底部，因为当解析到 script 标签时，通常页面的大部分内容都已经渲染完成，让用户马上能看到一个非空白页面。

另外你能看到多个脚本之间都是异步向服务器请求，他们之间不互相依赖，最终只等待 3 秒，而非 3+3+3 秒。

```javascript
script 标签

当浏览器解析DOM时，遇到<script>标签会暂停DOM的解析，转而去执行JavaScript代码。如果脚本是外部的还会先下载，再执行，所以JavaScript会再一定程度上阻塞DOM树的构建。
defer

defer 表示在加载后续HTML文档的同时一起加载JavaScript，当JavaScript加载完成后并不执行，只有当HTML元素解析完成后才会执行JavaScript脚本。

<script defer src='index.js'></script>

async

async 表示在外部JavaScript下载时 不会在阻塞HTML的解析了，但是脚本的执行依旧会阻塞HTML的解析。

<script async src='index.js'></script>

link 标签
preload

preload 是一种预加载，告知浏览器需要提前加载一个资源，当资源被使用时会立即执行。

<link rel="preload" href="main1.js" as="script">
<link rel="preload" href="style1.css" as="style">

    as 属性会指定预加载内容的类型。

prefetch

prefetch 是利用浏览器空闲时间进行资源加载的一种机制，通常可用于加载非首页内容的资源。

<link rel="prefetch" href="/path/to/style.css" as="style">
```

### CSS3 新特性

    过渡

/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/ 
transition：all,.5s

    动画

//animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）
/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/
animation: logo2-line 2s linear;

    形状转换

//transform:适用于2D或3D转换的元素
//transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)
transform:translate(30px,30px);
transform:rotate(30deg);
transform:scale(.8);

    选择器:nth-of-type()
    
    阴影 文字阴影: text-shadow: 2px 2px 2px #000;(水平阴影，垂直阴影，模糊距离，阴影颜色) 盒子阴影: box-shadow: 10px 10px 5px #999
    
    边框 border-image: url(border.png);
    
    背景
    
    文字
    
    渐变
    
    Filter（滤镜）
    
    弹性布局、栅格布局、多列布局
    
    媒体查询

### JS 中的 8 种数据类型及区别

在JS中，我们已知有5种基本数据类型：String、Number、Boolean、Undefined、Null。

当ES6问世，新增基本数据类型：Symbol(ES6) BigInt(ES10)

一、Number类型：

专门保存数字的类型,可用于进行数学计算等的数值.

二、String类型:

专门用来保存字符串的类型;" ",用来存储字符串类型的文本.

三、Boolean类型:

专门用来保存真或者假的类型,值二选一,true or false

四、undefined类型:

只有一个值undefined,没有赋值的变量的默认值.

五、null类型:

不知向任何地址,手动赋值,清空内容等....

六、object / Symbol

Symbol在ES6中新定义，符号类型是唯一的并且不可修改。Symbol 指的是独一无二的值。

### GET 与 POST 的区别

1.针对数据操作的类型不同.GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。

2.参数大小不同. GET请求在URL中传送的参数是有长度的限制，而POST没有限制

3.安全性不同. GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全

4.浏览器回退表现不同 GET在浏览器回退时是无害的，而POST会再次提交请求

5.浏览器对请求地址的处理不同 GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置

6.浏览器对响应的处理不同GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留

### CSS 盒子模型

CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。 在标准的盒子模型中，width 指 content 部分的宽度。 在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。

故在计算盒子的宽度时存在差异：

### WebSocket

实现原理： 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。

Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。

Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。

优点：
1.全双工通信：WebSocket允许客户端和服务器之间同时发送和接收数据，而无需等待对方的响应。这种实时双向通信使得WebSocket特别适合于需要及时更新的应用，如聊天应用、在线游戏等。

2.低延迟：由于WebSocket建立在单个TCP连接上（长连接，只连接一次），避免了HTTP请求-响应模型中频繁的连接建立和关闭，因此具有较低的延迟，能够更快地传输数据。

3.轻量级：第一次连接时需要携带请求头，后面数据通信都不需要带请求头。通信过程中的数据帧格式也比较简单，因此在网络传输中消耗的资源较少，可以更有效地利用带宽。

4.跨域支持：与传统的Ajax请求不同，WebSocket协议支持跨域通信，可以在不同域之间建立连接并进行数据传输，为开发跨域应用提供了更便利的方式。

缺点：
1.长连接需要后端处理业务的代码更稳定，推送消息相对复杂；

2.兼容性差：WebSocket 只支持 IE10 及其以上版本。

3.维护成本高：服务器长期维护长连接需要一定的成本。

【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】

### BFC（块级格式上下文）

```javascript
BFC的概念

BFC 是 Block Formatting Context的缩写，即块级格式化上下文。BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。

BFC的原理布局规则

    内部的Box会在垂直方向，一个接一个地放置

    Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠

    每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反

    BFC的区域不会与float box重叠

    BFC是一个独立容器，容器里面的子元素不会影响到外面的元素

    计算BFC的高度时，浮动元素也参与计算高度

    元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的Formatting Context。

如何创建BFC？

    根元素，即HTML元素

    float的值不为none

    position为absolute或fixed

    display的值为inline-block、table-cell、table-caption

    overflow的值不为visible

BFC的使用场景

    去除边距重叠现象

    清除浮动（让父元素的高度包含子浮动元素）

    避免某元素被浮动元素覆盖

    避免多列布局由于宽度计算四舍五入而自动换行
```

### 数据类型判断 instanceof 和 typeof 的区别

```javascript
1.typeof

console.log(typeof 1);               // number
console.log(typeof true);            // boolean
console.log(typeof 'mc');            // string
console.log(typeof Symbol)           // function
console.log(typeof function(){});    // function
console.log(typeof console.log); // undefined
console.log(typeof []);              // object 
console.log(typeof {});              // object
console.log(typeof null);            // object
console.log(typeof undefined);       // undefined
console.log(typeof BigInt) // function

优点：能够快速区分基本数据类型

缺点：不能将Object、Array和Null区分，都返回object

2.instanceof

console.log(1 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true

优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象

缺点：Number，Boolean，String基本数据类型不能判断

3.Object.prototype.toString.call()

var toString = Object.prototype.toString;
console.log(toString.call(1));      //[object Number]
console.log(toString.call(true));   //[object Boolean]
console.log(toString.call('mc'));   //[object String]
console.log(toString.call([]));     //[object Array]
console.log(toString.call({}));     //[object Object]
console.log(toString.call(function(){})); //[object Function]
console.log(toString.call(undefined));  //[object Undefined]
console.log(toString.call(null)); //[object Null]

优点：精准判断数据类型

缺点：写法繁琐不容易记，推荐进行封装后使用
```

### 隐藏页面元素的方法

```javascript
1.opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的

2.visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）

3.display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）

重排重绘
重排（回流）：因为节点的尺寸，布局等改变而需要重新构建渲染树（重新布局），这种重新构建的现象就是回流
重绘：浏览器根据节点的新属性重新绘制，呈现新的外观。改变元素外观如color可以触发重绘
重排一定引起重绘，重绘不一定引起重排
display: none 元素不显示，并且会触发重排和重绘。当一个元素的display:none时，它会从文档流中移除，其他元素会重新布局以填补该元素的空白位置，这就是回流。同时，由于元素不再显示，浏览器会将其对应的像素从屏幕上移除，这就是重绘。
visibility: hidden; 元素不显示，只会触发重绘。

```

### DNS 协议是什么？

DNS服务器通过多层查询将解析域名为IP地址

域名劫持：是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。

### Flex 布局

```javascript

Flex 是 Flexible Box 的缩写，意为"弹性布局",用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。

容器的属性：

    flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;

    flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;

    flex-flow： .box { flex-flow: || ; }

    justify-content：对其方式，水平主轴对齐方式

    align-items：对齐方式，竖直轴线方向

    align-content

项目的属性（元素的属性）：

    order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0

    flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大

    flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小

    flex-basis 属性：定义了在分配多余的空间，项目占据的空间。

    flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。

    align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖

    align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局

```

### 闭包

```javascript

闭包的特性：
        闭包让你可以在一个内层函数中访问到其外层函数的作用域 函数嵌套函数
        延长变量的生命周期 在内存中维持一个变量

            一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的

    闭包形成的条件：
        函数的嵌套
        内部函数引用外部函数的局部变量，延长外部函数的变量生命周期

    闭包缺点：会导致函数的变量一直保存在自己内存中，过多的闭包可能会导致内存泄漏

    闭包应用场景

闭包的两个场景，闭包的两大作用：保存/保护。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。
```

### Rem布局

```javascript
首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;
那么（1rem = 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。

优点：可以快速适用移动端布局，字体，图片高度

缺点：

①目前 ie 不支持，对 pc 页面来讲使用次数不多；

②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；

③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。
```

### 浏览器渲染

```javascript

    通过Html Parser 将html 转成Dom树
    同时通过Css Parser 将css 转成Style Rules规则树
    计算Dom树的每个节点的具体样式（Attachment）
    创建渲染布局树，将Dom树中可见节点添加至布局树，计算节点渲染到页面的坐标位置（Layout）
    通过布局树，进行分层（根据定位属性、透明属性、transform属性、clip属性等）生产图层树
    将不同图层进行绘制，转交给合成线程处理，最终产生页面，显示到浏览器页面中

```

### 百分比布局

```javascript
缺点:
（1）计算困难 
（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。

精度问题：因为百分比不是固定的数值，因此会造成布局偏差，特别是当容器的尺寸发生变化时。
兼容问题：不同的浏览器对百分比支持情况不一，这意味者有些浏览器可能无法很好的支持百分比布局。

```



### 重绘与重排区别

```javascript
    重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。

    重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,叫做重绘。表现为某些元素的外观被改变

『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。

如何触发重排和重绘？

    添加、删除、更新DOM节点

    通过display: none隐藏一个DOM节点-触发重排和重绘

    通过visibility: hidden隐藏一个DOM节点-只触发重绘

    移动或者给页面中的DOM节点添加动画

    添加一个样式表，调整样式属性

    用户行为，例如调整窗口大小，改变字号，或者滚动。

如何避免重绘或者重排？

    集中改变样式，不要一条一条地修改 DOM 的样式。

    不要把 DOM 结点的属性值放在循环里当成循环里的变量。

    尽量只修改position：absolute或fixed元素，对其他元素影响不大

    提升为合成层

    优点：
        合成层的位图，会交由 GPU 合成，比 CPU 处理要快
        当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
        对于 transform 和 opacity 效果，不会触发 layout 和 paint

方式：是使用 CSS 的 will-change 属性
```

### 行内元素、块级元素、空元素

![image-20240323223844616](F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240323223844616.png)

### 浮动布局

```javascript
浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。

优点

这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题

缺点

最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。

```

### Cookie、sessionStorage、localStorage 的区别

```javascript
Cookie、sessionStorage 和 localStorage 是在客户端存储数据的三种不同方式，它们之间有以下区别：

存储数据的生命周期：

Cookie： Cookie 是存储在客户端的小型文本文件，它们的生命周期可以通过设置过期时间来控制，可以是会话级的（即浏览器关闭时失效）或持久性的（在指定的日期之前有效）。
sessionStorage： sessionStorage 存储在浏览器的会话存储中，数据在当前会话结束时（即浏览器窗口关闭）被清除，因此数据只在单个会话期间有效。
localStorage： localStorage 也是存储在客户端的持久性存储中，数据在用户关闭浏览器后仍然保留，直到被显式删除或过期。
存储容量：

Cookie： 单个 Cookie 的存储容量通常受到限制，一般为几 KB 到几 MB 不等，且每个域名下的 Cookie 数量也有限制。
sessionStorage 和 localStorage： 它们的存储容量通常比 Cookie 更大，一般在 5 MB 到 10 MB 左右，但不同浏览器的限制可能有所不同。
与服务器的通信：

Cookie： 每次向同一服务器发起 HTTP 请求时，都会将与该域相关的 Cookie 信息发送给服务器，因此可以用于跟踪用户的状态和行为。
sessionStorage 和 localStorage： 存储在这两个地方的数据不会自动发送到服务器，因此只能用于客户端存储。
访问权限：

Cookie： 可以通过设置 Cookie 的 HttpOnly 属性来保护 Cookie 不被客户端脚本访问，只能在 HTTP 请求中传输给服务器。
sessionStorage 和 localStorage： 存储在其中的数据可以通过客户端脚本直接访问和修改。
应用场景：

Cookie： 通常用于跟踪用户的身份认证状态、记录用户偏好设置等。
sessionStorage 和 localStorage： 通常用于临时或持久性存储用户数据，例如在表单页面之间传递数据或缓存应用程序的状态。
综上所述，这三种客户端存储方式各有优劣，应根据具体的需求和场景选择合适的方式。

```

### em/px/rem/vh/vw 区别?

```javascript
1、px，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的

2、em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）em 的值并不是固定的，em 会继承父级元素的字体大小

3、rem，相对单位，相对的只是HTML根元素font-size的值

4、vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，vh则为窗口的高度

    vw,vh视口单位与%的区别？

1、% 是基于【父元素】的宽度/高度的百分比，vw，vh是根据视窗的宽度/高度的百分比。

2、视口单位优势在于【vh】能够直接获取高度，而用 % 在没有设置 body 高度情况下，是无法正确获得可视区域的高度。
```

### 输入 URL 回车后发生了什么?

```javascript
1.合成URL
用户输入URL，浏览器会自动判断用户输入的信息是搜索内容还是URL，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL地址；如果用户输入的是URL，就在这段内容上加上协议合成符合规则的URL。

2.DNS域名解析
合成URL后，先用递归的方式在本地查找，如果找不到，就用本地DNS服务器设置的转发器进行查询，若为转发器查询，则用迭代的方式从域名服务器上进行查询。

3.建立TCP连接，三次握手
客户端向服务器端发送连接请求；服务器端收到客户端的连接请求，回应一个处于响应状态的信息；客户端收到服务器端回应的信息，客户端再发送一个确认连接的请求，双方都处于建立连接的状态。

4.发送HTTP请求，服务器处理请求，响应结果
TCP建立连接后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求；服务器收到请求，对请求的内容进行解析，解析完毕后返回相应的状态码。

5.关闭TCP连接，四次挥手

挥手操作可以是客户端发起，也可以是服务器端发起。
1.客户端向服务器端发送一个关闭连接请求，并处于关闭等待状态；
2.服务器端收到了客户端发送的关闭请求，回应一个确认信息，表示我“同意”你的关闭请求；
3.服务器端也向客户端发送一个关闭连接请求，同时进入最终确认状态；
4.客户端收到服务器端发来的响应信息，然后向服务器端发送确认信息并进入等待状态中，服务器收到客户端的确认信息后就关闭连接，此时客户端等待时间超时后依然没有收到回复则证明服务端已关闭，那客户端也可以关闭连接了。

6.浏览器渲染

从服务器获取到的数据进行解析，HTML解析器将HTML先生成DOM树，同时CSS解析器将css样式表成CSSOM，然后二者合并生成Render Tree（渲染树），然后渲染引擎根据Render Tree计算好每个节点的信息，最后根据计算好的信息绘制整个页面。
```

### html dom 的 event 事件

```javascript
    onblur：失去焦点

    onfocus:元素获得焦点。

    加载事件：

    ​ onload：一张页面或一幅图像完成加载。

​ 4. 鼠标事件：

    ​ onmousedown 鼠标按钮被按下。
    ​ onmouseup 鼠标按键被松开。
    ​ onmousemove 鼠标被移动。
    ​ onmouseover 鼠标移到某元素之上。
    ​ onmouseout 鼠标从某元素移开。

​ 5. 键盘事件：

    ​ onkeydown 某个键盘按键被按下。
    ​ onkeyup 某个键盘按键被松开。
    ​ onkeypress 某个键盘按键被按下并松开。

​ 6. 选择和改变

    ​ onchange 域的内容被改变。
    ​ onselect 文本被选中。

​ 7. 表单事件：

    ​ onsubmit 确认按钮被点击。
    ​ onreset 重置按钮被点击。
```

### AJAX原理

```javascript
创建 XMLHttpRequest 对象：这是Ajax的核心对象，用于在后台与服务器交换数据而不必重新加载整个页面。

通过 XMLHttpRequest 的 open() 方法建立与服务器的连接，并指定请求的类型（GET、POST等）和URL。

构建请求所需的数据内容，可以是参数或者请求体。然后使用 XMLHttpRequest 的 send() 方法将请求发送给服务器。

监听 XMLHttpRequest 的 onreadystatechange 事件，以便在通信状态发生改变时进行处理。通常会检查 readyState 和 status 属性来确定请求的状态。

当 readyState 为 4 且 status 为 200 时，表示请求成功，可以从 XMLHttpRequest 对象的 responseText 或 responseXML 属性中获取服务器返回的数据结果。

使用获取到的数据结果，通过JavaScript操作DOM来更新页面的特定部分。
```

### JS 中 this 的情况

```javascript
1、普通函数调用：通过函数名()直接调用：this指向全局对象window（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a =’aaa’; this.a是undefined）

2、构造函数调用：函数作为构造函数，用new关键字调用时：this指向新new出的对象

3、对象函数调用：通过对象.函数名()调用的：this指向这个对象

4、箭头函数调用：箭头函数里面没有 this ，所以永远是上层作用域this（上下文）

5、apply和call调用：函数体内 this 的指向的是 call/apply 方法第一个参数，若为空默认是指向全局对象window。

6、函数作为数组的一个元素，通过数组下标调用的：this指向这个数组

7、函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等）
```

### 前端性能优化

```javascript
1、减少http请求数；2、图片优化；3、使用CDN；4、开启GZIP；5、构建优化；

1. 减少http请求数

1）合并图片。当图片较多时，可以合并为一张大图，从而减少http请求数。

2）合并压缩css样式表和js脚本。

一般我们会把css样式表文件放到文件的头部。比如，放到标签中，这样可以让CSS样式表尽早地完成下载。对应js脚本文件，一般我们把他放到页面的尾部。

3）充分利用缓存。

2. 图片优化
图片优化

1）尽可能的使用PNG格式的图片，它相对来说体积较小。（png比jpg还大，多了一个透明通道，如果无透明最好用jpg，如果支持可以考虑用webp格式）

1）尽可能的使用PNG格式的图片，它相对来说体积较小。

2）图片的延迟加载，也叫做懒加载。

3. 使用CDN

CDN即内容分发网络，可以使用户就近取得所需内容，解决网络拥挤的状况，提高用户访问网站的响应速度。

4. 开启GZIP

GZIP即数据压缩，用于压缩使用Internet传输的所有文本资源。开启GZIP的方法很简单，到对应的web服务配置文件中设置一下即可。以Apache为例，在配置文件httpd.conf中添加。

5. 构建优化

使用 Tree-shaking、Scope hoisting、Code-splitting

Tree-shaking是一种在构建过程中清除无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。
```

### 如何理解 CDN？实现原理？

```javascript
内容分发网络：
构建在现有网络基础之上的智能虚拟网络，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

CDN 的关键技术主要有内容存储和分发技术。简单来讲，CDN就是根据用户位置分配最近的资源。

应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡。

CNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键。
```

### 伪元素、伪类区别

```javascript
1.定义

    伪类---- 点击操作 ----是一个以冒号作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类。
    伪元素 ---- after、before ----用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过::before来在一个元素前添加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际不在文档树中。

2.区别 – 他们是否创造了新的元素

    伪类是通过在元素选择器上加入伪类改变元素状态。
    伪元素通过对元素的操作进行对元素的改变。
```

### 列举 ES6 的新特性

let 和 const
Promise
Class
箭头函数
函数参数默认值
模版字符串
解构赋值
展开语法
构造数组，调用函数时，将 数组表达式 或 string 在语法层面展开
对象属性缩写
键名和键值相同
函数省略 function
模块化



### 什么是原型 ? 什么是原型链 ？

JavaScript 一种基于原型的语言——每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。
原型关系：

    每个 class都有显示原型 prototype
    每个实例都有隐式原型 proto
    实例的 proto 指向对应 class 的 prototype

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 proto, 该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而 Object 原型对象用 Object.prototype.__ proto__ = null 表示原型链顶端。如此形成了js的原型链继承。

特点:  JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

### 什么是作用域 ? 什么是作用域链 ?

创建函数的时候，已经声明了当前函数的作用域 ==>当前创建函数所处的上下文。

    定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成
    
    全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。
    函数作用域：在固定的代码片段才能被访问
    
    作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
    作用域链：一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

### 对比 import、import() 和 requrie 的区别

![image-20240323231004148](F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240323231004148.png)

### 走迷宫用dfs还是bfs

在解决走迷宫问题时，深度优先搜索（DFS）和广度优先搜索（BFS）都是可行的算法，但它们各自有其特点和适用场景。具体选择使用哪种算法取决于你的需求和对解空间的期望。

1. **深度优先搜索（DFS）**：
   - 原理：沿着一条路径尽可能深地探索，直到找到出口或者路径走不通（遇到死胡同或已访问过的位置）才回溯到上一个分岔点，尝试其他路径。
   - 优点：
     - 空间效率相对较高，因为它使用递归或栈来存储待访问节点，只需要较少的额外空间。
     - 如果迷宫中存在多个解，DFS可能会更快地找到一个解（尽管不一定是最近的解）。
   - 缺点：
     - 在某些情况下，如果迷宫非常深且分支较多，DFS可能会导致栈溢出。
     - 对于求解最短路径的问题，DFS并不适合，因为它倾向于深入探索，可能会绕远路，而不是寻找最近的出口。

2. **广度优先搜索（BFS）**：
   - 原理：从起点开始，一层层向外扩展，优先遍历离起点近的节点，直到找到出口。
   - 优点：
     - 能保证找到从起点到终点的最短路径，因为BFS按照距离起点的距离逐层搜索。
     - 对于求解迷宫这类问题，BFS通常更直观，符合人们“逐步探索”的直觉。
   - 缺点：
     - 相比DFS，BFS的空间复杂度更高，因为它需要使用队列存储每一层的所有待访问节点。
     - 如果迷宫非常宽且分支众多，BFS可能需要遍历大量节点，消耗更多时间。

总结来说：

- **如果你关心的是尽快找到一个解，且迷宫不是特别深、内存限制较严格，或者不在乎解的长短，可以选择DFS。**
- **如果你关心的是找到从起点到终点的最短路径，或者迷宫可能很深、内存限制相对较宽松，应选择BFS。**

在实际应用中，由于大多数迷宫问题通常关注找到最短路径，因此BFS通常是首选方法。然而，具体情况还需根据实际迷宫的特性和你的具体需求来决定。
