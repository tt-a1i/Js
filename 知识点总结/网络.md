## 常见的HTTP请求方法

幂等性（Idempotence）是一个数学和计算机科学中的概念，它表示一个操作可以重复执行多次而不会改变结果。换句话说，无论执行一次还是执行多次，幂等操作的最终效果是相同的。

1. ### 1. GET
   
   用于从服务器获取资源。GET 请求的方法是幂等的和安全的，即多次调用不会引起副作用。
   
   - **用途**：检索数据，例如网页内容、API 数据等。
   - **特点**：请求的参数通常追加到 URL 路径，数据是可缓存的。
   
   ### 2. POST
   
   用于向服务器提交数据以进行处理。POST 请求可能会产生副作用，例如更新数据库或创建新资源。
   
   - **用途**：表单提交、文件上传、创建新数据等。
   - **特点**：请求的数据包含在请求体（body）中，通常不可缓存。
   
   ### 3. PUT
   
   用于更新指定的资源，如果资源不存在，通常会创建资源。PUT 请求是幂等的，即多次调用的结果是相同的。
   
   - **用途**：更新整条记录或文件。
   - **特点**：请求的数据包含在请求体中。
   
   ### 4. DELETE
   
   用于删除指定的资源。DELETE 请求是幂等的。
   
   - **用途**：删除数据或资源。
   - **特点**：通常不包含请求体。
   
   ### 5. HEAD
   
   与 GET 方法类似，但只请求资源的头部信息，不包含实际数据内容。
   
   - **用途**：获取资源的元数据，例如检查资源是否存在，获取资源的大小等。
   - **特点**：不会返回响应体，仅返回响应头信息。
   
   ### 6. PATCH
   
   用于对资源进行部分更新。与 PUT 不同的是，PATCH 只更新资源的部分内容而不是整个资源。
   
   - **用途**：部分更新资源中的数据。
   - **特点**：请求的数据包含在请求体中，描述需要修改的内容。
   
   ### 7. OPTIONS
   
   用于描述目标资源的通信选项。服务器返回支持的 HTTP 方法和其他通信选项。
   
   - **用途**：查看服务器支持的 HTTP 方法，通常用于跨域请求中的预检请求。
   - **特点**：不会返回资源的实际内容。
   
   ### 8. TRACE
   
   用于对目标资源进行回环测试，主要用于诊断。服务器会原样返回客户端的请求内容。
   
   - **用途**：诊断和调试。
   - **特点**：从安全角度考虑，少用。
   
   ### 9. CONNECT
   
   用于将请求连接转换为透明的 TCP/IP 隧道，通常用于 SSL（HTTPS）连接，通过代理服务器建立隧道。
   
   - **用途**：主要用于 HTTPS，通过代理进行安全通信。
   - **特点**：用于代理通信。
   
   ### 总结
   
   | 方法    | 用途             | 幂等性 | 安全性 |
   | ------- | ---------------- | ------ | ------ |
   | GET     | 获取资源         | ✔️      | ✔️      |
   | POST    | 提交数据         | ✖️      | ✖️      |
   | PUT     | 创建或更新资源   | ✔️      | ✖️      |
   | DELETE  | 删除资源         | ✔️      | ✖️      |
   | HEAD    | 获取资源头部信息 | ✔️      | ✔️      |
   | PATCH   | 局部更新资源     | ✖️      | ✖️      |
   | OPTIONS | 获取通信选项     | ✔️      | ✔️      |
   | TRACE   | 诊断、回环测试   | ✖️      | ✖️      |
   | CONNECT | 建立隧道         | ✖️      | ✖️      |

## Http和Https（待补充）

HTTP（超文本传输协议）和 HTTPS（超文本传输协议安全）是 Web 通信中广泛使用的协议。它们在Web浏览器与服务器之间传送信息。了解它们的区别、特点和 HTTPS 的发展非常重要。

### HTTP 

HTTP 是一个无状态协议。这意味着服务器不会自动“记住”客户端的信息。每次客户端向服务器发送请求时，服务器都将其视为一个全新的请求。

为了实现会话管理，开发者通常需要借助 Cookie 或 Session 等机制在服务器端存储客户端信息，但这些机制本身并不是 HTTP 协议的一部分。

1. **简介**：
   - HTTP 是一种用于传输超文本（例如 HTML）的应用层协议。
   - 使用明文通信，即不加密的数据传输。

2. **特点**：
   - **无状态**：每个请求是独立的，不会保留之前请求的数据。需要利用 Cookie 和 Session 等机制来管理会话数据。
   - **可扩展性**：支持多种方法（如 GET、POST、PUT、DELETE 等）和状态码（如 200、404 等）来进行通信和状态反馈。

3. **缺点**：
   - **不安全**：由于没有加密机制，数据容易被窃听和篡改。
   - **数据隐私**：敏感信息（如登录凭证）风险高。

### HTTPS 

1. **简介**：
   - HTTPS 是 HTTP 的安全版本，通过在 HTTP 上加入 SSL/TLS 层来加密数据。

2. **特点**：
   - **加密**：使用SSL/TLS协议加密数据，以保护信息不被第三方窃听。
   - **身份认证**：通过数字证书验证服务器身份，确保用户访问的是真实网站。
   - **数据完整性**：防止数据在传输过程中被篡改。

3. **技术原理**：
   - **SSL/TLS**：传输层安全协议，使用非对称加密、对称加密和数字签名结合的方式保护数据。
     - **握手协议**：建立安全连接的过程，包括服务器和客户端交换密钥等。
     - **记录协议**：在安全连接上，进行实际的数据传输。

### HTTPS 的发展

1. **SSL/TLS 协议演变**：
   - **SSL 1.0-3.0**：早期版本，已不再安全，基本弃用。
   - **TLS 1.0-1.2**：较为安全，并在实践中广泛使用。TLS 1.3 引入了很多优化，是目前最新版本。

2. **证书的进化**：
   - **单域、通配符、多域证书**：适应不同规模和需求的网站。
   - **EV SSL 证书**：提供更高的信任等级，要求严格的企业身份验证。
   - **自动化证书颁发**：如 Let’s Encrypt 提供免费 SSL 证书，促进 HTTPS 普及。

3. **性能优化**：
   - **OCSP Stapling**：减少证书验证的延迟。
   - **HTTP/2 与 HTTPS**：默认用 HTTPS 加载资源，改进了性能，通过多路复用等技术提升网页加载速度。
   - **TLS 1.3** ：削减了握手的步骤，加速安全连接的建立。

4. **普及措施**：
   - 各大浏览器对 HTTP 页面进行标记或限制，推动网站向 HTTPS 转移。
   - 搜索引擎（如 Google）对 HTTPS 网站给予更高的排名优待。

### HTTPS 实施机制

1. **加密技术**：
   - **对称加密**：用于加密数据的快速传输。常见算法有 AES、ChaCha20 等。
   - **非对称加密**：用于交换加密密钥等安全信息。常见算法有 RSA、DSA、ECDSA 等。
   - **哈希算法**：用于数据完整性检查。常见算法有 SHA-256、SHA-3 等。

2. **证书颁发机构（CA）**：
   - CA 是信任的第三方，负责颁发和验证数字证书。
   - 数字证书包含网站的公钥及其他身份验证信息。

3. **浏览器和服务器的角色**：
   - **浏览器**：验证服务器的证书，确保连接的合法性。
   - **服务器**：提供用于安全通信的证书和加密机制。

4. **交互过程**：
   - 客户端发送请求至服务端，服务端返回证书并开启 SSL/TLS 握手。
   - 握手过程生成对称密钥，用于加密后续通信。

### 总结

HTTPS 通过提供加密和身份验证，显著提升了 Web 安全性。随着网络安全意识的增强，HTTPS 的广泛部署已成为现代互联网环境的标准配置。在关注性能优化的同时，保持对最新协议版本（如 TLS 1.3）的更新至关重要。通过充分了解并应用这些技术，可以有效保证用户数据的安全及隐私。

## Https

为了解决Http不安全的特性

是HTTP协议的安全版本，旨在通过在传输层加密通信数据来保护用户和服务器之间的数据传输

让`Http运行在安全点SSL/TLS`协议上,`HTTPS = HTTP + SSL/TLS`,通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

### 主要过程

1. **客户端请求服务器**：
   - 用户在浏览器中输入URL，浏览器向服务器发送HTTPS请求。
2. **服务器发送证书**：
   - 服务器发送其SSL/TLS证书，证书中包括服务器的公钥和由可信的证书颁发机构（CA）签署的服务器身份信息。
3. **客户端验证证书**：
   - 浏览器验证服务器证书的有效性。它检查证书的签名、颁发机构的可信度、和证书的有效期等。
   - 如果验证通过，浏览器会生成一个随机的对称密钥（会话密钥）。
4. **密钥交换**：
   - 浏览器使用服务器的公钥加密这个对称密钥，并将其发送给服务器。
   - 服务器使用其私钥解密，获取对称密钥。
5. **建立安全连接**：
   - 现在客户端和服务器都拥有了相同的对称密钥。之后的通信将使用这个对称密钥进行加密和解密，以确保数据的机密性和完整性。
6. **数据传输**：
   - 使用对称密钥加密的数据在客户端和服务器之间传输，确保即使数据被拦截，也无法被读取。

### 应用场景

1. **银行与金融机构**：
   - 确保在线银行业务、股票交易等金融服务的安全通信。
2. **电子商务**：
   - 保护用户在进行网上购物时输入的敏感信息，如信用卡号、个人地址等。
3. **社交网络**：
   - 保护用户的个人信息和隐私，确保聊天、登录等功能的安全。
4. **在线服务与API**：
   - 保护各种在线服务和API接口的通信，防止数据泄露或被篡改。
5. **电子邮件和通信**：
   - 确保电子邮件服务的安全，防止邮件内容被第三方窥探。

#### 对称加密（Symmetric Encryption）

- **使用场景**：
  - 在通信的主要数据传输过程使用。
  - 通过共享的对称密钥对数据进行快速、高效的加密和解密。
- **优点**：
  - 加密和解密速度快，适合大数据量的传输。
- **缺点**：
  - 密钥分发难题：如何安全地在双方之间交换密钥是一个挑战（这正是非对称加密解决的）。

#### 非对称加密（Asymmetric Encryption）

- **使用场景**：
  - 在初始密钥交换过程中使用。
  - 客户端使用服务器的公钥加密会话密钥（对称密钥），服务器使用其私钥解密。
- **优点**：
  - 公钥公开，私钥保密，密钥分发相对安全。
  - 适合用于密钥交换和数字签名，确保身份验证和数据完整性。
- **缺点**：
  - 加密和解密速度较慢，不适合大数据量的传输。

 

- 首先客户端通过URL访问服务器建立SSL连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

## tls四次握手 发送了什么内容

TLS（传输层安全性协议）实际上是通过一个称为握手的过程来建立安全连接的，该过程用于协商加密密钥和算法。在谈到 TLS 握手时，人们通常提到的是包括四个主要阶段的过程，而不严格是“四次握手”。在传统的 TLS（如 TLS 1.2）中，该过程包含多个步骤，有时称为 "四次握手"，因为涉及到关键的四个步骤。以下是 TLS 握手过程中的关键步骤及其内容：

1. **ClientHello**：
   - 客户端向服务器发送一个 ClientHello 消息，其中包含：
     - TLS 版本号（客户端支持的最高版本）
     - 客户端生成的一个随机数
     - 支持的加密算法列表（例如，对称加密算法、散列算法、压缩方法等）
     - 其他扩展（如 Server Name Indication，SNI，用于指定请求的主机名）

2. **ServerHello**：
   - 服务器响应 ClientHello，通过发送 ServerHello 消息，包括：
     - 选择的 TLS 版本
     - 服务器生成的一个随机数
     - 选择的加密算法及其他协商参数
     - 服务器的数字证书（用于验证服务器身份）
     - 可能的请求客户端证书（可选）

3. **认证与密钥交换**：
   - **服务器证书**：服务器发送其数字证书链，以便客户端验证服务器的真实性。
   - **服务器密钥交换**（可选）：在某些情况下，例如使用 Diffie-Hellman 密钥交换时，服务器还会发送密钥交换参数。
   - **请求证书**（可选）：如果服务器需要客户端认证，它会请求客户端的证书。
   - **客户端证书**（可选）：如果服务器请求了客户端证书，客户端将发送其证书以供验证。

4. **Finished**：
   - **客户端密钥交换**：客户端生成一个预主密钥，并使用服务器的公钥对其加密，然后发送给服务器。
   - **更改密码规格**：客户端发送一条消息，通知服务器后续消息将使用协商好的加密算法与密钥来加密。
   - **Finished 消息**（客户端）：客户端通知服务器它的握手部分已完成，包含这一阶段的所有消息的哈希值加密信息。
   - **更改密码规格**：服务器接收客户端的“更改密码规格”并发送自己的更改密码规格。
   - **Finished 消息**（服务器）：服务器最后确认所有握手消息已完成并正确无误，也发送加密的哈希。

在完成这些步骤后，客户端和服务器协商并确认使用的加密参数，接下来的应用数据将使用该会话密钥进行加密通信。

请注意，TLS 1.3 对握手过程进行了精简和优化，只需一次往返时间（1-RTT），简化了握手过程，将一些阶段合并以提高性能和安全性。

## HTTPS 是在哪一层进行加密的

HTTPS（HyperText Transfer Protocol Secure）是通过在传输层（Transport Layer）进行加密来提供安全性的。具体来说，HTTPS使用了TLS（Transport Layer Security）或其前身SSL（Secure Sockets Layer）来确保在客户端和服务器之间传输数据的机密性和完整性。

在OSI模型中，TLS/SSL位于传输层，这意味着HTTPS是在传输层进行加密的，这在TCP/IP模型中也相对应于其传输层。同时，TLS/SSL通过加密HTTP协议数据，为其提供安全的加密通道。HTTP通过这一加密通道传输数据，因此变为HTTPS。

### HTTPS 你在浏览器的 debug 模式下抓的包，它是加密的还是非加密的，在浏览器上看到的 console 里面看到的 HTTPS 请求报文是被加密的吗

在浏览器的调试模式下（例如使用开发者工具查看网络请求），你看到的HTTPS请求和响应报文通常**不是加密的**。这是因为浏览器在呈现这些信息之前会解密相关数据，以便开发者能够调试和分析。

#### 详细说明：

1. **HTTPS传输过程中的加密**：
   - 在传输过程中，HTTPS使用加密（TLS/SSL）保护数据。这意味着数据在客户端（浏览器）和服务器之间传输时是加密的，从而防止中间人攻击，即其他人无法在网络上拦截并读取这些数据。

2. **浏览器调试工具**：
   - 浏览器本身能够解密这些数据，以便正常显示网页内容及其功能。同样地，浏览器的开发者工具也能够访问解密后的请求和响应，以便开发者能够查看HTTP头部、请求体、响应体等信息。
   - 在网络选项卡中查看的内容实际上是已经解密的数据，因此你可以看到完整的HTTP请求和响应，包括URL、头信息和（如果是可读的）请求/响应的主体。

3. **安全注意**：
   - 通过浏览器查看已解密的数据是安全的，因为是在本地设备上进行的，如果你的浏览器和计算机是安全的，未被恶意软件或病毒侵入的话。
   - 被安全的HTTPS连接加密的数据在传输中是不可读的，只有客户端和服务器能正常解密这段通信。

总结来说，尽管在浏览器中你所看到的HTTPS请求是解密后的明文数据，在实际的网络传输中这些数据是被加密的。浏览器确保这种解密仅限于本地显示和开发者调试用途。

## 区别

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

HTTP 报文是在应用程序之间发送的数据块，用于 HTTP 协议交互。它分为请求报文和响应报文两种类型。

## 如何验证CA证书是否过期

验证 CA 证书是否过期是非常重要的，以确保安全连接和通信。你可以通过多种方式来检查证书的有效性和过期状态：

### 方法1：使用浏览器

1. **打开浏览器**：访问需要检查的证书的目标网站。
2. **查看证书信息**：在大多数现代浏览器中，你可以点击地址栏旁边的锁图标，然后选择 "查看证书" 或类似选项。
3. **检查有效期**：在证书详细信息中，可以看到证书的有效日期范围，包括 "有效期开始" 和 "有效期结束"。
   
### 方法2：使用命令行工具

#### OpenSSL
使用 OpenSSL 工具在命令行中检查证书的过期时间。

1. **获取证书文件**：你需要先下载证书文件，通常是 `.pem`、`.crt`、`.cer` 等格式。
   
2. **检查有效期**：
   ```bash
   openssl x509 -in your-certificate.pem -noout -dates
   ```

   这个命令会输出：
   ```
   notBefore=Jan  1 00:00:00 2022 GMT
   notAfter=Jan  1 23:59:59 2023 GMT
   ```

3. **检查远程服务器证书**：
   如果你想要检查远程服务器的证书，而不是本地文件，可以使用如下命令：

   ```bash
   echo | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -dates
   ```

   这将直接从目标服务器读取证书信息并输出其有效日期。

#### Certutil
在 Windows 上，你可以使用 `certutil` 工具：

```cmd
certutil -dump certificate.cer
```

这会输出关于证书的详细信息，包括其有效期。

### 方法3：使用在线工具

有许多在线工具可以用于检查证书是否过期。你只需输入网站URL，这些工具就会显示证书的详细信息，包括过期日期。

### 注意事项

- **定期检查**：建议定期检查证书的有效性，尤其是当它们接近到期日时。
- **自动化脚本**：对于需要管理大量证书的环境，可以编写脚本定期检查证书的状态，并在快到期时发出警报。
- **续期提醒**：许多证书颁发机构会在证书快到期时发送续期提醒邮件。

通过以上方法，你可以有效地验证 CA 证书的过期状态，确保其在有效期内，并采取适当的措施进行更新或续期。

## 说一下http报文都有哪些东西

### 请求报文（Request Message）

1. **请求行**：

   - 描述客户端想要如何操作服务端的资源。
   - 由三部分构成：
     - 请求`方法`：表示对资源期望进行何种操作，常用的如 GET、POST。
     - 请求`目标`：通常是一个 URL，表明要操作的资源。
     - `版本号`：表示报文使用的 HTTP 协议版本。

   示例：

   ```
   GET / HTTP/1.1
   ```

   

2. **请求头**：

   - 包含若干个属性，格式为“属性名: 属性值”，服务端据此获取客户端的信息。
   - 请求头可大致分为四种类型：
     - 通用首部字段
     - 请求首部字段
     - 响应首部字段
     - 实体首部字段

3. **请求体**：

   - 包含要传输的内容，可以是文本、图片、音频、视频等。

### 响应报文（Response Message）

1. **状态行**：

   - 包含`协议版本`、`状态码`和`状态描述`。
   - 三位数字状态码表示处理的结果，例如 200 表示成功，404 表示资源未找到。
   - 状态描述是状态码的补充，帮助人们理解原因。

   示例：

   ```
   HTTP/1.1 200 OK
   ```

   

2. **响应头部**：

   - 由键值对组成，每行一对，键和值用英文冒号 : 分隔。
   - 响应头允许服务器传递不能放在状态行的附加信息，描述服务器的信息和 Request-URI 进一步的信息。

3. **响应包体**：

   - 服务器返回给浏览器的响应信息，响应数据的格式根据服务器来决定，常见的有 text/html、application/json 等。

[总之，HTTP 报文的基本概念和格式包括请求行、请求头、请求体、状态行、响应头和响应包体。](https://zhuanlan.zhihu.com/p/450128753)[1](https://zhuanlan.zhihu.com/p/450128753)[2](https://zhuanlan.zhihu.com/p/389369982)[3](https://blog.poetries.top/http-protocol/notes/base/06-HTTP报文是什么样子的.html)

## tcp 和 udp，区别特点应用

TCP 和 UDP 都是网络传输层协议，负责在网络设备之间传输数据，但它们的工作方式和应用场景有很大区别。

### **1. 连接方式：**

* **TCP：** 面向连接，就像打电话一样，需要先建立连接，然后才能开始传输数据，传输完毕后需要断开连接。
    1. 特点:
       - 面向连接:通信前需要先建立连接
       - 可靠传输:使用确认机制、重传机制等保证数据可靠到达
       - 流量控制:发送方根据接收方的处理能力调整发送速率
       - 拥塞控制:根据网络拥塞情况调整发送速率
       - 全双工通信:数据可以双向传输
       - 面向字节流:把应用层数据看作字节流,保证字节顺序
    2. 优点:
       - 可靠性高,能保证数据完整性
       - 有序传输
       - 错误重传
       - 流量控制和拥塞控制
    3. 缺点:
       - 开销大,建立连接需要三次握手
       - 时延高
       - 对系统资源要求高
       - 不适合高实时性应用
* **UDP：** 无连接，就像发短信一样，不需要建立连接，直接发送数据即可。
    1. **无连接**：UDP 是一种无连接的协议，它不需要在传输数据之前建立连接。发送方可以直接发送数据包，而无需等待接收方的确认。
    2. **不可靠性**：UDP 不保证数据的交付、顺序和完整性。它不使用确认机制，也没有重传机制。如果数据包在传输中丢失或损坏，UDP 不会进行重发。
    3. **低开销和高效**：由于 UDP 不需要建立连接和维护状态，并且没有流量控制和拥塞控制机制，因此它的开销较低，效率较高，适合对传输速度要求高、对可靠性要求不高的应用。
    4. **报文传输**：UDP 是面向报文的，每个 UDP 数据报都是一个独立的消息。发送方传输的消息不会被拆分和重组，接收方直接接收这些消息。

**2. 数据传输方式：**

* **TCP：**  面向字节流，将数据看作一个连续的字节流，类似于水管里的水流，可以保证数据完整性。
* **UDP：** 面向数据报，将数据分成一个个独立的数据包发送，每个数据包都有自己的目标地址和端口号，类似于寄送的信件，可能会有先后顺序到达的情况。

**3. 应用场景：**

* **TCP：** 适合对数据可靠性要求高的应用场景，例如：
    * **网页浏览 (HTTP/HTTPS):**  确保网页内容完整传输。
    * **文件传输 (FTP):**  保证文件完整传输，不丢失数据。
    * **电子邮件 (SMTP/POP3/IMAP):**  确保邮件内容完整送达。
    * **远程登录 (SSH):**  提供安全的远程连接。
* **UDP：** 适合对数据传输速度要求高，但对数据可靠性要求不高的应用场景，例如：
    * **视频直播：**  允许少量数据包丢失，保证实时性。
    * **语音通话 (VoIP):**  允许少量数据包丢失，保证实时性。
    * **域名系统 (DNS):**  快速解析域名，即使偶尔丢失数据包也能重试。
    * **在线游戏：**  对实时性要求高，允许少量数据包丢失。

**4. 常见比喻：**

* **TCP 像寄快递，需要填写详细地址、电话号码，保证送达，但速度较慢。**
* **UDP 像寄平信，只需要写地址，速度快，但可能丢失。**

**总结：**

| 特性     | TCP                                    | UDP                                    |
| -------- | -------------------------------------- | -------------------------------------- |
| 连接方式 | 面向连接                               | 无连接                                 |
| 可靠性   | 高                                     | 低                                     |
| 速度     | 较慢                                   | 较快                                   |
| 开销     | 较大                                   | 较小                                   |
| 数据传输 | 字节流                                 | 数据报                                 |
| 应用场景 | 网页浏览，文件传输，电子邮件，远程登录 | 视频直播，语音通话，域名系统，在线游戏 |

**选择 TCP 还是 UDP 取决于具体的应用场景，需要在可靠性和速度之间进行权衡。**

### 区别

|          |               TCP                |              UDP               |
| -------- | :------------------------------: | :----------------------------: |
| 可靠性   |               可靠               |             不可靠             |
| 连接性   |             面向连接             |             无连接             |
| 报文     |            面向字节流            |            面向报文            |
| 效率     |            传输效率低            |           传输效率高           |
| 双共性   |              全双工              | 一对一、一对多、多对一、多对多 |
| 流量控制 |             滑动窗口             |               无               |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复 |               无               |
| 传输效率 |                慢                |               快               |

- 都位于传输层
- TCP适用于对效率要求低,对准确性要求高,有连接的场景
- UDP适用于对效率要求高,准确性要求低的场景

## 粘包

粘包是网络通信中常见的一个问题，尤其在使用 TCP 协议时。让我们深入了解这个概念：

粘包问题通常由以下原因导致：

1. **发送端**：数据在发送端被快速地连续发送，操作系统为了优化网络资源利用而合并了多个小的数据包。
2. **接收端**：接收端在从套接字读取数据时，可能一次性读取了多个数据包的内容，导致数据包间无明显边界。



1. 粘包定义：
   - 粘包是指多个数据包在传输过程中被合并成一个包，或者一个数据包被分割成多个包的现象。
2. 产生原因： a) TCP 面向字节流：TCP 是面向字节流的协议，不保存消息边界。 b) 发送端原因：
   - Nagle 算法：为了提高网络利用率，可能会将多个小包合并发送。
   - TCP 发送缓冲区：数据可能在缓冲区中被合并。 c) 接收端原因：
   - 接收缓冲区：数据可能在接收缓冲区中被合并。
   - 接收应用程序读取不及时，导致多个数据包在缓冲区中累积。
3. 粘包的影响：
   - 接收方无法正确区分数据包的边界，导致数据解析错误。
   - 可能造成数据丢失或错误解释。
4. 解决方案： a) 固定长度：每个消息都使用固定长度。 b) 分隔符：使用特殊字符作为消息的分隔符。 c) 消息长度+消息内容：在消息前加上长度字段。 d) 自定义协议：设计包含消息边界信息的应用层协议。
5. 具体实现方法：
   - 消息帧定界：如使用 JSON、XML 等格式，自带结构边界。
   - 长度前缀法：在每个消息前加上长度字段。
   - 特殊结束符：如 HTTP 使用空行表示消息头结束。

## OSI七层模型

`OSI`将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰

<img src="https://static.vue-js.com/eb1b2170-b61e-11eb-ab90-d9ae814b240d.png" alt="img" style="zoom: 67%;" />

#### **应用层:**

定义了应用进程之间的各种交互规则,通过不同的应用层协议为不同的网络应用提供服务

在应用层交互的单元称为报文



#### **表示层:**

作用是使通信的应用程序能够解释交换数据的含义，位于 第六层，向上为应用层提供服务，向下接收来自会话层的服务

服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异



#### 会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话

该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法



#### 传输层

传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题

传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层

其中，主要的传输层协议是`TCP`和`UDP`



#### 网络层

两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网

网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送

在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层

在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层



#### 数据链路层

数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 `IP`数据报组装成帧，在两个相邻节点间的链路上传送帧

每一帧的数据可以分成：报头`head`和数据`data`两部分:

- head 标明数据发送者、接受者、数据类型，如 MAC地址
- data 存储了计算机之间交互的数据

通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源



#### 物理层

作为`OSI` 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送

该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）

该层主要是和硬件有关，与软件关系不大

## 传输过程

- 应用层报文被传送到运输层
- 在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用
- 应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变
- 运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报
- 网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧
- 在物理层数据帧被封装成比特流，之后通过传输介质传送到对端
- 对端再一步步解开封装，获取到传送的数据

## TCP/IP协议

TCP/IP协议是一组广泛使用的网络通信协议，互联网和许多内部网络都是基于TCP/IP协议进行通信的。TCP/IP协议由传输控制协议（TCP，Transmission Control Protocol）和互联网协议（IP，Internet Protocol）组成，因此得名为TCP/IP。

### 1. **TCP/IP 协议栈的分层模型**

TCP/IP 协议栈通常被划分为四层结构（与更传统的OSI七层模型相对），分别是：

1. **应用层（Application Layer）**：负责网络服务和最终用户应用程序之间的交互。
2. **传输层（Transport Layer）**：提供端到端的数据传输服务。
3. **网络层（Internet Layer）**：处理数据的路由与寻址。
4. **链路层（Link Layer）**：处理与物理网络介质的直接交互。

### 1.1 应用层

应用层负责网络应用程序间的交互，是直接为用户服务的最上层协议，包括HTTP、FTP、SMTP等。

- **HTTP/HTTPS**（超文本传输协议）：用于在Web浏览器和服务器之间传递超文本。
- **FTP**（文件传输协议）：用于文件的上传和下载。
- **SMTP**（简单邮件传输协议）：用于电子邮件的传输。
- **DNS**（域名系统）：用于将域名解析为IP地址。

### 1.2 传输层

传输层提供端到端通信服务，负责数据分段、重组、错误检测和流量控制。主要有两类协议：

- **TCP**（传输控制协议）：面向连接的协议，确保数据可靠、有序和无差错地传输。主要特性包括：
    - 连接建立和释放（三次握手和四次挥手）
    - 流量控制（利用接收窗口进行）
    - 拥塞控制（如慢开始、快重传等算法）
    - 数据重传和确认机制

- **UDP**（用户数据报协议）：无连接的协议，不保证数据包顺序和送达。主要用于需要快速传输和实时应用，如视频流、在线游戏和DNS查询。

### 1.3 网络层

网络层负责数据包在不同网络之间的传输和最佳路径选择，主要协议包括：

- **IP**（互联网协议）：IPv4 和 IPv6
    - IPv4：使用32位地址，进行路由选择和数据包转发。
    - IPv6：使用128位地址，解决IPv4地址不足的问题，增加了更多的功能与改进。
- **ICMP**（互联网控制消息协议）：用于发送错误消息和操作信息。
- **ARP**（地址解析协议）：将IP地址解析为硬件MAC地址。
- **RARP**（逆地址解析协议）：将MAC地址解析为IP地址。

### 1.4 链路层

链路层负责直接和物理介质交互，定义数据帧的传输。协议和标准包括：

- **以太网**：数据链路层标准，大多数局域网使用。
- **PPP**（点对点协议）：用于点对点数据链路，常用于电话拨号连接。
- **MAC**（介质访问控制）：管理硬件地址和帧的传输。

### 2. **TCP/IP 通信过程**

以下是TCP建立连接、传输数据和终止连接的详细过程：

### 2.1 三次握手建立连接

1. **SYN**：客户端向服务器发送SYN（同步）包，表明客户端要建立连接，并发送初始序号 `Seq=x`。
2. **SYN-ACK**：服务器收到SYN包后，向客户端发送SYN-ACK包，表示接受连接请求，并发送 `Seq=y` 和应答 `Ack=x+1`。
3. **ACK**：客户端收到SYN-ACK包后，向服务器发送ACK包，确认连接，`Seq=x+1` 和 `Ack=y+1`。

### 2.2 数据传输

- **可靠传输**：TCP使用序号和确认机制保证数据可靠传输。
- **流量控制**：TCP使用窗口机制防止发送端过多发送数据。
- **拥塞控制**：TCP通过算法（慢启动、拥塞避免、快速重传）防止网络拥塞。

### 2.3 四次挥手终止连接

1. **FIN**：客户端向服务器发送FIN（终止）包，表示数据发送完毕，断开连接请求。
2. **ACK**：服务器收到FIN包，返回ACK包，确认接收到FIN包。
3. **FIN**：服务器发送自己的FIN包，表示服务器也完成数据发送，准备断开连接。
4. **ACK**：客户端收到服务器的FIN包，发送ACK包，确认断开。

### 3. **TCP/IP 地址和路由**

### 3.1 IP 地址

- **IPv4**：用点分十进制表示，例如：192.168.0.1。
- **IPv6**：用冒号分隔的十六进制数表示，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334。

### 3.2 子网划分

子网掩码用来确定IP地址的网络部分和主机部分，有助于网络分段和管理流量。

### 3.3 路由

路由器根据路由表确定数据包的传输路径，路由表记录了网络的拓扑结构和最佳路径选择，包括静态路由和动态路由（使用协议如RIP、OSPF、BGP）。

### 4. **常见 TCP/IP 工具**

- **ping**：使用ICMP协议检查网络连通性。
- **traceroute**：显示数据包到目的地的路径。
- **netstat**：显示网络连接和端口状态。
- **ifconfig/ipconfig**：显示和配置网络接口。
- **tcpdump/wireshark**：抓包工具，分析网络流量。

### 5. **TCP/IP 协议的优缺点**

### 优点

- **通用性和互操作性强**：广泛应用于各种类型的网络。
- **可扩展性**：支持各种应用层协议、传输层协议和网络层协议。
- **鲁棒性和容错性**：通过多种机制保证数据传输的可靠性和有效性。
- **高效路由机制**：使用动态路由协议，找到最佳传输路径。

### 缺点

- **效率问题**：对实时性要求高的应用（如视频会议）可能不够理想。
- **安全性问题**：需要结合其他安全协议（如TLS/SSL）来确保数据传输安全。
- **配置复杂性**：需要理解大量协议和技术细节，配置和管理较复杂。

通过以上深入介绍，你应该对TCP/IP协议有了更全面和深刻的理解。TCP/IP是互联网的基石，其重要性不可替代。理解和掌握TCP/IP协议是网络通信领域的基本功，对于网络工程师、系统管理员和开发者都非常重要。

## TCP稳定性的各种控制机制,待补充

## DNS

#### 域名协议系统

进行域名和与之相对应的 IP 地址进行转换的服务器

`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

- IP 地址：一长串能够唯一地标记网络上的计算机的数字
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

#### 查询方式

- 递归查询
- 迭代查询

#### `DNS`的记录分成两种缓存方式

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件

#### 查询过程

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

## CDN

### CDN（内容分发网络）概述

**CDN** 的全称是 **Content Delivery Network**，即内容分发网络。CDN 的主要目的是提高网站内容的传输速度、减少服务器负载，并提升用户的访问体验。

### CDN 的工作原理

CDN 的核心概念是将网站的静态资源（如图片、JavaScript、CSS、视频等）缓存到分布在全球各地的服务器节点上。当用户访问网站时，CDN 会根据用户的位置将请求路由到离用户最近的缓存节点，从而加快资源的加载速度。

具体来说，CDN 的工作原理分为以下几个步骤：

1. **资源缓存**：网站的静态资源被上传到 CDN 供应商的服务器，这些服务器通常称为 CDN 边缘节点。
2. **DNS 解析**：用户访问网站时，DNS 服务器会解析域名，将请求导向最近的 CDN 边缘节点。
3. **内容分发**：最近的 CDN 边缘节点直接将缓存的资源返回给用户。
4. **缓存更新**：当源站点上的资源更新时，CDN 边缘节点会根据缓存策略更新缓存内容，以确保用户获取到的是最新的资源。

### 使用 CDN 的优势

1. **提升加载速度**：由于 CDN 服务器分布在全球各地，用户可以从地理位置最近的服务器获取资源，从而减少加载时间。
2. **减轻服务器负载**：大部分静态资源的请求都由 CDN 边缘节点处理，减少了源服务器的压力。
3. **提高可用性**：即使某个节点出现故障，CDN 会自动切换到其他节点进行服务，从而提高网站的可用性和容错能力。
4. **安全性**：许多 CDN 提供 DDoS 防护和 Web 应用防火墙（WAF）等安全功能，以提高网站的安全防护水平。

### 一般放在CDN上的资源：

1. **静态资源**：
   - **图片**：如网站Logo、背景图、产品照片等。
   - **视频和音频**：媒体流或下载。
   - **CSS/JavaScript文件**：包括前端框架、样式表等。
   - **字体**：Web字体文件，确保快速加载和呈现。
2. **动态内容的缓存版本**：
   - 某些动态生成的内容可以缓存一定时间，提高重复访问时的速度。
3. **大型文件下载**：
   - 软件、补丁、游戏更新包等需要高速下载的内容。

### 如何在项目中使用 CDN

使用 CDN 提供的资源通常只需简单地修改资源的加载路径。例如，你本地的某个 JavaScript 文件可能这样引用：
```html
<script src="/js/app.js"></script>
```

如果你将这个文件通过 CDN 提供，可以这样修改为：
```html
<script src="https://cdn.example.com/js/app.js"></script>
```

许多流行的前端库已经提供了 CDN 地址，只需引用相应的 CDN 地址即可。例如，使用 CDN 加载 Vue.js：
```html
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
```

通过这种方式，你可以快速地利用 CDN 的优势，提升网站性能和用户体验。

- HTTP（HyperText Transfer Protocol）是 Web 的基础协议，用于在客户端（通常是浏览器）和服务器之间传输数据。HTTP 协议经历了几个版本的升级，每个版本都有不同的改进和优化，旨在解决前一个版本中的一些缺陷和不足。下面详细介绍 HTTP/1.1、HTTP/2 和 HTTP/3 之间的主要区别，以及每个版本在演进过程中解决的问题。

## HTTP1/2/3的区别

### HTTP/1.1
HTTP/1.1 是最广泛采用的 HTTP 协议版本，它带来了很多改进和优化，但仍存在一些问题。

**主要特点**：

1. **长连接**（Persistent Connections）：HTTP/1.1 引入了长连接，默认使用 `Connection: keep-alive`，允许多个请求和响应在同一 TCP 连接上传输，减少了连接建立和关闭的开销。
2. **管道化**（Pipelining）：支持请求管道化，即在收到响应之前可以发送下一个请求。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。但是如果网络问题第2个变成第1个接收到的，这个特性在实际中并不常用，因其难以实现和存在队头阻塞（Head-of-Line Blocking）问题。
3. **缓存控制**：增加了更多的缓存控制头，如 `Cache-Control`、`ETag` 等，提高了缓存机制的效率。
4. **字节范围请求**（Range Requests）：允许请求部分内容，特别适用于断点续传和多线程下载。
5. **明文**，报文主体压缩，首部不压缩

**存在的问题**：

1. **队头阻塞**（Head-of-Line Blocking）：通常会发送请求后需要等到收到相应后才能再次发送请求，同一连接上的请求必须按顺序发送和接收，这导致任何一个请求阻塞都会影响后续请求（队头阻塞）。
2. **效率低下**：每个请求都会**带上完整的请求头**，且请求头相对较大，导致带宽浪费。
3. **连接数量限制**：浏览器对**同一域名的并发连接数量有限制**，通常是 6 个，可以使用域名分片，资源放在多个子域（麻烦）。这可能会导致资源加载变慢。连接太多可能会导致DDOS攻击

### HTTP/2
HTTP/2 是对 HTTP/1.1 的改进，旨在解决其存在的问题，提高 Web 性能。

**HTTP/1.1** 版的**头信息肯定是文本**（ASCII编码），**数据体可以是文本**，也可以是二进制。**HTTP/2** 则是一个彻底的二进制协议，**头信息和数据体都是二进制**，并且统称为"帧"（frame）：头信息帧和数据帧。

**主要特点**：

1. **二进制分帧层**：HTTP/2 使用二进制而非文本格式传输数据，大大减少了消息解析的复杂度。
   - 报文变为**二进制**的帧
   - 流标识符，根据标识符来进行组合
     - 数据流发送到一半的时候，客户端和服务器都可以发送信号（`RST_STREAM`帧），取消这个数据流
     - 1.1版取消数据流的唯一方法，就是关闭TCP连接
     - HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用
   
2. **多路复用**（Multiplexing）：在同一 TCP 连接上并行处理多个请求和响应，解决了 HTTP/1.1 的队头阻塞问题。
   - 把报文分成数据帧，首部帧和尾部帧，有流标识符，使得帧可以不用按顺序抵达，根据流标识符进行组合，帧还可以设置流标识优先级

3. **首部压缩**（Header Compression）：通过 HPACK 压缩算法减少头部传输的冗余，提高传输效率。
   - HPACK: 浏览器和服务器都保存一张静态只读的表,通过发送表中的字段来替代请求头的字段,比如http/1.1 OK 起始行,降低传输开销
     - <img src="./assets/image-20240827214324508.png" alt="image-20240827214324508" style="zoom:33%;" />

4. **服务器推送**（Server Push）：服务器可以主动向客户端推送资源，无需客户端显式请求，提高资源加载速度。
   - 把浏览器可能需要的文件一次性发送过去
     - 缺点：比如误点网页，多了很多缓存，安全性问题，DDOS攻击


**存在的问题**：
1. **队头阻塞的TCP层面问题**：尽管 HTTP/2 解决了应用层的队头阻塞问题，但在 TCP 层，上行和下行仍是顺序处理的，如有丢包现象还是需要重传，会影响整个连接的性能。除非把TCP变成二进制的帧那样，但是TCP是由操作系统内核实现的，不可行，所以有了http3

### HTTP/3
HTTP/3 在 HTTP/2 的基础上进一步改进，用以解决其在 TCP 连接层面上的问题。TCP和TLS是两个协议，所以为了HTTP3的部署，只能选择传输层的UDP协议，并且在UDP上新增协议QUIC

**主要特点**：
1. **基于 QUIC 协议**：HTTP/3 默认使用基于 UDP 的 QUIC 传输协议，解决了 TCP 层的队头阻塞问题。QUIC 集成了 TLS 加密和传输层（把TCP和TLS的握手整合在了一起），确保传输速度和安全性。
2. **快速重建连接**：应用层传来的数据封装为QUIC帧，加了流标识符，封装为QUIC数据包，加了ConnectionId,如果网络发生改变，比如wifi变成4G，根据连接Id确认为同一连接，避免再次握手，所以QUIC 连接一旦建立，不受 IP 地址变化的影响，适用于移动设备切换网络场景，提高了连接的可靠性。
3. **减少连接时延**：由于 QUIC 集成了加密握手过程，而且恢复的会话可以不用握手（0-RTT），减少了连接的建立延迟，提高了性能。

**解决的问题**：
1. **TCP 队头阻塞问题**：,解决了 TCP 层的队头阻塞问题，即使个别数据包丢失，也不会影响后续数据流的传输。
2. **传输效率和安全性**：QUIC 结合了 TLS，加密与传输一体化，简化了加密过程，提高了数据传输安全性。
3. **移动适应性和可靠性**：由于 QUIC 的连接无状态重置和快速重新建立连接的特性，适应性和可靠性相比 HTTP/2 有了很大提升。

### 总结

| 特性/版本  | HTTP/1.1           | HTTP/2        | HTTP/3          |
| ---------- | ------------------ | ------------- | --------------- |
| 传输格式   | 文本               | 二进制        | 二进制          |
| 多路复用   | 不支持             | 支持          | 支持            |
| 头部压缩   | 不支持             | 支持（HPACK） | 支持（QPACK）   |
| 服务器推送 | 不支持             | 支持          | 支持            |
| 队头阻塞   | 应用层和传输层都有 | 仅传输层      | 无              |
| 连接协议   | TCP                | TCP           | QUIC (基于 UDP) |
| 安全加密   | 可选 (TLS)         | 可选 (TLS)    | 必须 (内置TLS)  |

每个 HTTP 版本的演进，都在解决前一个版本中的缺陷，提升传输效率、减少延迟、提高安全性和可靠性。HTTP/3 结合了 QUIC 协议的特点，使得它在实际网络环境中表现更加出色，特别是在现代移动和微服务场景下。

## http3的0-RTT
HTTP/3 是一种基于 QUIC 协议的新一代 HTTP 协议，旨在提高网页加载速度和连接的可靠性。QUIC（Quick UDP Internet Connections）是一种基于 UDP 的传输层协议，具有低延迟和高安全性等优点。

### 0-RTT（Zero Round-Trip Time）

0-RTT 是 QUIC 协议中的一个重要特性，它允许客户端在不需要等待完整的握手过程完成之前就开始发送数据。0-RTT 的主要优点在于大幅减少首次连接的延迟，特别是在需要快速响应的应用场景中（例如网页加载或实时通信）。

### 0-RTT 的工作原理

1. **初次连接和握手**：
    - 客户端第一次与服务器通信时，需要经历一个完整的握手过程。这包括用来交换加密密钥和建立安全通信通道的几个往返数据包。
    - 在**完成这个握手之后**，**服务器会向客户端提供**一个「**会话恢复票据**」（Session Resumption Ticket），客户端可以存储这个票据以备后用。

2. **二次连接和 0-RTT 数据传输**：
    - 客户端在随后与同一服务器连接时，可以使用之前存储的会话恢复票据来重用先前的加密密钥。在发送 ClientHello 消息时，客户端可以附带 0-RTT 数据。
    - 服务器在验证会话恢复票据后，立即开始处理和响应客户端的 0-RTT 数据，而无需再经历完整的握手过程。

### 0-RTT 的优缺点

#### 优点
1. **减少延迟**：0-RTT 大幅减少首次连接的延迟，特别是对于那些需要快速响应的应用场景，这是非常有利的。
2. **提高性能**：对于频繁与服务器交互的应用（例如网页加载、API 调用等），0-RTT 可以显著提高性能和用户体验。

#### 缺点
1. **重放攻击的风险**：0-RTT 由于允许在握手完成之前发送数据，会增加重放攻击（Replay Attack）的风险。为了减轻这种风险，应用需要确保 0-RTT 数据是幂等的，即重复执行多次不会产生不一致的结果。
2. **加密强度**：虽然 QUIC 使用强加密技术，但在依赖先前会话的密钥时，0-RTT 的加密强度可能相对较弱，特别是在会话票据被窃取的情况下。

### 如何使用 0-RTT

大多数现代浏览器和 Web 服务器已经开始支持 HTTP/3 和 QUIC 协议，对于开发者来说，一般不需要进行额外的设置，只要确保服务器配置了支持 HTTP/3 和 TLS 1.3（或更新版本）的加密协议即可。

以下是一些常见的服务器和浏览器支持情况：

- **浏览器**：Google Chrome、Mozilla Firefox、Microsoft Edge 和 Apple Safari 都已经支持 HTTP/3 和 QUIC 协议。
- **服务器和 CDN**：Nginx、Apache、Cloudflare 等也开始支持 HTTP/3 和 QUIC 协议。

### 结论

HTTP/3 和 QUIC 中的 0-RTT 功能极大地改善了网络性能，特别是对于需要快速响应的应用。然而，由于存在安全风险，在使用 0-RTT 时需要特别关注数据的幂等性和安全性。如果能够正确实施和管理，0-RTT 将为网络应用带来显著的性能提升。
## HTTP 常见的状态码有哪些，适用场景

`http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态`

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误

#### 1xx

`代表请求已被接受，需要继续处理`。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

常见的有：

- 100（客户端继续发送请求，这是临时响应）：这个临时响应是`用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝`。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101：`服务器根据客户端的请求切换协议`，主要用于websocket或http2升级

#### 2xx

代表`请求已成功被服务器接收、理解、并接受`

常见的有：

- 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
- 201（已创建）：请求成功并且服务器创建了新的资源
- 202（已创建）：服务器已经接收请求，但尚未处理
- 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
- 204（无内容）：服务器成功处理请求，但没有返回任何内容
- 205（重置内容）：服务器成功处理请求，但没有返回任何内容
- 206（部分内容）：服务器成功处理了部分请求

#### 3xx

`表示要完成请求，需要进一步操作`。 通常，这些状态代码用来`重定向`

常见的有：

- 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
- 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
- 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
- 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

#### 4xx

`代表了客户端看起来可能发生了错误，妨碍了服务器的处理`

常见的有：

- 400（错误请求）： 服务器不理解请求的语法
- 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403（禁止）： 服务器拒绝请求
- 404（未找到）： 服务器找不到请求的网页
- 405（方法禁用）： 禁用请求中指定的方法
- 406（不接受）： 无法使用请求的内容特性响应请求的网页
- 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
- 408（请求超时）： 服务器等候请求时发生超时

#### 5xx

表示服务器无法完成明显有效的请求。这类状态码`代表了服务器在处理请求的过程中有错误或者异常状态发生`

常见的有：

- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
- 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

#### 适用场景

下面给出一些状态码的适用场景：

- 100：客户端在`发送POST数据给服务器前，征询服务器情况`，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。`常用于POST大数据传输`
- 206：一般用来做`断点续传`，或者是`视频文件等大文件的加载`
- 301：永久重定向会缓存。`新域名替换旧域名`，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
- 302：临时重定向不会缓存，常用 于`未登陆的用户访问用户中心重定向到登录页面`
- 304：`协商缓存，告诉客户端有缓存，直接使用缓存中的数据`，返回页面的只有头部信息，是没有内容部分
- 400：`参数有误，请求无法被服务器识别`
- 403：`告诉客户端禁止访问该站点或者资源`，如在外网环境下，然后访问只有内网IP才能访问的时候则返回
- 404：`服务器找不到资源时，或者服务器拒绝请求又不想说明理由时`
- 503：`服务器停机维护时`，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
- 504：`网关超时`

## GET 和 POST 的区别

#### GET

`GET`方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据

#### get请求会被浏览器缓存吗

[**GET 请求有可能被浏览器缓存**。当服务器返回的响应头包含 “Cache-Control” 或 “Expires” 字段时，浏览器会缓存该请求的响应内容。在下一次请求同样的 URL 时，浏览器会先检查缓存中是否有该请求的响应内容，如果有则直接使用缓存中的内容，不再向服务器发送请求](https://juejin.cn/s/get请求会被浏览器缓存)[1](https://juejin.cn/s/get请求会被浏览器缓存)。

为了防止浏览器缓存，可以采取以下方法之一：

- **添加 HTTP 头**：告诉浏览器不要缓存数据。
- [**添加校验参数**：每次请求时添加一个后端会忽略的参数，例如时间戳。这样浏览器会认为每次都是不同的请求，不会从历史记录中读取数据](https://segmentfault.com/q/1010000021784624)[2](https://segmentfault.com/q/1010000021784624)[3](https://bing.com/search?q=get请求会被浏览器缓存吗)。

#### [#](https://vue3js.cn/interview/http/GET_POST.html#post)POST

`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**



本质上都是`TCP`链接，并无差别

但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别

#### 区别

- `GET在浏览器回退时是无害的`，而``POST会再次提交请求``。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- `GET请求会被浏览器主动cache`，而`POST不会`，除非手动设置。
- `GET请求只能进行url编码`，而`POST支持多种编码方式`。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- `GET请求在URL中传送的参数是有长度限制的`，而`POST没有`。
- 对参数的数据类型，`GET只接受ASCII字符`，而`POST没有限制`。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- `GET参数通过URL传递`，`POST放在Request body中`
- 携带参数的时候，GET`请求是放在`url`中，`POST`则放在`body`中

#### 安全

`POST`比`GET` 安全，因为数据在地址栏上不可见

然而，从传输的角度来说，他们都是不安全的，因为`HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文

只有使用`HTTPS`才能加密安全

#### 数据包

对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应200（返回数据）

对于`POST`，浏览器先发送`header`，服务器响应100 `continue`，浏览器再发送`data`，服务器响应200 ok

并不是所有浏览器都会在`POST`中发送两次包，`Firefox`就只发送一次

## HTTP 常见的请求头有哪些? 作用？

HTTP请求和响应消息中的消息头部分

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 Host: en.wikipedia.org             |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

####  协商缓存

协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

#### 会话状态

`cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `Cookie`有效期、安全性、使用范围的可选属性组成

`Cookie` 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等

## 浏览器输入网址到网页显示过程

```javascript
- 浏览器输入url，浏览器主进程接管，开一个下载线程，
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始
```

浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

1. 解析html建立dom树
2. 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

当用户在浏览器地址栏中输入网址并按下回车键后，浏览器会经历一系列步骤来将请求的网页显示出来。下面是这个过程的详细步骤：

### 1. **DNS 解析**

- **解析域名**：浏览器首先需要将用户输入的域名转换为对应的 IP 地址。它先从本地缓存中查找，如果不存在，则向 DNS 服务器请求解析。
- **查询 DNS 服务器**：依次通过递归 DNS 服务器和根域名服务器，直到找到存储目标域名记录的权威 DNS 服务器。
- **返回结果**：权限服务器将相应域名的 IP 地址返回给浏览器。

### 2. **建立 TCP 连接**

- **三次握手**：一旦浏览器获得 IP 地址，它通过传输控制协议 (TCP) 开始与目标服务器建立连接。这个过程包括：
  1. 浏览器向服务器发送一个带 SYN 标志的包。
  2. 服务器回应一个带 SYN/ACK 标志的包。
  3. 浏览器发送一个确认包，连接建立。

### 3. **发送 HTTP 请求**

- **构建请求报文**：浏览器创建一个 HTTP 请求报文，其中包含请求方法（例如GET、POST）、目标 URL、请求头等信息。
- **发送请求**：浏览器将该请求报文通过之前建立的 TCP 连接发送到服务器。

### 4. **服务器处理请求并响应**

- **处理请求**：服务器接收到请求后，会根据请求的内容由指定的程序（例如后端框架应用）处理。
- **生成响应**：处理完请求后，服务器生成一个 HTTP 响应报文，包括状态码、响应头和可选主体（例如 HTML、CSS、JavaScript 文件或 JSON 数据等）。
- **发送响应**：服务器将响应报文发送回浏览器。

### 5. **浏览器接收响应**

- **解析响应状态**：浏览器接收到响应后，首先检查响应状态码（例如 200 表示成功，404 表示资源未找到）。
- **处理响应头**：浏览器根据响应头中的信息（如内容类型、缓存控制）确定接下来的操作。

### 6. **渲染页面**

- **解析 HTML**：浏览器解析 HTML 文档，同时构建 DOM 树。在解析的过程中，如果遇到 CSS 或 JavaScript，则：
  - **CSS**：构建 CSSOM 树，并进行样式计算。
  - **JavaScript**：暂停 DOM 构建，执行 JavaScript 以便修改 DOM 或 CSSOM（如果是同步脚本）。
- **构建渲染树**：将 DOM 树和 CSSOM 树结合，构建渲染树。
- **布局和绘制**：计算每个节点的几何属性（布局），然后将页面绘制到屏幕上。

### 7. **后续处理**

- **处理异步请求**：在解析和渲染页面时，可能会发起异步的请求（如 AJAX），这些请求的结果可能会进一步更新页面。
- **用户交互**：页面完全渲染后，用户可以进行各种交互，浏览器会根据用户操作继续发起请求或操作 DOM。

总的来说，这是一个复杂且高效的过程，涉及了网络协议、服务器处理、客户端渲染等多个方面，从而实现页面的快速渲染和响应。

## TCP为什么需要三次握手和四次挥手

<img src="./assets/image-20240827210747409.png" alt="image-20240827210747409" style="zoom:67%;" />

tcp有一个重要的特性,**可靠性**,发出消息给对方后,一定要是对方收到了才算发送成功,如果对方没有说收到了,那就要不停的重发,这就是可靠性

### 握手过程（连接建立）

**三次握手 (Three-Way Handshake)**：

1. **SYN（Synchronize）帧**：客户端发送 SYN 包给服务器，表示请求建立连接，并同步序列号。
2. **SYN-ACK（Synchronize-Acknowledgment）帧**：服务器接收到 SYN 包后，回复一个带有 SYN 和 ACK 标志的包，表示同意连接并同步序列号，确认客户端的 SYN 包。
3. **ACK（Acknowledgment）帧**：客户端接收到服务器的 SYN-ACK 包之后，再发送一个 ACK 包，表示确认服务器的 SYN-ACK 包。连接建立成功，双方可以开始通信。

### 挥手过程（连接终止）

**四次挥手 (Four-Way Handshake)**：

1. **FIN（Finish）帧**：主动关闭连接的一方（例如客户端）发送一个 FIN 包，表明它已经没有数据要发了，请求关闭这个方向的连接。
2. **ACK（Acknowledgment）帧**：被动关闭连接的一方（例如服务器）收到 FIN 包后，发送一个 ACK 包，确认已经接收到 FIN 包，但它可能仍有数据要发送。
3. **FIN（Finish）帧**：被动关闭连接的一方（服务器）在完成数据发送后，发送一个 FIN 包，表明它也没有数据要发了，请求关闭连接。
4. **ACK（Acknowledgment）帧**：主动关闭连接的一方（客户端）收到服务器的 FIN 包后，发送一个 ACK 包，确认收到 FIN，连接正式关闭。

### 为什么挥手比握手多一次？

以下是原因和详细解释：

1. **全双工通信的特点**：
   - TCP 是全双工的，这意味着数据可以在连接双方的任意方向上同时传输。断开连接时，每个方向的连接都必须单独关闭，以确保所有未完成的数据传输能够完成。
2. **确保数据完整传输**：
   - 握手阶段主要目的是建立稳定的连接，因此三次握手就足够了。而在断开连接时，需要确保双方都已经完成了所有数据的传输，这需要更多的步骤。
3. **独立的关闭请求**：
   - 每一方都需要独立地发送一个 FIN 包来表示自己没有数据可发送了。例如，客户端发送一个 FIN 包后，还需要等待服务器完成自己的数据发送。这使得 ACK 和 FIN 的交互过程变成了两步。

### 示例流程示意图

```
客户端                      服务器
   |                            |
   | —————> (SYN) —————>        |  初次请求连接
   | <————— (SYN-ACK) <—————    |  同意建立连接
   | —————> (ACK) —————>        |  确认连接建立
   |                            |
   |           连接建立         |
   |                            |
   | —————> (FIN) —————>        |  请求关闭连接
   | <————— (ACK) <—————        |  确认关闭请求
   |                            |
   |                            | —————> (FIN) —————>
   |                            |   数据传输完成后关闭连接
   | <————— (ACK) <—————        |  确认关闭连接
   |                            |
   |        连接关闭            |
   |                            |
```

### 总结

1. **三次握手**：用于可靠地建立连接，主要包括同步序列号和确认双方具备通信能力。
2. **四次挥手**：用于可靠地终止连接，确保双方都已经关闭且没有未发送的数据，分别关闭两个方向的连接。

## 为什么是四次挥手，为什么不是三次、五次

### 四次挥手过程

1. **第一次挥手（FIN）**：
   - 客户端主动关闭，发送一个FIN（Finish）报文段给服务器，表示其已经没有数据要发送了。
   - 此时，客户端进入FIN_WAIT_1 状态。

2. **第二次挥手（ACK）**：
   - 服务器收到FIN报文后，发送一个ACK（Acknowledgment）报文段进行确认。确认号是收到的序列号加1。
   - 服务器进入 CLOSE_WAIT 状态，客户端进入 FIN_WAIT_2 状态。
   - 这表明客户端到服务器的通道已关闭，但服务器到客户端的通道仍然开放，服务器可以继续发送数据（即全双工通信的特性）。

3. **第三次挥手（FIN）**：
   - 服务器发送一个FIN报文段给客户端，表示它也已经没有数据要发送了。
   - 服务器进入 LAST_ACK 状态。

4. **第四次挥手（ACK）**：
   - 客户端收到FIN报文后，发送一个ACK报文段给服务器，确认服务器关闭连接请求，同时自己进入 TIME_WAIT 状态，等待一段时间以确保服务器接收到了ACK报文段。如果服务器没有收到，服务器会重发FIN报文段。
   - 服务器收到这个ACK报文后，正式关闭连接。

### 为什么是四次挥手？

1. **全双工通信**：**TCP 连接是全双工**的，这意味着**数据可以同时在两个方向上传输**。关闭连接时，**需要确保两个数据流都已经正确终止**。因此需要双方都分别发送FIN和ACK来关闭各自的传输通道。

2. **确保数据传输完整性**：在**关闭连接之前**，必须**确保所有数据都已被接收并被成功传送**。因此，分别的FIN/ACK保证双方都能独立地完成它们自己的数据传输和连接关闭过程。

3. **状态过渡的必要性**：每一方向的关闭请求和确认（FIN和ACK）都会导致状态变化，这对TCP状态机的设计来说是关键的。例如，CLOSE_WAIT 和 TIME_WAIT 状态确保双方能够处理还未完成的数据传输。



四次挥手的设计是为了满足TCP连接的可靠性和有序性，也为了处理全双工连接的关闭。以下是四次挥手的具体合理性和必要性：

1. **全双工连接的关闭**：
   - TCP是一种**全双工**协议，这意味着**双方可以同时发送和接收数据**。
   - 四次挥手过程确保双方都能各自独立地关闭发送和接收通道。通过这样，确保数据的可靠传输和完整性。
2. **保证数据完整传输**：
   - 在第一步发送FIN请求后，即表示客户端A不会再发送任何数据，但它可以继续接收来自服务器B的数据。
   - 服务器B通过第二次握手的ACK段回应确认，同时可以继续发送未完成的数据。
   - 服务器B在完成数据发送后才会发送其FIN请求（第三步），这确保了所有待发送的数据都能完成传输。
3. **确保双方确认连接关闭**：
   - 双方通过四次握手各自确认连接已经关闭，确保没有数据丢失或误解。
   - 通过最后的ACK确认段（第四步），确保双方在**关闭连接前完成所有必要的确认和数据传输**。

### 为什么不是三次、五次挥手

**√ 不是三次挥手的原因**：

- 三次挥手无法正确处理全双工通信中的每个方向的独立关闭。例如，无法确保每一方已经完全传输和接收了所有数据。

**× 不需要五次挥手的原因**：

- 四次挥手已经满足TCP连接终止的所有需求和规范，再增加一步只是多余并且没有实质性的意义。

### 为什么不能是三次？

如果只是三次挥手，就可能发生以下问题：

- 如果服务器的FIN 与 ACK 被合并（在某些情况下这是可能的），这样客户端无法确认它的 FIN 得到了正确处理。
- 客户端没有机会确认服务器发送的最后的 FIN，可能会导致服务器错误地认为连接已经完全关闭，从而丢失一些未被传输的确认信息。

### 为什么不能是五次？

五次挥手没有必要，因为：

- 四次挥手已经能够分别确认每一方都完成和关闭传输，而且已经足够保证连接的完整性和安全性。
- 增加更多的信息交换会增加协议复杂性和通信开销，而没有带来额外的可靠性或效率提升。

总结来说，四次挥手是 TCP 协议在关闭连接时平衡效率与可靠性的结果，既确保了连接的完整关闭又避免了不必要的复杂性。

## 说说对WebSocket的理解？应用场景？

WebSocket，是一种`网络传输协议`，位于`OSI`模型的`应用层`。可在`单个TCP`连接上进行`全双工通信`，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器`只需要完成一次握手`，两者之间就可以创建`持久性的连接`，并进行`双向数据传输`



`websocket`出现之前，开发实时`web`应用的方式为`轮询`

不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果`轮询的频率比较高，那么就可以近似地实现“实时通信”的效果`

轮询的`缺点`也很明显，反复发送无效查询请求`耗费了大量的带宽`和 `CPU`资源



#### 全双工

通信`允许数据在两个方向上同时传输`，它在能力上相当于两个单工通信方式的结合

例如指 A→B 的同时 B→A ，是瞬时同步的

#### 二进制帧

采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比`http/2`，`WebSocket`更侧重于“实时通信”，而`HTTP/2` 更侧重于提高传输效率，所以两者的帧结构也有很大的区别

#### 协议名

引入`ws`和`wss`分别代表明文和密文的`websocket`协议，且默认端口使用80或443，几乎与`http`一致

#### 握手

`WebSocket`也要有一个握手过程，然后才能正式收发数据

#### 优点

- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

#### 应用场景

基于`websocket`的事实通信的特点，其存在的应用场景大概有：

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新

## url有长度限制吗

URL 的长度在不同浏览器和协议中有一定的限制。让我们来详细了解一下：

1. **HTTP/1.1 规范**：
   - 最初的 HTTP/1.1 规范（RFC 2616）并没有对 URI（Uniform Resource Identifier，即 URL）的长度设定明确的上限。
   - [服务器应该能够处理任何资源的 URI，如果服务器无法处理过长的 URI，应该返回状态码 414（Request-URI Too Long）](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)[1](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)。
2. **实际使用情况**：
   - 实际上，不同浏览器和服务器软件对请求行长度都有一些限制。
   - 通常，如果你将 URL 保持在 **2000 个字符以内**，它们将在几乎所有组合的客户端和服务器软件以及搜索引擎中正常工作。
   - 对于特定用例，可以考虑使用更长的 URL。
3. **推荐长度**：
   - 根据最新的规范（RFC 9110），建议所有发送方和接收方至少支持 **8000 个八位字节** 长度的 URI。
   - [这意味着如果你的 URL 在 8000 个字符以内，它应该在大多数情况下都能正常工作](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)[1](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)。

[总之，如果你的 URL 在 **2000 个字符以内**，它将在几乎所有组合的客户端和服务器软件中正常工作。但是，如果你有特定的用例，可以考虑使用更长的 URL。](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)



## Http协议的Content-Type

http头信息必须是 ASCII 码，后面的数据可以是任何格式,这就是`Content-Type`字段作用,数据类型总称为`MIME type`

在HTTP协议中，“Content-Type”是一个头部字段（header field），用于`指示资源的媒体类型`（也称为`MIME`类型）。这个头部字段告诉客户端实际返回的内容的格式是什么，以此来确保正确的解析和处理数据。

例如：

1. 如果服务器返回的是普通文本，头部可能会标注为：

   ```javascript
   Content-Type: text/plain
   ```

2. 如果返回的是HTML文档，则头部可能是：

   ```
   Content-Type: text/html
   ```

3. 对于JSON格式的数据，头部则会标注为：

   ```
   Content-Type: application/json
   ```

4. 对于图片和视频，Content-Type也有不同的值，例如：

   - 图片PNG格式：`Content-Type: image/png`
   - 视频MP4格式：`Content-Type: video/mp4`

在编写HTTP服务器响应客户端请求时，正确设置“Content-Type”头部非常重要，以确保客户端软件（如浏览器）能正确解析和显示内容。

## SSE

服务器发送事件(Server-Sent Events, SSE)是一种网络通信技术，允许服务器向客户端推送实时数据。以下是对SSE的详细介绍：

1. 基本概念：

   - SSE是HTML5规范的一部分。
   - 它提供了一种单向通信机制，从服务器到客户端。
   - 基于HTTP协议，使用标准的GET请求。

2. 工作原理：

   - 客户端发起一个HTTP连接到服务器。
   - 服务器保持这个连接开放，并通过它发送事件。
   - 连接长期保持开放状态，直到客户端关闭或服务器终止。

3. 数据格式：

   - 服务器发送的数据格式为"text/event-stream"。

   - 每条消息以一个或多个文本行组成，以换行符分隔。

   - 典型的消息格式：

     ```
     event: eventName
     data: Your message here
     id: messageId
     ```

4. 客户端API：

   - 使用EventSource对象创建连接：

     ```javascript
     const eventSource = new EventSource('/events');
     ```

   - 监听事件：

     ```javascript
     eventSource.onmessage = (event) => {
       console.log(event.data);
     };
     ```

5. 服务器实现：

   - 服务器需要设置正确的头部：

     ```
     Content-Type: text/event-stream
     Cache-Control: no-cache
     Connection: keep-alive
     ```

   - 然后发送格式化的事件数据。

6. 优点：

   - 简单易用，基于标准HTTP。
   - 自动重连机制。
   - 跨域支持（通过CORS）。
   - 服务器端实现简单。

7. 限制：

   - 单向通信（服务器到客户端）。
   - 不是所有浏览器都支持（但主流浏览器支持良好）。
   - 连接数限制（每个浏览器对同一域名的连接数有限制）。

8. 应用场景：

   - 实时新闻推送。
   - 股票价格更新。
   - 社交媒体实时通知。
   - 即时聊天应用的部分功能。

9. 与WebSocket比较：

   - SSE更轻量，实现更简单。
   - WebSocket支持双向通信，功能更强大。
   - SSE基于HTTP，更容易通过防火墙。

10. 安全性考虑：

    - 使用HTTPS加密传输。
    - 实施适当的认证和授权机制。

11. 性能优化：

    - 合理控制消息发送频率。
    - 在客户端实现错误处理和重连逻辑。

Server-Sent Events (SSE) 是一种允许服务器向客户端推送数据的 Web 技术。它提供了一种单向通信机制，使服务器能够主动发送更新到客户端。让我们深入探讨 SSE 的优点和缺点：

优点：

1. 简单性：
   - SSE 基于 HTTP 协议，实现和使用都相对简单。
   - 使用标准的 EventSource API，无需额外的库或框架。

2. 原生浏览器支持：
   - 大多数现代浏览器都原生支持 SSE，无需额外的客户端库。

3. 自动重连：
   - 浏览器内置了自动重连机制，提高了连接的可靠性。

4. 基于标准 HTTP：
   - 使用标准的 HTTP/HTTPS 连接，易于通过防火墙和代理。

5. 服务器推送：
   - 允许服务器主动向客户端推送数据，适合实时更新场景。

6. 轻量级：
   - 相比 WebSocket，SSE 更加轻量，适用于单向数据流场景。

7. 支持事件类型：
   - 可以发送不同类型的事件，便于客户端区分和处理不同种类的更新。

8. 文本格式友好：
   - 默认使用 UTF-8 编码的文本数据，易于处理和调试。

9. 长连接：
   - 建立长连接，减少了频繁建立连接的开销。

10. 适合特定实时场景：
    - 非常适合如股票报价、新闻推送、社交媒体更新等单向实时数据流场景。

11. 跨域支持：
    - 支持跨域资源共享（CORS），可以从不同域的服务器接收事件。

12. 服务器端实现简单：
    - 服务器端实现相对简单，只需要发送特定格式的响应。

缺点：

1. 单向通信：
   - SSE 只支持服务器到客户端的单向通信，不能从客户端发送数据到服务器。

2. 连接数限制：
   - 浏览器对每个域名的 SSE 连接数有限制（通常为 6 个）。

3. 不支持二进制数据：
   - SSE 主要用于发送文本数据，不适合大量二进制数据传输。

4. IE 浏览器不支持：
   - Internet Explorer 不支持 SSE，需要使用 polyfill 或替代方案。

5. 连接管理：
   - 长时间保持连接可能导致服务器资源消耗。

6. 网络问题：
   - 在不稳定的网络环境下，可能会遇到连接断开的问题。

7. 缓冲控制：
   - 客户端对接收数据的缓冲控制有限。

8. 无法手动关闭连接：
   - 服务器没有直接的机制来关闭客户端连接。

9. 延迟：
   - 虽然比轮询好，但仍可能存在一些延迟，特别是在高负载情况下。

10. 可扩展性挑战：
    - 在需要维护大量并发连接的场景中，可能面临可扩展性问题。

11. 调试复杂性：
    - 相比普通 HTTP 请求，SSE 连接的调试可能更复杂。

12. 服务器端保持打开状态：
    - 服务器需要保持连接打开状态，可能增加服务器负载。

综合考虑：

- SSE 非常适合需要服务器向客户端推送数据的场景，特别是实时更新的应用。
- 对于需要双向通信或大量二进制数据传输的应用，WebSocket 可能是更好的选择。
- SSE 的简单性和基于 HTTP 的特性使其在某些场景下比 WebSocket 更容易实现和部署。
- 在选择使用 SSE 时，需要考虑浏览器兼容性、连接数限制和网络环境等因素。
- SSE 可以作为轮询的有效替代方案，提供更实时的数据更新。
- 对于只需要服务器推送数据的应用，SSE 可能是比 WebSocket 更轻量级和简单的解决方案。

总的来说，SSE 是一个强大而简单的技术，适用于多种实时数据推送场景。但它也有其局限性，开发者需要根据具体的应用需求来决定是否使用 SSE。在某些情况下，SSE 可以与其他技术（如 RESTful API）结合使用，以实现更全面的通信解决方案。

## 为什么gpt问答这种场景sse比websocket更合适

在 GPT 问答这样的场景中，SSE（Server-Sent Events）确实比 WebSocket 更合适。让我们深入分析一下原因：

1. 单向通信流:
   - GPT 问答场景主要是服务器向客户端发送数据（回答），这正好符合 SSE 的单向通信模型。
   - WebSocket 提供全双工通信，在这种情况下可能是过度设计。

2. 简单性:
   - SSE 基于 HTTP 协议，实现和维护都比 WebSocket 简单。
   - 对于 GPT 问答这种主要是服务器推送内容的场景，SSE 的简单性是一大优势。

3. 轻量级:
   - SSE 比 WebSocket 更轻量，消耗的服务器资源更少。
   - 在大规模部署时，这种轻量级特性可以显著降低服务器负载。

4. 自动重连:
   - SSE 客户端（浏览器）内置自动重连机制，对于可能需要长时间等待的 GPT 回答很有用。
   - 这减少了开发者处理连接中断的工作。

5. 基于 HTTP:
   - SSE 使用标准 HTTP 连接，易于通过现有的网络基础设施（如代理、防火墙）。
   - 这简化了部署和扩展过程。

6. 文本流处理:
   - GPT 回答通常是文本形式，SSE 默认使用 UTF-8 编码的文本数据流，非常适合这种场景。
   - 文本流使得服务器可以逐步发送生成的回答，而不需要等待完整回答生成。

7. 低延迟流式传输:
   - SSE 允许服务器即时推送数据，非常适合 GPT 模型生成文本的流式特性。
   - 用户可以看到答案的实时生成过程，提升交互体验。

8. 连接复用:
   - 对于多次问答，SSE 可以保持单一长连接，减少了重复建立连接的开销。

9. 服务器控制:
   - 服务器可以更好地控制数据流，例如调整发送速率或暂停发送。

10. 跨域支持:
    - SSE 支持跨域资源共享（CORS），便于前端和后端分离部署。

11. 适合长时间运行的请求:
    - GPT 生成回答可能需要较长时间，SSE 非常适合这种长时间运行的请求。

12. 兼容性和可访问性:
    - 大多数现代浏览器都支持 SSE，不需要额外的客户端库。
    - 对于不支持 SSE 的浏览器，可以轻松退回到长轮询等替代方案。

13. 调试友好:
    - SSE 的文本基础使得调试和监控相对简单。

14. 资源效率:
    - 对于主要是单向数据流的 GPT 问答场景，SSE 比 WebSocket 更高效。

15. 扩展性:
    - 在需要处理大量并发连接时，SSE 的资源消耗通常比 WebSocket 低。

16. 安全性:
    - SSE 使用标准的 HTTPS，无需额外的安全配置。

17. 与现有 Web 架构的集成:
    - SSE 更容易集成到现有的 Web 应用架构中，特别是基于 REST 的 API。

结论:
对于 GPT 问答这种以服务器向客户端推送文本数据为主的场景，SSE 提供了一个几乎完美的平衡点。它结合了实时性、简单性、效率和易于实现的特点，同时避免了 WebSocket 在这种场景下可能带来的不必要的复杂性和开销。SSE 允许开发者专注于核心功能 —— 流式传输 GPT 生成的文本，而不需要处理双向通信的复杂性。这使得 SSE 成为 GPT 问答系统的理想选择，能够提供流畅的用户体验，同时保持系统的简洁和高效。

## 哪些文件或资源会受跨域限制，什么类型的网络请求不受同源策略管控

在Web开发中，同源策略（Same-Origin Policy）是一种重要的安全机制，用来防止不同源的资源相互访问，以防止恶意网站窃取数据。具体来说，同源策略会限制以下资源的跨域请求：

### 受同源策略限制的文件或资源：
1. **XMLHttpRequest (XHR) 和 Fetch API**：
   这些是用来进行网络请求的主要方式，受同源策略严格控制。若要跨域请求，则需要服务器开启CORS（Cross-Origin Resource Sharing）。

2. **AJAX 请求**：
   通过JavaScript发起的AJAX请求也在同源策略之下，这是由XMLHttpRequest对象实现的，涉及到任何敏感数据的请求都需要同源。

3. **WebSockets**：
   初始化WebSocket连接时也遵循同源策略，服务器需要配置相应的CORS头来允许跨域连接。

4. **Cookie, LocalStorage 和 IndexedDB**：
   这些客户端存储机制也受同源策略保护，不同源的网页无法直接访问这些存储中的数据。

5. **Web Workers**：
   创建Web Worker时，脚本文件必须同源。

6. **Iframes**：
   同源策略会限制iframe与其嵌套的页面之间的JavaScript交互。例如，iframe中的脚本无法访问不同源主页面中的DOM和Cookie。

### 不受同源策略管控的网络请求类型：

1. **嵌入资源请求**：
   这些资源通过HTML标签天然允许跨域请求：
   - **`<script>` 标签**：可以用来加载不同源的JavaScript文件。
   - **`<link>` 标签**：可以用来加载不同源的CSS文件。
   - **`<img>` 标签**：可以用来加载不同源的图片。
   - **`<video>` 和 `<audio>` 标签**：可以用来加载不同源的媒体文件。
   - **`@font-face`**：可以用来加载不同源的字体文件。
   - **`<iframe>` 标签**：可以嵌入不同源的网页，但会受到沙箱机制限制，只能做有限的交互。

2. **JSONP (JSON with Padding)**：
   它是一种使用<script>标签来实现跨域的方案，服务端返回的是一段JavaScript代码，通过回调函数将数据传递给客户端。

3. **CORS (Cross-Origin Resource Sharing)**：
   允许开发者在服务器端设置相关的HTTP响应头来绕过同源策略。例如，通过设置`Access-Control-Allow-Origin`来实现允许的跨域请求。

4. **WebSockets**：
   WebSockets一旦连接建立，不再受同源策略限制，可以双向传输数据。初始握手需遵从同源策略，但可以通过服务器允许跨域。

5. **DNS预取和预加载**：
   这些技术通过在页面加载之前解析和提取资源，但它们不会涉及到内容或数据的泄露。

### 第三方库：

值得注意的是，一些第三方库也提供了解决跨域问题的方案，比如通过代理服务器进行请求转发：

- **CORS Proxy**：
  通过代理服务器去请求真实的资源，然后将结果返回给客户端。这种方式可以绕过浏览器的同源策略限制。

- **JSONP库**：
  像`jQuery.ajax`的`jsonp`选项，使得跨域调用变得更方便，但它只能用于GET请求。

### 安全注意事项：

跨域资源共享和不受同源策略影响的操作有其自身的风险，开发者需要确保其资源和API没有被恶意利用。例如：

- **CORS配置**：不应使用通配符`*`广泛允许所有域访问，应该限制到特定的信任域。
- **JSONP**：由于其运行JavaScript代码的本质，需要防范代码注入和XSS漏洞。

### 总结：

同源策略在保护Web应用安全性方面起到了至关重要的作用，理解其限制和如何安全地跨域访问资源将帮助开发者构建更加安全和智能的Web应用。选择合适的跨域解决方案并确保安全性，是每个Web开发者需关注的重要课题。

## 浏览器的同源策略

### 1.1同源策略概述


同源策略是`浏览器为确保资源安`全，而`遵循的一种策略`，该策略`对访问资源进行了一些限制`。
W3C 上对同源策略的说明：[Same origin policy](https://www.w3.org/Security/wiki/Same_Origin_Policy)。

### 1.2什么是源（origin）？


**1源的组成部分**



![image.png](https://img-blog.csdnimg.cn/img_convert/33a80a2d737e19650ae7757eccd938f6.png)


**下面表格中，只有最后一行的两个源是同源。**

| 源 1                         | 源 2                           | 是否同源 |
| ---------------------------- | ------------------------------ | -------- |
| http://www.xyz.com/home      | https://www.xyz.com/home       | ⛔非同源️  |
| http://www.xyz.com/home      | http://mail.xyz.com/home       | ⛔非同源  |
| http://www.xyz.com:8080/home | http://www.xyz.com:8090/home   | ⛔非同源  |
| http://www.xyz.com:8080/home | http://www.xyz.com:8080/search | ✅同 源︎   |



**同源请求**



![image.png](https://img-blog.csdnimg.cn/img_convert/2081b3b2d85c9d7a0ea9ff82e8663e92.png)


**4非同源请求**





![image.png](https://img-blog.csdnimg.cn/img_convert/9474242fbaf1ee01437a76fd89a4c2e6.png)


**5总结:『所处源』与『目标源』不一致，就是『非同源』，又称『异源』或『跨域』**

## 2跨域会受到哪些限制


例如有两个源：『源A』和『源B』，它们是『非同源』的，那么浏览器会有如下限制：

### 2.1限制DOM访问

『源A』的脚本不能访问『源B』的 DOM。

```cobol
<!-- <iframe id="framePage" src="./demo.html"></iframe> -->

<iframe id="framePage" src="https://www.baidu.com"></iframe>

<script type="text/javascript" >

  function showDOM(){

    const framePage = document.getElementById('framePage')

    console.log(framePage.contentWindow.document) //同源的可以获取，非同源的无法获取
  }
</script>
```

### 2.2限制Cookie访问

『源A』不能访问『源B』的 cookie

```cobol
<iframe id="baidu" src="http://www.baidu.com" width="500" height="300"></iframe>

<script type="text/javascript" >
  // 访问的是当前源的cookie，并不是baidu的cookie
  console.log(document.cookie)
</script>
```

### 2.3限制Ajax获取数据

『源A』可以给『源B』发请求，但是无法获取『源B』响应的数据。

```typescript
const url = 'https://www.toutiao.com/hot-event/hot-board/?origin=toutiao_pc'
let result = await fetch(url)
let data = await result.json();
console.log(data)
```

>  备注：在上述限制中，浏览器对 Ajax 获取数据的限制是影响最大的一个，且实际开发中经常遇到。

## 3几个注意点 

1. `跨域限制仅存在浏览器端`，`服务端不存在`跨域限制。
2. `即使跨域`了，`Ajax 请求也可以正常发出`，但`响应数据不会交给开发者`。
3. <link>、<script>、<img>...... 这些标签发出的请求也可能跨域，只不过浏览器对标签跨域不做严格限制，对开发几乎无影响



![image.png](https://img-blog.csdnimg.cn/img_convert/6ef6a9a11e46dc02ba24e4e6fc18162e.png)

## CORS 解决 Ajax 跨域问题

### 4.1CORS 概述

`CORS` 全称：`Cross-Origin Resource Sharing`（`跨域资源共享`），是用于控制浏览器校验跨域请求的一套规范，服务器依照 CORS 规范，`添加特定响应头来控制浏览器校验`，大致规则如下：

1. 服务器明确表示拒绝跨域请求，或没有表示，则浏览器校验不通过。
2. 服务器明确表示允许跨域请求，则浏览器校验通过。
3. 备注说明：使用 CORS 解决跨域是最正统的方式，且要求服务器是“自己人”。

###  4.2CORS 解决简单请求跨域

整体思路：服务器在给出响应时，通过`添加Access-Control-Allow-Origin响应头`，来`明确表达允许某个源发起跨域请求`，随后浏览器在校验时，直接通过。



![image.png](https://img-blog.csdnimg.cn/img_convert/7fc3d4076e0424a705f91a39b41533fe.png)

服务端核心代码（以express框架为例）：

```cobol
// 处理跨域中间件
function corsMiddleWare(req,res,next){
  // 允许 http://127.0.0.1:5500 这个源发起跨域请求
  // res.setHeader('Access-Control-Allow-Origin','http://127.0.0.1:5500')
  // 允许所有源发起跨域请求
  res.setHeader('Access-Control-Allow-Origin','*')
  next()
}
// 配置路由并使用中间件
app.get('/',corsMiddleWare,(req,res)=>{
  res.send('hello!')
})
```

## CORS添加的字段是什么

跨域资源共享（CORS, Cross-Origin Resource Sharing）通过定义一组HTTP头来允许或限制不同域之间的资源请求。下面是与CORS相关的关键HTTP头字段：

### 请求头（由浏览器自动添加或由客户端手动设置）：

1. **Origin**：每当一个跨域请求（即请求的资源域与当前页面的域不同时）发出时，浏览器自动在请求头中包含此字段。它指示请求最初来自哪个域。

2. **Access-Control-Request-Method**：在预检请求（preflight request）中使用，指定实际请求将使用的方法（例如，GET、POST等）。

3. **Access-Control-Request-Headers**：在预检请求中使用，列出将在实际请求中使用的自定义头部字段。

### 响应头（由服务器响应设置）：

1. **Access-Control-Allow-Origin**：指定哪些域可以访问资源。如果允许所有域访问，则设置为“*”。否则，它会列出允许的特定域。

2. **Access-Control-Allow-Methods**：在预检响应中指定允许的HTTP方法（例如，GET、POST、PUT等）。

3. **Access-Control-Allow-Headers**：在预检响应中指定允许的自定义请求头。

4. **Access-Control-Allow-Credentials**：如果为“true”，则表示是否允许发送身份验证凭据（如Cookies）。不过，当允许的源为“*”时，不允许使用此标头。

5. **Access-Control-Expose-Headers**：此头用于标识可以在响应中访问的安全响应头。默认情况下，只有特定的基本头信息是可见的。

6. **Access-Control-Max-Age**：在预检请求中指定预检的结果可以被缓存的时间（以秒为单位）。

这些字段协同工作以控制和安全管理跨域HTTP请求，确保浏览器从服务器响应中获得正确的访问权限配置。

## 简单请求与复杂请求

CORS 会把请求分为两类，分别是：① `简单请求`、② `复杂请求`。

| 简单请求                                                     | 复杂请求                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ✅请求方法（method）为：`GET`、`HEAD`、`POST`                 | 1不是简单请求，就是复杂请求。 2复杂请求会`自动发送预检请求`。 |
| ✅请求头字段要符合[《CORS 安全规范》](https://fetch.spec.whatwg.org/#cors-safelisted-request-header) 简记：只要不手动修改请求头，一般都能符合该规范。 |                                                              |
| ✅请求头的Content-Type的值只能是以下三种： ●text/plain ●multipart/form-data ●application/x-www-form-urlencoded |                                                              |

### 

**关于预检请求：**

- 发送`时机`：`预检请求在实际跨域请求之前发出`，是由`浏览器自动发起`的。
- 主要`作用`：用于`向服务器确认是否允许接下来的跨域请求`。
- 基本`流程`：先`发起OPTIONS请求`，如果`通过预检`，`继续发起实际的跨域请求`。
- 请求`头内容`：一个`OPTIONS预检请求`，通常会包含如下请求头：

| 请求头                           | 含义                                     |
| -------------------------------- | ---------------------------------------- |
| `Origin`                         | `发起请求的源`                           |
| `Access-Control-Request-Method`  | 实际请求的` HTTP 方法`                   |
| `Access-Control-Request-Headers` | 实际请求中使用的`自定义头`（如果有的话） |

### 4.4CORS 解决复杂请求跨域

1第一步：服务器先通过浏览器的预检请求，服务器需要返回如下响应头：

| 响应头                       | 含义                           |
| ---------------------------- | ------------------------------ |
| Access-Control-Allow-Origin  | 允许的源                       |
| Access-Control-Allow-Methods | 允许的方法                     |
| Access-Control-Allow-Headers | 允许的自定义头                 |
| Access-Control-Max-Age       | 预检请求的结果缓存时间（可选） |





![image.png](https://img-blog.csdnimg.cn/img_convert/b518d361e5d112a0b6cf9f118df52c6e.png)

2第二步：处理实际的跨域请求（与处理简单请求跨域的方式相同）

![image.png](https://img-blog.csdnimg.cn/img_convert/7fc3d4076e0424a705f91a39b41533fe.png)

服务端核心代码：

```javascript
// 处理预检请求
app.options('/students', (req, res) => {
  // 设置允许的跨域请求源
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  // 设置允许的请求方法
  res.setHeader('Access-Control-Allow-Methods', 'GET')
  // 设置允许的请求头
  res.setHeader('Access-Control-Allow-Headers', 'school')
  // 设置预检请求的缓存时间（可选）
  res.setHeader('Access-Control-Max-Age', 7200)
  // 发送响应
  res.send()
})

// 处理实际请求
app.get('/students', (req, res) => {
  // 设置允许的跨域请求源
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  // 随便设置一个自定义响应头
  res.setHeader('abc',123)
  // 设置允许暴露给客户端的响应头
  res.setHeader('Access-Control-Expose-Headers', 'abc')
  // 打印请求日志
  console.log('有人请求/students了')
  // 发送响应数据
  res.send(students)
})
```

### 4.5借助 cors 库快速完成配置

上述的配置中需要自己配置响应头，或者需要自己手动封装中间件，借助cors库，可以更方便完成配置



●安装cors

```less
npm i cors
```

●简单配置cors

```php
app.use(cors())
```

●完整配置cors

```cobol
// cors中间件配置
const corsOptions = {
  origin: 'http://127.0.0.1:5500', // 允许的源
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS'], // 允许的方法
  allowedHeaders: ['school'], // 允许的自定义头

  exposedHeaders: ['abc'], // 要暴露的响应头

  optionsSuccessStatus: 200 // 预检请求成功的状态码
};
app.use(cors(corsOptions)); // 使用cors中间件
```

> 默认`js是不能访问后端设置的响应头的`，`需要后端暴露`

## JSONP 解决跨域问题

1JSONP 概述： JSONP 是`利用了<script>标签可以跨域加载脚本`，且`不受严格限制的特性`，可以说是程序员智慧的结晶，早期一些浏览器不支持 CORS 的时，可以靠 JSONP 解决跨域。


2基本流程：

- 第一步：`客户端创建一个<script>标签`，并将其`src属性设置为包含跨域请求的 URL`，同时`准备一个回调函数`，这个回调函数`用于处理返回的数据`。
- 第二步：`服务端接收到请求后`，将`数据封装在回调函数中并返回`。
- 第三步：`客户端的回调函数被调用`，`数据以参数的形势传入回调函数`。

3图示：



![image.png](https://img-blog.csdnimg.cn/img_convert/a9b69cb4c148848bc9bd6aa7a0474312.png)

4代码示例：

```cobol
<button onclick="getTeachers()">获取数据</button>
<script type="text/javascript" >
  function callback(data){
    console.log(data)
  }

  function getTeachers(url){
    // 创建script元素
    const script = document.createElement('script')
    // 指定script的src属性
    script.src= 'http://127.0.0.1:8081/teachers'
    // 将script元素添加到body中触发脚本加载
    document.body.appendChild(script)
    // script标签加载完毕后移除该标签
    script.onload = ()=>{
      script.remove()
    }
  }
</script>
```

jQuery 封装的 jsonp

> ?callback=?' 为固定格式 会自动解析

```typescript
$.getJSON('http://127.0.0.1:8081/teachers?callback=?',(data)=>{
  console.log(data)
})
```

## JSONP方式为什么能解决跨域？解决跨域有什么样的局限

JSONP（JSON with Padding）是一种古老的方法，用于解决Web应用中的跨域问题。它依赖于浏览器对`<script>`标签的宽松策略，因为通过这种标签加载的脚本不受同源策略限制。这使得JSONP能够实现跨域数据请求，但也有一些局限性和安全问题。

### JSONP解决跨域的机制：

1. **`<script>`标签的特性**：
   - 浏览器允许从其他域加载脚本文件，这意味着通过`<script>`标签可以绕过同源策略来请求数据和执行代码。

2. **回调函数**：
   - JSONP请求通常包括一个回调函数的名称作为参数发送给服务器。服务器收到请求后，将数据封装在这个回调函数中返回。例如：
     ```javascript
     // 客户端请求
     <script src="http://example.com/data?callback=myCallback"></script>
     
     // 服务器响应
     myCallback({ "key": "value" });
     ```
   - 客户端定义的`myCallback`函数将在脚本加载并执行后被调用，并接收到数据作为参数。

### JSONP的局限性：

1. **仅支持GET请求**：
   - JSONP只能通过`<script>`标签进行GET请求，无法使用POST等其他HTTP方法进行数据提交。

2. **安全问题**：
   - JSONP有XSS（跨站脚本攻击）的风险，因为它会执行服务器返回的任何脚本。如果信任的域被攻击，恶意代码可能会被注入到客户应用中。

3. **依赖服务器端支持**：
   - 服务器端必须支持JSONP，即能够根据请求参数返回合适的JavaScript回调格式的数据。很多现代API已经不再支持JSONP。

4. **有限的错误处理**：
   - 由于没有标准的HTTP状态代码，难以处理常规错误信息。通常，JSONP只能通过超时或语法错误来推断失败。

5. **不支持复杂的请求数据结构**：
   - 由于GET请求的限制，包含复杂数据结构或者大数据量的请求可能不适合使用JSONP。

### 总结

JSONP在现代应用中逐渐被淘汰，取而代之的是更安全和灵活的方法，如CORS（跨域资源共享）和服务器代理。然而，由于其简单性和对老旧系统的兼容性，JSONP在某些情况下仍然可能被使用。

## 配置代理解决跨域

### 6.1自己配置代理服务器



> 服务器之间是没有跨域问题的，要使用express 启动静态资源保证自己的服务器跟页面在同源下

```php
// 启动静态资源 让服务器跟页面同一个源
app.use(express.static("./public"));
```

借助http-proxy-middleware配置代理

```php
const { createProxyMiddleware } = require('http-proxy-middleware');
app.use('/api',createProxyMiddleware({

  target:'https://www.toutiao.com',

  changeOrigin:true,

  pathRewrite:{

    '^/api':''

  }
```

 

优点：

- 功能丰富：http-proxy-middleware提供了丰富的配置选项，可以满足各种代理需求。
- 可以灵活配置多个代理：可以配置多个代理服务器，分别对应不同的接口路径。
- 可以拦截请求：可以通过自定义的处理函数对请求进行拦截和修改。

缺点：

- 配置相对复杂：需要了解http-proxy-middleware库的配置规则和参数。
- 不适用于生产环境：http-proxy-middleware主要用于开发环境，不适用于生产环境。

使用场景：

- 适用于使用任何构建工具的前端项目，可以与任何开发服务器配合使用。
- 适用于需要灵活配置多个代理服务器的场景。
- 适用于需要对请求进行拦截和修改的场景。

### 使用 Nginx 搭建代理服务器

整体思路：让nginx充当两个角色，既是 静态内容服务器，又是代理服务器。

修改nginx配置如下，注意nginx的根目录最好不是 C 盘

```cobol
# 配置nginx根目录
location / {
  root   D:\dist;
  index  index.html index.htm;
}
# 配置代理
location /dev/ {
  # 设置代理目标
  proxy_pass http://sph-h5-api.atguigu.cn/;
}
```

2修改前端项目，让所有请求都转发给 /dev，随后重新打包

```php
const request = axios.create({
  baseURL:'/dev',
  timeout:10000
})
```

随后直接访问nginx服务器即可，例如 nginx如果运行在8099端口，则访问

```cobol
http://localhost:8099
```

随后会遇到刷新404问题，追加nginx配置来解决

```cobol
# 配置nginx根目录
location / {
  root   D:\dist;
  index  index.html index.htm;
  try_files $uri $uri/ /index.html; # 解决刷新404
}
# 配置代理
location /dev/ {
  # 设置代理目标
  proxy_pass http://sph-h5-api.atguigu.cn/;
}
```

加上这两个“/”就剔除掉了dev

![img](https://i-blog.csdnimg.cn/direct/cfaa51e3932442a488eb2a44ac542ccd.png)

### 6.3借助脚手架搭建服务器 

1. 使用vue.config.js文件配置代理：

在Vue项目的根目录下创建一个vue.config.js文件，并添加以下代码：

```JS
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}
```

上述代码中，我们使用`devServer`配置项来配置代理服务器。其中`proxy`属性用于配置代理的规则，`/api`表示需要代理的接口路径。`target`属性表示代理的目标服务器地址，`changeOrigin`属性表示是否改变请求的源地址，`pathRewrite`属性用于重写请求的路径。

优点：

- 配置简单：使用webpack-dev-server的代理配置，只需要在webpack配置文件中进行简单的配置即可。
- 功能全面：webpack-dev-server提供了丰富的配置选项，可以满足大部分代理需求。
- 可以拦截请求：可以通过自定义的处理函数对请求进行拦截和修改。

缺点：

- 需要重启服务器：配置修改后需要重新启动webpack-dev-server才能生效。
- 不适用于生产环境：webpack-dev-server主要用于开发环境，不适用于生产环境。

使用场景：

- 适用于使用webpack构建的前端项目，通过webpack-dev-server来启动开发服务器的场景。
- 适用于需要简单的代理配置，并且不需要频繁修改代理配置的场景。

## url的长度限制

1. `HTTP协议本身没有对URL长度做出明确限制`：

   - `HTTP/1.1规范(RFC 2616)并没有规定URL的最大长度`。

2. 然而，在实际应用中，`URL长度可能受到以下因素的限制`：

   a)` 服务器限制`：

   - 不同的Web服务器可能有自己的URL长度限制。
   - 例如，`Apache服务器默认限制URL长度为8192字符`。
   - `Microsoft Internet Information Server` (IIS)默认`限制URL长度为16384字符`。

   b) `浏览器限制：`

   - 不同的浏览器可能对URL长度有不同的处理能力。
   - 例如，Internet Explorer的最大URL长度是2083字符。

   c) `代理服务器和防火墙`：

   - 一些代理服务器或防火墙`可能对长URL有特殊处理或限制`。

   d) 客户端操作系统：

   - 某些操作系统可能对命令行长度有限制，这可能间接影响URL长度。

3. 最佳实践：

   - 尽管理论上URL可以很长，但出于实用性和兼容性考虑，通常建议将URL长度控制在2000字符以内。
   - 对于需要传递大量数据的情况，建议使用POST方法而不是GET。

4. GET方法的注意事项：

   - 虽然`GET方法的URL理论上没有严格限制`，但`过长的URL可能导致以下问题`：
     - `可读性差`
     - `容易出错`
     - 可能`超出服务器或浏览器的处理能力`
     - `安全风险（敏感信息暴露在URL中）`

## 代理服务器转发是正向代理还是反向代理，有什么区别

代理服务器可以实现正向代理和反向代理，这两种类型的代理有不同的用途和特点。让我们来详细了解一下：

正向代理：

1. 定义：正向代理代表客户端向目标服务器发送请求。

2. 工作流程：
   客户端 -> 正向代理服务器 -> 互联网 -> 目标服务器

3. 特点：
   - 客户端知道目标服务器的存在，但目标服务器不知道客户端的真实身份。
   - 通常由客户端配置使用。

4. 用途：
   - 访问被限制的资源（如翻墙）
   - 提高访问速度（缓存）
   - 保护客户端隐私
   - 绕过内容过滤

5. 例子：VPN服务、某些网络加速器

反向代理：

1. 定义：反向代理代表服务器接收来自客户端的请求。

2. 工作流程：
   客户端 -> 互联网 -> 反向代理服务器 -> 目标服务器

3. 特点：
   - 客户端不知道真正的目标服务器，只知道反向代理服务器。
   - 通常由服务器端配置使用。

4. 用途：
   - 负载均衡
   - 保护后端服务器安全
   - 缓存静态内容
   - SSL终结
   - 压缩
   - 提供统一接口

5. 例子：Nginx、HAProxy、CDN服务

主要区别：

1. 代表对象：
   - 正向代理代表客户端
   - 反向代理代表服务器

2. 配置位置：
   - 正向代理通常在客户端配置
   - 反向代理在服务器端配置

3. 可见性：
   - 正向代理对服务器透明
   - 反向代理对客户端透明

4. 主要用途：
   - 正向代理主要用于帮助客户端访问无法直接访问的资源
   - 反向代理主要用于保护和优化服务器资源

5. IP地址：
   - 正向代理隐藏了客户端的真实IP
   - 反向代理隐藏了真实服务器的IP

6. 安全性：
   - 正向代理可能被用来绕过安全限制
   - 反向代理通常用来增强安全性

总的来说，代理服务器转发既可以是正向代理，也可以是反向代理，具体取决于其配置和用途。在实际应用中，正确选择和配置代理类型对于实现预期的网络架构和功能至关重要。

## websocket

websocket之前通过轮询实现高频次的传输,明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源

WebSocket 在建立连接时，初始的握手使用的是标准的 HTTP 协议，这个握手过程中会包含 HTTP 请求和响应头。但是，一旦 WebSocket 连接建立之后，数据交换就不再使用 HTTP 协议，而是转而使用 WebSocket 特有的数据帧格式来传输数据。

WebSocket 使用的是自己的协议，称为 WebSocket 协议。它是一个独立的、基于 TCP 的协议

### 握手过程

- 初始连接使用 HTTP/HTTPS 升级请求
- 之后切换到 WebSocket 协议
  - ws:// (非加密)
  - wss:// (加密，使用 TLS/SSL)
- 端口
  - 默认使用 80 端口 (ws://)
  - 默认使用 443 端口 (wss://)

### 优点

1. 实时性强：WebSocket提供了真正的全双工通信，数据可以实时双向传输。
2. 减少延迟：一旦建立连接，数据传输没有额外的HTTP请求开销，减少了延迟。
3. 更少的网络流量：相比轮询等技术，WebSocket减少了不必要的网络流量。
4. 支持跨域：WebSocket天生支持跨域通信。
5. 保持连接状态：长连接可以保持客户端状态，更容易实现客户端与服务器的实时交互。
6. 更好的二进制支持：相比HTTP，WebSocket更适合传输二进制数据。
   1. 支持二进制帧，可以直接发送和接收二进制数据
   2. 建立连接后，传输数据的帧头很小，减少了额外开销

### 缺点

1. 复杂性增加：相比简单的HTTP请求，WebSocket的实现和管理更为复杂。

2. 服务器压力：长时间保持连接可能会增加服务器的负载。

3. 兼容性问题：某些老旧浏览器可能不支持WebSocket。

4. 连接中断处理：网络不稳定时，需要处理连接中断和重连的情况。

5. 扩展性挑战：在处理大量并发WebSocket连接时，可能面临扩展性问题。




WebSocket 是一种通信协议，为 Web 应用程序提供了全双工通信的能力。与传统的 HTTP 请求-响应模型不同，WebSocket 允许服务器和客户端之间无需请求即可实时进行数据交换。下面是对 WebSocket 的优缺点的深入探讨：

### 优点

1. **全双工通信**:
   - WebSocket 支持双向通信，这意味着客户端和服务器都可以主动发送消息。这对于需要实时响应的应用程序非常有利，如聊天应用、在线游戏和股票交易平台。

2. **低延迟**:
   - WebSocket 连接建立后，数据帧头部最小仅需 2 字节，相较于传统的 HTTP 请求（每次请求都有相对较大的头部），WebSocket 大幅减小了开销，使得数据传输延迟极低。

3. **持久连接**:
   - 一旦建立，WebSocket 连接在通信期间保持开放（除非显式关闭），无需像 HTTP 那样每次请求-响应都握手一次。这减少了握手开销，提升了性能。

4. **更有效的带宽使用**:
   - 由于 WebSocket 消息头较小且不需要反复建立连接，这有效减少了带宽使用，特别适合带宽敏感的应用。

5. **服务器的主动推送能力**:
   - WebSocket 允许服务器主动向客户端推送更新数据，而不需要客户端轮询。对于需要频繁更新的数据（如实时报告、动态仪表盘等），WebSocket 提供了更高效的方案。

6. **标准化协议**:
   - WebSocket 是由 IETF 定义的标准协议（RFC 6455），并被广泛支持在当前的浏览器和服务器平台之上。

### 缺点

1. **建立连接的开销**:
   - 虽然 WebSocket 连接持久，但初次连接的握手依然是基于 HTTP 的，包含一次完整的 HTTP 请求-响应循环，可能导致连接延迟（尤其是在高延迟的网络环境下）。

2. **复杂性**:
   - 开发者需要处理连接的打开、关闭，以及在连接丢失时的重连逻辑。这对开发和维护的要求更高。

3. **安全性**:
   - 虽然 WebSocket 可以使用加密的 `wss://` 协议，但建立在 TCP 之上的持久连接可能成为潜在的攻击向量。需要处理会话劫持、跨站请求伪造和消息验证等安全问题。

4. **不支持离线事务**:
   - WebSocket 需要持续的连接来进行通信，无法像 HTTP 一样，通过缓存实现离线通信。若连接断开，即无法保证消息传递。

5. **可能会引入防火墙问题**:
   - 某些防火墙和代理服务器可能不支持 WebSocket 的长连接，或在闲置时主动断开连接，影响应用的可用性。

6. **服务器成本**:
   - 由于 WebSocket 连接是持久的，服务器需要维持这些连接，要求更高的内存和 CPU 资源，这在大量用户时会增大服务器成本。

### 总结

WebSocket 在需要低延迟、高频次数据更新的应用场景中表现出色，如实时聊天、实时通知、在线协作工具和物联网应用等。然而，由于其带来的复杂性和安全性问题，使用 WebSocket 需要进行合理的评估和设计。对于需要简单、一致性操作的场景，HTTP 或 HTTP/2 这样的传统协议可能仍然是更合适的选择。选择 WebSocket 前，应仔细评估应用的特性和需求，以及负载均衡、连接管理、安全考虑。

## websocket断连怎么处理

在 WebSocket 应用程序中，处理连接断开是实现健壮通信的重要方面。下面是一些常用的方法来处理 WebSocket 连接断开和恢复：

### 1. 处理 `onclose` 事件

监听 WebSocket 对象的 `onclose` 事件，以处理连接断开的情况。你可以在事件处理程序中执行必要的逻辑，例如记录日志、通知用户，或者尝试重新连接。

```javascript
const socket = new WebSocket('ws://example.com');

socket.onclose = function(event) {
    console.log(`WebSocket closed: ${event.code} - ${event.reason}`);
    // 这里可以尝试重连
};
```

### 2. 自动重连机制

实现一个自动重连的机制，以在连接断开时自动尝试重新连接。这通常会涉及到使用指数退避算法来避免频繁的重连请求。 其基本思想是：在每次重试失败后，等待一段逐渐增加的时间，然后再进行下一次重试。这样可以避免在短时间内过于频繁地进行重试操作，从而减少对系统的压力

```javascript
function connectWebSocket() {
    const socket = new WebSocket('ws://example.com');

    socket.onopen = function() {
        console.log('WebSocket connected!');
    };

    socket.onclose = function(event) {
        console.log(`WebSocket closed: ${event.code} - ${event.reason}`);
        // 尝试重连
        setTimeout(() => {
            console.log('Attempting to reconnect...');
            connectWebSocket();
        }, 5000); // 5秒后重连
    };

    socket.onerror = function(error) {
        console.error(`WebSocket error: ${error.message}`);
    };
}

connectWebSocket();
```

### 3. 处理 `onerror` 事件

监听 `onerror` 事件可以帮助你检测到一些连接问题。注意 `onerror` 触发后不一定会伴随连接关闭，所以你可能需要在此进行额外处理。

```javascript
socket.onerror = function(error) {
    console.error(`WebSocket encountered error: ${error.message}`);
    // 可能需要采取措施，比如立即关闭连接
    socket.close();
};
```

### 4. 心跳机制

实现心跳机制以检测连接的存活状态。你可以在服务器和客户端之间定期发送「心跳」消息来保持连接活跃，并及时检测连接问题。

#### 客户端心跳实现示例：

```javascript
let pingInterval;

function startPing(socket) {
    pingInterval = setInterval(() => {
        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'ping' }));
        }
    }, 30000); // 每30秒发送一次ping
}

function stopPing() {
    clearInterval(pingInterval);
}

// 当连接打开时启动心跳
socket.onopen = function() {
    startPing(socket);
};

// 关闭或错误时停止心跳
socket.onclose = stopPing;
socket.onerror = stopPing;
```

### 5. 用户通知机制

在用户界面上提示用户当前的连接状态也是一个良好的用户体验：

- 当连接断开时，显示提示消息 ("正在尝试重新连接...")
- 当连接恢复后，移除或更新消息。

通过结合这些策略，你可以有效地管理 WebSocket 连接的断开和重连，确保应用程序的可靠性和用户体验。

## websocket和http的区别

WebSocket和HTTP是两种用于在客户端（通常是浏览器）和服务器之间进行通信的协议，它们虽然都用于网络通信，但在设计和应用场景上存在显著的区别。

| `WebSocket`                      | `EventSource`            |
| -------------------------------- | ------------------------ |
| 双向：客户端和服务端都能交换消息 | 单向：仅服务端能发送消息 |
| 二进制和文本数据                 | 仅文本数据               |
| WebSocket 协议                   | 常规 HTTP 协议           |

### HTTP

HTTP（Hypertext Transfer Protocol）是一种无状态的协议，主要用于网页浏览和Web应用程序的通信。以下是HTTP的一些关键特性：

1. **请求-响应模式**：
   - HTTP是基于请求-响应模式的协议。客户端发送请求到服务器，服务器处理请求并发送响应回客户端。
   
2. **无状态**：
   - HTTP是无状态的，这意味着每个请求都是独立的，与之前或之后的请求没有关联。虽然可以通过使用Cookies、Sessions等技术来维持某种状态，但HTTP本身是无状态的。

3. **短连接**：
   - HTTP/1.0每次请求都需要新建一个TCP连接。HTTP/1.1 引入了持久连接（Keep-Alive），允许在一个TCP连接上发送多个请求/响应，但在响应完毕后连接通常会关闭。

4. **文本协议**：
   - HTTP是一个文本协议，消息体可以是纯文本、HTML、JSON/XML等，头部信息也是人类可读的文本。

5. **应用层协议**：
   - HTTP是一个基于TCP的应用层协议，使用IP、TCP等协议进行数据传输。默认使用TCP端口80（HTTP）或443（HTTPS）。

#### 示例

```http
GET /index.html HTTP/1.1
Host: www.example.com

HTTP/1.1 200 OK
Content-Type: text/html

<html>
<!-- HTML content here -->
</html>
```

### WebSocket

WebSocket是为了解决HTTP无法持续连接的问题而设计的协议，旨在提供全双工通信——客户端和服务器都可以随时发送消息。以下是WebSocket的关键特性：

1. **全双工通信**：
   - WebSocket允许服务器和客户端之间进行双向通信，客户端和服务器可以在任何时候发送数据，而无需等待对方先发送数据。

2. **持久连接**：
   - WebSocket通过单个TCP连接进行通信，从建立连接到关闭连接期间，这个连接始终保持打开状态。

3. **低开销**：
   - 与HTTP相比，WebSocket因其头部较少（只有在握手阶段使用HTTP的头部信息），因此发送的消息更小，开销更低，更适合实时应用。

4. **二进制和文本传输**：
   - WebSocket不仅支持文本数据传输，还支持二进制数据传输，例如ArrayBuffer和Blob。

5. **建立在TCP之上**：
   - WebSocket也是基于TCP协议的，类似于HTTP，但其设计是用来处理实时通信的应用，默认使用TCP端口80（WebSocket）或443（WebSocket over TLS/SSL，即wss）。

#### 示例

WebSocket连接的建立过程首先通过HTTP的GET请求进行WebSocket握手，然后切换协议：

握手请求：

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

握手响应：

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

之后通信将切换到WebSocket协议，两端可以随时双向发送数据。

客户端示例：

```javascript
let socket = new WebSocket("ws://www.example.com/chat");

socket.onopen = function(event) {
    console.log("Connection established");
    socket.send("Hello Server!");
};

socket.onmessage = function(event) {
    console.log("Received message from server: " + event.data);
};

socket.onclose = function(event) {
    console.log("Connection closed");
};

socket.onerror = function(error) {
    console.log("WebSocket error: " + error.message);
};
```

### 详细对比

| 特性           | HTTP                                           | WebSocket                                                  |
| -------------- | ---------------------------------------------- | ---------------------------------------------------------- |
| 通信模式       | 请求-响应                                      | 全双工                                                     |
| 连接类型       | 短连接（HTTP/1.1可以保持连接，但通常为短连接） | 长连接                                                     |
| 传输的数据类型 | 主要为文本（HTML、JSON、XML等）                | 文本和二进制数据（ArrayBuffer、Blob等）                    |
| 头部开销       | 较大                                           | 较小（握手后开销极低）                                     |
| 适用场景       | 适用于请求-响应模式的通信，如网页浏览、API调用 | 适用于需要实时通信的应用，如在线聊天、实时游戏、股票行情等 |
| 连接端口       | 80（HTTP）或 443（HTTPS）                      | 80（WS）或 443（WSS）                                      |
| 标准           | HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3             | RFC 6455                                                   |

### 适用场景

- **HTTP**：
  - 适合大多数Web服务场景，如加载网页、获取静态资源（CSS、JS、图像等）、调用RESTful API等。
  - 适用于一次性请求和响应的场景，且请求间互不相关。

- **WebSocket**：
  - 适合需要实时交流的场景，例如在线聊天应用、实时游戏、股票行情推送、实时协作工具等。
  - 适用于需要长时间持续通信，且短时间内需要频繁数据交换的场景。

总结来说，HTTP适合传统的请求-响应模式，而WebSocket适合需要高效实时双向通信的应用。了解两者的区别和应用场景，有助于开发者为各类应用选择合适的网络通信协议。

## restful API

RESTful API （Representational State Transfer API） 是一种基于REST（Representational State Transfer）架构风格的设计规范，用于设计和实现网络服务。RESTful API广泛应用于Web服务和网络应用，通过HTTP协议实现资源的创建、读取、更新和删除（CRUD操作）。下面将详细深入地介绍RESTful API的各个方面。

### REST架构风格

REST是一种分布式系统的架构风格，由Roy Fielding在他的博士论文中首次定义。REST架构风格基于以下几个关键原则：

1. **客户端-服务器架构**：
   - 使用客户端-服务器模型实现分离关注点（Separation of Concerns）。客户端负责用户界面和用户交互，而服务器负责数据存储和业务逻辑。

2. **无状态性**：
   - 服务器不在请求之间保存客户端的状态。每个请求都应包含处理该请求所需要的所有信息，这使得请求彼此独立。

3. **可缓存性**：
   - 客户端和服务器都可以缓存响应以提高性能。响应必须定义其是否可缓存以及缓存的有效期。

4. **统一接口**：
   - 通过统一的接口简化和分离客户端和服务器。统一接口包括资源标识、资源操作和消息格式。

5. **分层系统**：
   - 系统可以分为多个层，每一层只与相邻层交互。分层系统有助于构建更灵活、可扩展的系统架构。

6. **按需代码**：
   - 服务器可以扩展客户端的功能，通过提供可执行代码（例如，通过JavaScript），使得客户端可以动态加载功能。

### RESTful API的基本概念

#### 资源

在RESTful API中，资源是API的核心概念。资源可以是任何东西，例如用户、文章、图片等。资源通过URI（Uniform Resource Identifier）标识。URI是资源在网络中的唯一标识符。

例如：
  - `/users`：表示用户资源集合。
  - `/users/123`：表示ID为123的特定用户。

#### HTTP动词

RESTful API使用标准的HTTP动词来进行不同的操作，每个动词对应一种操作：

- **GET**：读取资源。
  - `/users`：获取用户列表。
  - `/users/123`：获取ID为123的用户信息。

- **POST**：创建资源。
  - `/users`：创建新用户。

- **PUT**：更新资源（替换资源）。
  - `/users/123`：更新ID为123的用户信息。

- **PATCH**：部分更新资源。
  - `/users/123`：部分更新ID为123的用户信息。

- **DELETE**：删除资源。
  - `/users/123`：删除ID为123的用户信息。

#### HTTP状态码

RESTful API使用HTTP状态码来指示操作的结果。常用的状态码包括：

- **200 OK**：请求成功。
- **201 Created**：资源成功创建（通常用于POST操作）。
- **204 No Content**：请求成功但没有返回内容。
- **400 Bad Request**：客户端请求错误，例如参数不合法。
- **401 Unauthorized**：未授权，需要认证。
- **403 Forbidden**：已认证但没有权限访问资源。
- **404 Not Found**：资源未找到。
- **500 Internal Server Error**：服务器内部错误。

#### 消息格式

RESTful API通常使用JSON作为消息格式，因为JSON是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成。不过，API也可以使用其他格式如XML。

请求示例（创建新用户 - POST）：

```http
POST /users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "johndoe@example.com"
}
```

响应示例：

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "id": 123,
  "name": "John Doe",
  "email": "johndoe@example.com"
}
```

### RESTful API设计

以下是设计RESTful API的一些最佳实践：

#### 1. 资源命名

资源的命名应使用名词且尽量保持简洁。应当使用复数形式表示资源集合。

```text
/users           // 用户资源集合
/users/123       // 单个用户资源
/products        // 产品资源集合
/products/456    // 单个产品资源
```

#### 2. 动词使用

应利用HTTP动词进行操作，而不是在URL中包含动词：

```text
GET    /users             // 获取用户列表
POST   /users             // 创建新用户
GET    /users/123         // 获取ID为123的用户信息
PUT    /users/123         // 更新ID为123的用户信息
DELETE /users/123         // 删除ID为123的用户信息
```

#### 3. 使用嵌套资源

当资源具有层级关系时，可以使用嵌套的URL结构：

```text
GET /users/123/orders          // 获取用户123的订单列表
GET /users/123/orders/789      // 获取订单ID为789的详细信息
```

#### 4. 过滤、排序和分页

通过查询参数实现数据过滤、排序和分页，以提高查询性能和可用性：

```text
GET /products?category=books&sort=price&order=asc&page=2&limit=10
```

#### 5. API版本控制

为了确保API的可升级性和兼容性，往往需要对API进行版本控制：

```text
GET /v1/users/123          // 使用URL路径指定版本
GET /users/123?version=1   // 使用查询参数指定版本
Header: Accept: application/vnd.example.v1+json  // 使用HTTP头部指定版本
```

#### 6. 错误处理

应使用合适的HTTP状态码和错误消息返回详细的错误信息：

```json
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "InvalidRequest",
  "message": "The field 'email' is required."
}
```

### RESTful API的优缺点

**优点**：

1. **简洁直观**：基于URI和HTTP动词的设计，很自然且易于理解和使用。
2. **无状态、可扩展**：无状态设计使得服务器更容易扩展，负载均衡更简单。
3. **缓存支持**：基于HTTP协议的RESTful API天然支持缓存，提高了性能。
4. **多格式支持**：可以使用JSON、XML等多种格式进行数据传输，灵活性高。

**缺点**：

1. **无状态的限制**：在某些场景下REST无状态性可能会带来额外的开发复杂度，需通过其他方式（如JWT Token等）管理状态。
2. **实时性不足**：对于需要实时通信的应用场景，REST可能无法满足实时要求，而需要使用WebSocket等其他协议。

### RESTful API vs RPC

REST和RPC（Remote Procedure Call）是两种不同的API设计风格：

- **RPC**：基于方法调用的API设计，通常会暴露调用的方法或函数。常见的RPC技术包括SOAP、gRPC等。
- **REST**：基于资源的API设计，更倾向于将操作施加于资源上，而非直接的方法调用。

REST更具资源导向，避免了暴露服务器的内部方法细节，而RPC更关注功能点的暴露和调用方式。

### 结语

RESTful API是当前Web服务设计的主流范式，具备简洁性、可扩展性和灵活性。通过合理设计RESTful API，可以构建出高效、易维护、良好扩展性和高可用性的网络服务。理解REST的核心原则和最佳实践是构建优秀RESTful API的基础。

## https的加密过程（SSL、TLS）

HTTPS (HTTP Secure) 的加密过程主要依赖于 SSL (Secure Sockets Layer) 或其继任者 TLS (Transport Layer Security) 协议。这个过程包括几个关键步骤，主要目的是确保客户端和服务器之间的通信是安全的、加密的、且不被篡改的。以下是 HTTPS 的加密过程的详细说明：

1. 客户端发起请求

当用户在浏览器中输入 HTTPS 网址时，客户端（浏览器）会向服务器发送一个 ClientHello 消息，包含：
- 支持的 SSL/TLS 协议版本
- 支持的加密算法列表
- 一个随机数（Client Random）

2. 服务器响应

服务器收到请求后，会返回 ServerHello 消息，包含：
- 选择的 SSL/TLS 协议版本
- 选择的加密算法
- 服务器的数字证书（包含公钥）
- 另一个随机数（Server Random）

3. 证书验证

客户端收到服务器的响应后，会验证服务器的数字证书：
- 检查证书是否由受信任的证书颁发机构（CA）签发
- 验证证书的有效期
- 检查证书的域名是否匹配

4. 密钥交换

如果证书验证通过，客户端会生成一个预主密钥（Pre-master Secret），并使用服务器的公钥加密这个预主密钥，然后发送给服务器。

5. 会话密钥生成

客户端和服务器都使用预主密钥、Client Random 和 Server Random 来独立计算出相同的会话密钥。这个会话密钥将用于后续的对称加密通信。

6. 完成握手

客户端和服务器互相发送 "Finished" 消息，确认握手过程完成，并验证双方计算出的会话密钥是否一致。

7. 安全通信

握手完成后，客户端和服务器使用协商好的对称加密算法和会话密钥进行后续的通信加密。

关键点：

- 非对称加密（如 RSA）用于安全地交换对称加密的密钥。
- 对称加密（如 AES）用于实际的数据传输，因为它比非对称加密更快。
- 数字证书用于验证服务器的身份，防止中间人攻击。
- 会话密钥是临时的，每次会话都会重新生成，增加安全性。

这个过程确保了 HTTPS 通信的机密性（数据被加密）、完整性（数据不被篡改）和认证（确认通信对象的身份）。

##  OPTIONS 请求

HTTP OPTIONS 请求是一种 HTTP 方法，用于获取目标资源所支持的通信选项的信息。它主要用于以下几个方面：

### [“非安全”请求](https://zh.javascript.info/fetch-crossorigin#fei-an-quan-qing-qiu)

预检请求使用 `OPTIONS` 方法，它没有 body，但是有三个 header：

- `Access-Control-Request-Method` header 带有非安全请求的方法。
- `Access-Control-Request-Headers` header 提供一个以逗号分隔的非安全 HTTP-header 列表。
- `Origin` header 说明请求来自哪里。（如 https://javascript.info）

如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：

- `Access-Control-Allow-Origin` 必须为 `*` 或进行请求的源（例如 `https://javascript.info`）才能允许此请求。
- `Access-Control-Allow-Methods` 必须具有允许的方法。
- `Access-Control-Allow-Headers` 必须具有一个允许的 header 列表。
- 另外，header `Access-Control-Max-Age` 可以指定缓存此权限的秒数。因此，浏览器不是必须为满足给定权限的后续请求发送预检。

1. 跨域资源共享（CORS）预检请求：
   - 在进行复杂跨域请求之前，浏览器会先发送一个 OPTIONS 请求，以确定实际请求是否安全。
   - 服务器通过响应头指示允许的方法、头部和源。
2. 服务器功能探测：
   - 客户端可以使用 OPTIONS 请求来确定服务器支持哪些 HTTP 方法。
3. 缓存验证：
   - 可用于检查缓存的响应是否仍然有效。

主要特点：

1. 安全性：OPTIONS 是一个安全的方法，不应改变服务器状态。
2. 幂等性：多次相同的 OPTIONS 请求应该产生相同的结果。
3. 响应头：
   - Allow：列出支持的 HTTP 方法
   - Access-Control-Allow-Methods：CORS 中允许的方法
   - Access-Control-Allow-Headers：CORS 中允许的请求头
   - Access-Control-Allow-Origin：允许的源
4. 无响应体：通常 OPTIONS 请求不需要响应体，所有信息都在头部。

示例 OPTIONS 请求：

```HTTP
OPTIONS /resource/foo HTTP/1.1
Host: example.org
Access-Control-Request-Method: POST
Access-Control-Request-Headers: origin, x-requested-with
Origin: https://foo.example
```

示例响应：

```http
HTTP/1.1 204 No Content
Allow: GET, POST, HEAD, OPTIONS
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: origin, x-requested-with
Access-Control-Max-Age: 86400
```

使用场景：

1. 浏览器自动发起，用于 CORS 预检。
2. API 开发中，用于检查端点支持的操作。
3. 安全扫描，探测服务器配置。

注意事项：

- 正确配置 OPTIONS 响应对于 CORS 至关重要。
- 不应在 OPTIONS 中暴露敏感信息。
- 某些防火墙可能会阻止 OPTIONS 请求，需要适当配置。

了解 OPTIONS 请求有助于处理跨域问题和设计 RESTful API。

## RESTful API

RESTful API（Representational State Transfer API）是一种基于 HTTP 协议设计的软件架构风格，用于创建可扩展的 Web 服务。它由 Roy Fielding 在 2000 年的博士论文中提出。RESTful API 遵循一系列约束和原则，旨在简化和标准化 Web 服务的设计和实现。

RESTful API 的主要特征和原则：

1. 资源导向（Resource-Oriented）：
   - 所有内容都被视为资源
   - 每个资源都有唯一的标识符（URI）
   - 示例：/users, /products/123

2. 使用 HTTP 方法：
   - GET：读取资源
   - POST：创建新资源
   - PUT：更新整个资源
   - PATCH：部分更新资源
   - DELETE：删除资源

3. 无状态（Stateless）：
   - 每个请求包含所有必要的信息
   - 服务器不保存客户端状态

4. 客户端-服务器分离：
   - 提高可移植性和可扩展性

5. 统一接口：
   - 简化和解耦架构

6. 分层系统：
   - 允许架构由多个层组成

7. 可缓存性：
   - 响应应明确标记是否可以缓存

8. 表现层（Representations）：
   - 资源可以有多种表现形式（如 JSON, XML）
   - 使用 Accept 和 Content-Type 头部协商

RESTful API 设计最佳实践：

1. 使用名词而非动词作为 URI：
   好：/users
   差：/getUsers

2. 使用复数形式：
   /users 而不是 /user

3. 使用 HTTP 状态码：
   200 OK, 201 Created, 400 Bad Request, 404 Not Found 等

4. 版本控制：
   /api/v1/users

5. 分页和过滤：
   /users?page=2&limit=20

6. HATEOAS（Hypertext As The Engine Of Application State）：
   在响应中包含相关资源的链接

7. 使用嵌套资源表示关系：
   /users/123/orders

8. 一致性命名约定

示例 RESTful API 端点：

1. GET /users - 获取所有用户
2. GET /users/123 - 获取特定用户
3. POST /users - 创建新用户
4. PUT /users/123 - 更新用户
5. DELETE /users/123 - 删除用户
6. GET /users/123/orders - 获取用户的订单
7. POST /users/123/orders - 为用户创建新订单

RESTful API 的优势：

1. 简单性和可读性
2. 可扩展性
3. 高性能（通过缓存）
4. 可靠性
5. 适合无状态的移动应用开发

注意事项：

1. 安全性：需要实现适当的身份验证和授权
2. 速率限制：防止 API 滥用
3. 文档：提供清晰的 API 文档
4. 错误处理：提供有意义的错误信息

## 浏览器的最大请求数量是多少，为什么这么设计？

不同浏览器对同一个域名（origin）施加的最大并发请求数量各不相同，这个限制通常被称为“并发连接限制”或“并行连接限制”。这些限制存在的原因是为了均衡网络资源，避免服务器过载，并优化整体网络性能和用户体验。

### 常见浏览器的最大并发请求数量

一个大致的参考数据是这样的（具体版本可能会有所不同）：

- **Google Chrome**: 6 个并发请求
- **Mozilla Firefox**: 6 个并发请求
- **Microsoft Edge**: 6 个并发请求 (基于 Chromium)
- **Safari**: 6 个并发请求
- **Internet Explorer 11**: 6 个并发请求

### 设计这种限制的原因

1. **网络资源优化**：
    - **减少带宽争用**：如果允许任意数量的并发连接，一个页面可能会占用不公平的网络带宽，从而导致网络拥塞，影响其他用户的体验。
    
2. **减轻服务器负载**：
    - **防止服务器过载**：过多的并发连接可能会导致服务器资源枯竭，影响其稳定性。在这种情况下，限制每个客户端的并发连接数有助于维持服务器的正常运行。
    
3. **用户体验**：
    - **页面加载优化**：有限制的并发连接数量有助于更好地管理资源，可以避免因为过多的连接而导致的页面加载帧的阻塞，从而提高用户体验。
    
4. **防止滥用**：
    - **防止 DoS 攻击**：限制并发连接数量可以在一定程度上防止某些类型的拒绝服务（DoS）攻击，有效管理服务器的负载。

### 设计实践

浏览器的并发请求限制并不是一个绝对数值，在实际设计中，可能会根据不同环境和需求进行调整，但通常都有类似的目的和理由：

- **保持公平性**：确保所有用户都能公平地使用网络资源，而不会因为某些请求特别多的用户影响其他人的体验。
- **优化性能**： 在大多数情况下，6 个并发连接数量在现代网络环境下能够提供良好的用户体验。它有助于浏览器在能够并行加载资源的同时，不至于导致过度的资源竞争。
- **兼容性**：浏览器开发者在设定这些限制的时候，也会考虑与现有网络基础设施的兼容性，包括服务器、CDN 以及常见的网络拓扑结构[error]

## 浏览器的缓存？etag的优缺点

浏览器缓存是指浏览器保存一些特定资源（如 HTML、CSS、JavaScript、图像等）的副本，以便在后续请求相同资源时能更快地加载，提高页面加载的效率和用户体验。

### 浏览器缓存类型

1. **强制缓存 (Force Cache)**：
   - **Expires**：HTTP 响应头中的 `Expires` 字段指定了一个确切的日期和时间，在此之前，资源被认为是新鲜的，可以直接从缓存中加载，而不需要向服务器发送请求。
   - **Cache-Control**：相比 `Expires` 更为现代和灵活，如 `max-age` 指定在多少秒内资源被认为是新鲜的，`public` 和 `private` 表示缓存的范围等。

2. **协商缓存 (Conditional Cache)**：
   - **ETag**：实体标签，服务器为每个资源生成的唯一标识，通常是资源内容的哈希值。浏览器在执行缓存验证时，会将上一次返回的 `ETag` 值通过 `If-None-Match` 头发送到服务器，服务器比较这些值，如果资源没有改变，返回 304 状态码，告诉浏览器继续使用缓存。
   - **Last-Modified**：指示资源最后一次修改的时间。浏览器在执行缓存验证时，将上一次返回的 `Last-Modified` 值通过 `If-Modified-Since` 头发送到服务器，服务器比较这些值，如果资源没有修改，返回 304 状态码。

### ETag 的优缺点

#### 优点

1. **更精确**：
   - **精确的内容验证**：ETag 基于内容生成，能够在资源内容稍微变化时检测到变化，相比 `Last-Modified`，ETag 更为精确。
   - **部分内容更新支持**：当资源进行部分更新（如文件的某些部分改变），ETag 可以通过不同的标识来实现细粒度的缓存控制和验证。

2. **跨时间区和文件系统一致性**：
   - **跨时区问题**：不用担心服务器和客户端间的时区差异，ETag 采用内容哈希值，避免了时间不一致的问题。
   - **文件系统精度问题**：在某些系统上，时间戳的精度可能不够，而 ETag 可以提供字节级的变化检测。

#### 缺点

1. **生成开销**：
   - **服务器计算资源**：生成 ETag 需要计算资源，通常通过哈希算法生成，对于大型资源或高并发服务器，会有额外的计算开销。
   
2. **缓存一致性问题**：
   - **负载均衡问题**：在负载均衡环境下，如果多个服务器返回不同的 ETag 标识，则会影响缓存的一致性。通常需要确保所有服务器生成 ETag 的算法和策略一致。
   
3. **缓存头长度**：
   - **Header 头长度**：ETag 是一个哈希值，可能会增加 HTTP 请求和响应头部的长度，在某些网络条件下会有影响。

### 小结

- **ETag 的优点在于其精确而灵活的缓存控制，适用于需要精确缓存验证的场景。**
- **缺点主要在于服务器负载和复杂的缓存一致性管理。**

在实际应用中，可以综合使用 ETag 和其他缓存策略（如 `Last-Modified`、`Cache-Control`）来优化缓存性能和用户体验，权衡不同方案的优缺点，根据具体需求和环境选择合适的策略。

## axios原理

`axios` 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js。它提供了一系列用于发送 HTTP 请求和处理响应的函数，同时提供了便利的配置和高级功能。但了解它背后的工作原理可以帮助我们更好地使用它。

### axios 的核心组成

1. **主模块**：这是 `axios` 的主要入口模块，负责创建 `axios` 实例，对外暴露 API。
2. **请求适配器（Adapter）**：针对不同的环境（浏览器环境和 Node.js 环境），`axios` 提供了不同的请求适配器来实际发起请求。在浏览器中使用 `XMLHttpRequest` 或 `fetch` API，在 Node.js 中使用 `http` 模块。
3. **拦截器（Interceptors）**：提供请求和响应的拦截功能，允许在请求或响应被处理前做一些处理操作。
4. **请求/响应配置**：配置请求/响应的默认参数，如请求头、超时时间等。

### axios 的工作流程

1. **实例初始化**：用户调用 `axios.create` 或直接调用 `axios`，创建一个 `axios` 实例。
2. **配置处理**：合并用户指定的配置和默认配置。
3. **请求拦截器**：在请求被发送前会依次通过所有配置的请求拦截器，进行预处理（如添加 token、修改请求头等）。
4. **请求发送**：根据当前环境（浏览器或 Node.js），选择合适的适配器发送 HTTP 请求。
5. **响应拦截器**：请求响应回来后，通过所有配置的响应拦截器进行处理（如全局错误处理、响应格式化等）。
6. **返回结果**：最终返回处理后的响应结果给调用者。

### axios 的基本工作原理

```javascript
const axios = require('axios');

// 创建实例
const instance = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 1000,
  headers: { 'Authorization': 'Bearer token' }
});

// 添加请求拦截器
instance.interceptors.request.use(config => {
  // 在请求发送前做一些处理
  config.headers['X-Custom-Header'] = 'foobar';
  return config;
}, error => {
  // 处理请求错误
  return Promise.reject(error);
});

// 添加响应拦截器
instance.interceptors.response.use(response => {
  // 对响应数据做一些处理
  return response.data;
}, error => {
  // 处理响应错误
  return Promise.reject(error);
});

// 发送请求
instance.get('/user')
  .then(response => {
    console.log(response); // 处理响应数据
  })
  .catch(error => {
    console.error(error); // 处理响应错误
  });
```

### axios 的重要模块说明

#### 1. 适配器（Adapter）

适配器是 `axios` 用于不同环境下的请求发起机制。在浏览器里面，适配器一般使用 `XMLHttpRequest` 来发送请求；在 Node.js 环境中，适配器使用 Node.js 的 `http` 模块。

```javascript
// 伪代码示例
function xhrAdapter(config) {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open(config.method.toUpperCase(), config.url);
    request.timeout = config.timeout;
    request.onload = () => resolve(request.response);
    request.onerror = () => reject(new Error('Network Error'));
    request.ontimeout = () => reject(new Error('Timeout Error'));
    request.send(config.data);
  });
}
```

#### 2. 拦截器（Interceptors）

拦截器使得 `axios` 在发送请求和处理响应时有较高的灵活性，可以实现全局统一的处理和自定义操作。

```javascript
// 添加请求拦截器
axios.interceptors.request.use(config => {
  // 在请求发送前做一些处理
  return config;
}, error => {
  // 处理请求错误
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(response => {
  // 对响应数据做一些处理
  return response;
}, error => {
  // 处理响应错误
  return Promise.reject(error);
});
```

#### 3. 配置管理

`axios` 允许在全局和实例级别管理默认配置，每个请求也可以单独配置，最终是通过合并配置来实现灵活性。

```javascript
// 创建实例时配置默认参数
const axiosInstance = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 1000,
  headers: { 'Authorization': 'Bearer token' }
});

// 单个请求时也可以自定义参数
axiosInstance.get('/user', {
  params: { ID: 12345 }
})
.then(response => {
  console.log(response);
})
.catch(error => {
  console.error(error);
});
```

### 总结

`axios` 通过模块化的设计、灵活的配置和强大的拦截器机制，使得 HTTP 请求处理变得非常简洁和高效。它的核心在于通过不同环境适配器发起请求，使用拦截器进行请求和响应的预处理和后处理，以及灵活的配置管理来满足不同场景的需求。这样，即使在复杂的应用中，`axios` 仍然可以提供一致且简便的接口来处理 HTTP 请求。

## 有了IPV4为什么还要有IPV6

IP地址是用来标识网络上的设备的唯一标识符。互联网协议版本4（IPv4）和版本6（IPv6）是当前主要的两种网络协议。虽然IPv4在过去几十年里成功地支持了互联网的蓬勃发展，但随着时间的推移，它的局限性逐渐显现，IPv6应运而生。以下是对两者的深入分析及IPv6发展强调的原因：

### IPv4的局限性

1. **地址空间有限**：
   - IPv4使用32位地址空间，总共可以提供约43亿（\(2^{32}\)）个唯一地址。对于互联网早期，这个数量似乎足够，但随着互联网设备（智能手机、物联网设备、计算机等）的爆炸性增长，公网IPv4地址资源变得稀缺。

2. **地址耗尽与分配复杂性**：
   - 在全球范围内，IPv4地址耗尽已成为长期存在的问题。网络地址翻译（NAT）出现，以缓解地址耗尽问题，通过允许多个设备共享单个IP地址起作用，但也增加了网络复杂性，并对点对点连接提出了挑战。

3. **网络性能与安全**：
   - 随着扩展和复杂的网络结构的加入，NAT在安全、路由和性能上都存在诸多挑战。此外，IPv4没有内置的端到端加密和更强的认证方案。

### IPv6的优势

1. **更大的地址空间**：
   - IPv6采用128位地址空间，这意味着可以提供约 \(3.4 \times 10^{38}\) 个地址（340多万亿个亿个地址），可以充分满足未来的互联网需求，包括物联网的快速发展。

2. **简化的地址配置**：
   - IPv6支持自动配置（Stateless Address Autoconfiguration），使得设备可以在不需要外部配置服务（如DHCP）的情况下自动获得IP地址，从而简化了网络配置和管理。

3. **内置安全**：
   - IPv6协议设计时就集成了IPsec（Internet Protocol Security），这为网络层提供了更高的安全保证，支持数据包的加密以及更安全的身份验证。

4. **更优的路由效率**：
   - IPv6采用简化的报头格式，以及更有效的分组转发与处理，提升了路由效率。对于较大规模的网络，IPv6可以更好地简化路由表，并提高路由精度。

5. **去掉NAT的需求**：
   - 由于IPv6拥有充足的地址空间，可以分配给每台设备唯一的公网地址，因此消除了NAT的需求，促进了端到端的直接通信，这对新兴的应用场景如P2P、VoIP有非常积极的影响。

6. **支持新的服务**：
   - IPv6通过扩展报头和更灵活的数据传输，为未来网络服务发展提供了可能性，例如基于IPv6多播的更丰富的多媒体应用。

### IPv6的挑战

虽然IPv6具有许多优越性，但其推广面临一些挑战：

1. **过渡成本**：
   - 如果企业或运营商已有完善的现有IPv4基础设施，转向IPv6需要投入额外的成本进行升级硬件、软件和培训。

2. **兼容性**：
   - IPv4与IPv6是不可互通讯的（本质上两个独立的网络层协议），因此在过渡期需要具有“两栖”性，可以同IPv4、IPv6同时工作以保证互操作性。

3. **普及缓慢**：
   - 尽管IPv6的部署和应用正在加速，但全球快速全面应用仍需时间。

### 总结

IPv6的出现与发展是对互联网繁荣发展的有效响应，提供了一个具备相对长远适用性的解决方案。伴随着全球数字化和互联网通信需求的不断扩大，IPv6在支持更广阔网络生态系统中的关键角色愈发显著。推动IPv6的发展不仅解决了IPv4的局限性，也为互联网的未来创新服务提供了更坚实的基础。

## http-only

HTTP-only 是一个设置在 Cookie 上的标记，它是一个安全特性，用于帮助防止跨站脚本攻击（XSS）。当一个 Cookie 被标记为 HTTP-only 时，它具有以下特性：

1. 限制访问：

   - JavaScript 无法通过 document.cookie 访问这个 Cookie。
   - 这个 Cookie 只能被服务器访问，不能被客户端脚本读取。

2. 安全性提升：

   - 即使网站存在 XSS 漏洞，攻击者也无法通过 JavaScript 窃取这个 Cookie。
   - 特别适合存储敏感信息，如身份验证令牌。

3. 设置方法：

   - 服务器在设置 Cookie 时，通过添加 HttpOnly 标志来创建 HTTP-only Cookie。

   例如，在 HTTP 响应头中：

   ```
   Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; HttpOnly
   ```

4. 兼容性：

   - 大多数现代浏览器都支持 HTTP-only Cookie。

5. 限制：

   - HTTP-only Cookie 不能通过客户端 JavaScript 设置，只能由服务器设置。

6. 用途：

   - 通常用于存储 session ID、认证令牌等敏感信息。
   - 不适用于需要在客户端 JavaScript 中访问的数据。

7. 注意事项：

   - 虽然增加了安全性，但不应该被视为唯一的安全措施。
   - 应该与其他安全实践（如 HTTPS、适当的 CORS 策略等）结合使用。

8. 验证：

   - 可以通过浏览器的开发者工具查看 Cookie 是否设置了 HTTP-only 标志。

示例（Node.js 中设置 HTTP-only Cookie）:

```javascript
res.cookie('session_id', '1234567890', {
    httpOnly: true,
    secure: true, // 仅在 HTTPS 连接中发送
    sameSite: 'strict' // 防止 CSRF 攻击
});
```

总之，HTTP-only Cookie 是一种重要的安全机制，特别是在处理用户认证和会话管理时。它通过限制客户端脚本对 Cookie 的访问，显著降低了某些类型的攻击风险，尤其是跨站脚本攻击（XSS）。

## 先跳了一个网址、后面又自动跳了一个网址、 这种情况下第一个请求收到的http状态码是多少？

HTTP状态码用于表示服务器响应客户端请求的状态。状态码分为五大类，每类有不同的具体状态码。下面列出了一些常见的HTTP状态码：

### 1xx: 信息响应
- **100 Continue**: 继续请求。
- **101 Switching Protocols**: 切换协议。

### 2xx: 成功响应
- **200 OK**: 请求成功。
- **201 Created**: 已创建，通常用于POST请求。
- **202 Accepted**: 请求已接受，但尚未处理。
- **204 No Content**: 请求成功但无内容返回。

### 3xx: 重定向
- **300 Multiple Choices**: 多种选择。
- **301 Moved Permanently**: 资源已永久移动到新URL。
- **302 Found**: 临时重定向。
- **303 See Other**: 请求的资源在另一个URL。
- **304 Not Modified**: 资源未修改，使用缓存。
- **307 Temporary Redirect**: 请求的资源临时从另一个URL响应。
- **308 Permanent Redirect**: 请求的资源永久从另一个URL响应。

### 4xx: 客户端错误
- **400 Bad Request**: 请求无效。
- **401 Unauthorized**: 未认证。
- **403 Forbidden**: 禁止访问。
- **404 Not Found**: 资源未找到。
- **405 Method Not Allowed**: 请求方法不允许。
- **409 Conflict**: 请求冲突。

### 5xx: 服务器错误
- **500 Internal Server Error**: 服务器内部错误。
- **501 Not Implemented**: 服务器不支持请求方法。
- **502 Bad Gateway**: 网关错误。
- **503 Service Unavailable**: 服务不可用。
- **504 Gateway Timeout**: 网关超时。

### 重定向场景的状态码
在你提供的场景中，如果客户端访问一个URL（例如A），此URL的服务器响应一个重定向到另一个URL（例如B），而B又重定向到另一个URL（例如C），那么客户端根据第一个请求收到的HTTP状态码是：

- **302 Found** 或者 **301 Moved Permanently**：如果A的服务器相应。
- **307 Temporary Redirect** 或者 **308 Permanent Redirect**：如果A的服务器使用这些码。

具体来讲：
- **301 Moved Permanently**: 如果A的资源被永久移动到新URL。
- **302 Found**: 如果A的资源临时位于新URL。
- **308 Permanent Redirect**: A的资源被永久移到新URL，并且方法不变。
- **307 Temporary Redirect**: A的资源在临时的新URL，并且方法不变。

因此，如果在第一个请求中，服务器指定了一个永久或临时新的URL，那么客户端将收到以下状态码之一作为响应：
- **301 Moved Permanently**
- **302 Found**
- **307 Temporary Redirect**
- **308 Permanent Redirect**

例如：
```http
HTTP/1.1 302 Found
Location: https://exampleB.com
```
这表示第一个请求收到302状态码，并且浏览器会自动重定向到B。

```
HTTP/1.1 301 Moved Permanently
Location: https://exampleC.com/new-location
```
这表示第一个请求会收到301状态码。

## xhr和fetch区别

XMLHttpRequest (XHR) 和 Fetch 都是用于在Web应用中进行网络请求的API，但它们有许多不同之处。以下是它们的主要区别：

### 1. 简单性和现代性

**Fetch**：
- Fetch 是现代的、基于Promise的API，设计更简洁、现代。
- 使用起来更加简洁，避免了许多传统 XHR 模式中的回调地狱。
- 更加语义化，代码更易读。

**XMLHttpRequest (XHR)**：
- XHR 是旧的、基于回调的API。
- 语法较复杂，代码较难读。
- 使用时需要处理大量的状态变化和回调。

### 2. 基于 Promise

**Fetch**：
- 基于 Promise，可以使用 `.then()` 和 `.catch()` 链式处理。
- 易于与 `async` 和 `await` 一起使用。

**XMLHttpRequest (XHR)**：
- 基于回调，需要设置 `onreadystatechange` 或其他事件处理程序来处理响应。
- 无内置 Promise 支持，需要手动封装 Promise。

### 3. 响应处理

**Fetch**：
- 默认不会拒绝HTTP错误状态，如 `404` 或 `500`；这些状态仍然会被当作成功的请求，需要手动处理。
- 使用 `Response` 对象，提供了多种方法来处理不同类型的响应 (`text()`, `json()`, `blob()` 等)。

**XMLHttpRequest (XHR)**：
- 必须手动检查HTTP状态码来判断请求是否成功。
- 响应数据储存在 `xhr.responseText` 或 `xhr.responseXML` 属性中。

### 4. 定制和控制

**Fetch**：
- 更适用于更高级的定制，例如 Headers 对象、自定义请求和权限处理。
- 没有内置对超时、进度监测的支持，但可以通过其他方式封装来实现。
- 不能直接取消请求，但可以使用 `AbortController` 结合 `fetch` 实现请求取消。

**XMLHttpRequest (XHR)**：
- 内置对请求的超时和进度监测的支持 (`xhr.timeout`, `xhr.ontimeout`, `xhr.upload.onprogress` 等)。
- 直接提供请求取消的功能 (`xhr.abort()`)。

### 5. 跨域请求和凭证

**Fetch**：
- 更加严格的跨域规则，需要明确指定 `credentials` 选项（如 `same-origin`, `include`）。
- 默认不会发送Cookie，但通过设置 `credentials: 'same-origin'` 或 `credentials: 'include'` 可以管理cookie。

**XMLHttpRequest (XHR)**：
- 默认情况下会根据同源策略发送Cookie；可以通过设置 `xhr.withCredentials` 控制跨域请求是否发送Cookie和HTTP认证信息。

### 例子对比

**Fetch**：
```javascript
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error('There was a problem with the fetch operation:', error);
    });
```

**XMLHttpRequest (XHR)**：
```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
        if (xhr.status === 200) {
            var data = JSON.parse(xhr.responseText);
            console.log(data);
        } else {
            console.error('There was a problem with the request:', xhr.statusText);
        }
    }
};
xhr.send();
```

### 总结

- **Fetch API** 是新的、简洁的、更具现代浏览器友好性的选择，默认使用Promise来处理异步操作，易与 `async` 和 `await` 搭配。
- **XMLHttpRequest (XHR)** 是较老的API，虽然功能强大，但使用起来相对繁琐，依赖回调来处理异步操作。

在新的 Web 开发项目中，建议优先使用 Fetch API，除非有特定需求必须使用 XHR，例如需要处理上传进度、超时等。

## websocket请求头与http请求头哪里不一样

WebSocket 请求头和 HTTP 请求头最大的区别在于 WebSocket 是一种 **升级后的 HTTP 连接**，用于实现持久的双向通信。因此，WebSocket 请求头中包含了一些特殊的字段来完成协议升级和建立连接。

**1. 连接的建立方式:**

* **HTTP:** 客户端发起请求，服务器响应，连接断开。每次交互都需要建立新的连接。
* **WebSocket:** 客户端发起 HTTP 握手请求，服务器响应后升级为 WebSocket 连接。连接建立后，双方可以持续双向通信，直到连接被关闭。

**2. 请求头的区别:**

* **WebSocket 请求头:**
    * **Connection: Upgrade:**  表示客户端希望将连接升级到 WebSocket 协议。
    * **Upgrade: websocket:** 指定要升级到的协议为 WebSocket。
    * **Sec-WebSocket-Key:** 客户端随机生成的密钥，用于验证连接。
    * **Sec-WebSocket-Version:** 指定 WebSocket 协议版本，通常为 13。
    * **Sec-WebSocket-Protocol (可选):**  用于协商子协议，例如 chat, notification 等。

* **HTTP 请求头:**
    * **Method:**  请求方法，例如 GET, POST 等。
    * **Host:**  请求的服务器地址和端口。
    * **User-Agent:**  客户端信息，例如浏览器版本。
    * **Accept:**  可接受的响应内容类型。
    * **Content-Type:**  请求体的数据类型。

**3. 响应头的区别:**

* **WebSocket 响应头:**
    * **Connection: Upgrade:**  服务器同意升级连接。
    * **Upgrade: websocket:**  确认升级协议为 WebSocket。
    * **Sec-WebSocket-Accept:**  服务器根据客户端提供的 Sec-WebSocket-Key 计算出的响应值，用于验证连接。

* **HTTP 响应头:**
    * **Status:**  响应状态码，例如 200 OK, 404 Not Found 等。
    * **Content-Type:**  响应体的数据类型。
    * **Content-Length:**  响应体的长度。

**总结:**

WebSocket 请求头中包含了 `Upgrade`, `Connection`, `Sec-WebSocket-Key` 等特殊字段，用于完成协议升级和建立 WebSocket 连接。而 HTTP 请求头则用于描述 HTTP 请求的具体信息，例如请求方法、地址、数据类型等。

## fetch，ajax，xhr和axios

`fetch`、`XMLHttpRequest (XHR)`、`Ajax` 和 `axios` 是用于处理 HTTP 请求的不同方式和工具，每种都有其特点和使用适合的场景。下面详细介绍它们的区别和使用方法。

### 1. XMLHttpRequest (XHR)

#### 描述
`XMLHttpRequest` 是用于在客户端与服务器之间交换数据的 API。它可以用来发送数据到服务器以及从服务器获取数据，而无需刷新整个页面。它是实现 Ajax 的基础。

#### 使用方法

创建一个 `XMLHttpRequest` 对象，然后使用它的各种方法来发送请求。

```javascript
const xhr = new XMLHttpRequest();

// 配置请求类型和URL
xhr.open('GET', 'https://api.example.com/data', true);

// 设定回调函数
xhr.onreadystatechange = function () {
  if (xhr.readyState === XMLHttpRequest.DONE) {
    if (xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText));
    } else {
      console.error('Request failed with status:', xhr.status);
    }
  }
};

// 发送请求
xhr.send();
```

#### 特点
- 相对复杂，支持所有主流浏览器。
- 回调地狱（尤其是处理复杂请求链条时）。
- 手动处理 JSON 数据。
- 处理响应状态需要多个回调。

### 2. Ajax

#### 描述
`Ajax`（Asynchronous JavaScript and XML）实际上是指一套用于创建异步网页应用的技术集合，而不是特定的单一技术。`Ajax` 的核心是 `XMLHttpRequest`。

Ajax的全称是Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求，而不需要重载（刷新）整个页面。

是基于XHR原生开发的，目前已有的fetch可替代。本身是针对[mvc](https://zhida.zhihu.com/search?q=mvc&zhida_source=entity&is_preview=1)的编程模式，不太适合目前[mvvm](https://zhida.zhihu.com/search?q=mvvm&zhida_source=entity&is_preview=1)的编程模式。jQuery本身比较大，如果单纯的使用ajax可以自己封装一个，不然会影响性能体验。

#### 使用方法

可以使用各种库（如 jQuery）来简化 Ajax 请求。

```javascript
$.ajax({
  url: 'https://api.example.com/data',
  type: 'GET',
  success: function (data) {
    console.log(data);
  },
  error: function (error) {
    console.error('Request failed:', error);
  }
});
```

#### 特点
- 依赖第三方库，如 jQuery。
- 提供统一的接口，简化了异步请求代码。
- 比起原生 `XMLHttpRequest` 更易用，但冗余代码多。

### 3. Fetch

#### 描述
`fetch` 是一个现代化的 API，用于现代浏览器进行网络请求。它返回一个 `Promise`，简化了异步请求的处理。

#### 使用方法

使用 `fetch` 发起请求并处理响应。

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok ' + response.statusText);
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error('Fetch error:', error);
  });
```

#### 特点
- 基于 Promise，更加简洁和现代化。
- 默认不发送 cookies（需设置 `credentials`）。
- 不支持进度事件（如文件上传进度）。
- 需要 polyfill 以支持老版本浏览器。

### 4. Axios

#### 描述
`axios` 是基于 `Promise` 的用于浏览器和 `Node.js` 的 HTTP 客户端。它提供了一些高级特性和便利功能。

axios也是对原生XHR的一种封装，不过是Promise实现版本。它是一个用于浏览器和 nodejs 的 HTTP 客户端，符合最新的ES规范。

#### 使用方法

安装 `axios` 并发起请求。

```javascript
// 安装 axios：npm install axios

const axios = require('axios'); // Node.js 环境
// 或者在浏览器中使用 <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

axios.get('https://api.example.com/data')
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    console.error('Axios error:', error);
  });
```

#### 特点
- 自动转换 JSON 数据。
- 默认支持并发请求取消（通过 `CancelToken`）。
- 能够处理并发请求（通过 `axios.all`）。
- 支持拦截请求和响应，方便处理通用逻辑（如认证，错误处理）。
- 易于扩展，支持创建实例，可以配置默认参数（如 base URL）。
- 默认支持发送 cookies。

### 细节对比

#### 1. 异步和同步
- **XMLHttpRequest**：支持异步和同步请求（不推荐同步）。
- **fetch**：仅支持异步请求。
- **axios**：仅支持异步请求。

#### 2. 请求取消
- **XMLHttpRequest**：可以通过 `abort` 方法取消请求。
- **fetch**：可以通过 `AbortController` 取消请求。
- **axios**：提供 `CancelToken` 取消请求。

#### 3. 处理 JSON 数据
- **XMLHttpRequest**：手动处理 JSON 数据。
- **fetch**：需要调用 `.json()` 方法来解析 JSON。
- **axios**：自动处理和解析 JSON。

#### 4. Cookie 支持
- **XMLHttpRequest**：发送请求时需要手动配置 `withCredentials` 属性。
- **fetch**：通过 `credentials` 配置来管理 cookies。
- **axios**：默认发送和接收 cookies。

### 示例总结

#### 完整 Axios 使用示例

- **GET 请求：**

```javascript
axios.get('https://api.example.com/data', {
  params: {
    ID: 12345
  }
})
.then(response => {
  console.log(response.data);
})
.catch(error => {
  console.error('Axios error:', error);
});
```

- **POST 请求：**

```javascript
axios.post('https://api.example.com/data', {
  firstName: 'John',
  lastName: 'Doe'
})
.then(response => {
  console.log(response.data);
})
.catch(error => {
  console.error('Axios error:', error);
});
```

- **Request 和 Response 拦截器：**

```javascript
axios.interceptors.request.use(function (config) {
  // 在请求发出之前做些什么
  console.log('Request config:', config);
  return config;
}, function (error) {
  // 请求错误时做些什么
  return Promise.reject(error);
});

axios.interceptors.response.use(function (response) {
  // 对响应数据做些什么
  console.log('Response data:', response.data);
  return response;
}, function (error) {
  // 响应错误时做些什么
  return Promise.reject(error);
});
```

综上所述，选择哪种方式主要取决于具体的项目需求和代码维护的复杂度。当选择 `fetch` 和 `axios` 这种现代工具时，可以大大简化请求处理代码并提高可维护性。`XMLHttpRequest` 和 `Ajax` 仍然是稳健的选择，但是对于新项目不太建议使用。

## 浏览器缓存策略

浏览器缓存是一种用于提高网页加载速度、减少服务器负担和带宽消耗的机制。浏览器通过在本地存储资源副本，避免重复下载相同的资源。以下是常见的浏览器缓存方式和机制：

### 1. **强制缓存（强缓存）**

强制缓存通过使用 HTTP 头中的 `Expires` 或 `Cache-Control` 来实现。

- **Expires**:
  - `Expires` 是一个 HTTP 响应头，指定资源过期的具体时间（使用 UTC 时间）。
  - 缺点是基于服务器时间，并且不支持相对时间，容易受到客户端时间的影响。

- **Cache-Control**:
  - `Cache-Control` 是现代浏览器建议使用的缓存控制头。
  - 支持多个指令，如 `max-age`（指定资源在客户端缓存的最长时间，以秒为单位）、`no-cache`（每次使用前必须重新验证）、`no-store`（不缓存资源）
  - `max-age` 是一种相对时间，与 `Expires` 的区别是它不依赖于服务器的时间。

### 2. **协商缓存（对比缓存）**

当强制缓存失效或无法使用时，浏览器会通过协商缓存来确认资源是否发生变化，决定是否重新下载资源。

- **Last-Modified / If-Modified-Since**:
  - **Last-Modified**: 服务器在响应中告知资源的最后修改时间。
  - **If-Modified-Since**: 浏览器在后续请求中，携带上次 `Last-Modified` 给服务器，服务器判断资源是否在此时间后被修改。
  - 若资源未修改，服务器返回 304 状态码，并使用本地缓存资源；若已修改，返回最新的资源及 200 状态码。

- **ETag / If-None-Match**:
  - **ETag**: 服务器为资源生成的唯一标识符（校验码），反映资源内容的唯一性。
  - **If-None-Match**: 浏览器请求中携带上次的 `ETag`，服务器根据匹配结果判断资源是否变化。
  - 匹配则返回 304 状态码和缓存，未匹配则返回新资源和 200 状态码。

### 3. **存储缓存**

浏览器还可以通过其他存储机制实现缓存：

- **Service Workers**:
  - 允许拦截网络请求并使用缓存 API 手动缓存资源。
  - 适用于离线优先的应用场景，开发者可以控制缓存策略。
  
- **IndexedDB / Local Storage / Session Storage**:
  - 这些是提供给开发者的客户端存储机制，可以存储 JSON 数据、字符串和其他信息。
  - 虽然不是专用的缓存机制，但可以用来手动实现缓存策略或数据存储。

### 4. **应用缓存（App Cache）**

- 已被 Service Workers 逐渐取代，不建议在现代开发中使用。
- 通过缓存清单 (`manifest`) 文件来声明需要缓存的资源。

### 缓存策略总结

- **优先级**：强缓存优先于协商缓存，如果强缓存有效，浏览器直接使用缓存，协商缓存不被触发。
- **缓存的使用场景**：
  - **静态资源（如图像、CSS）**通常用强缓存，以免频繁请求。
  - **需要保持更新的资源（如 API 数据）**可用协商缓存，确保资源的更新。
  

选择合适的缓存策略，对提高网页性能和用户体验至关重要。调整缓存配置需关注资源的更新频率和用户对最新内容的需求。

## 强缓存和协商缓存

在 Web 开发中，缓存策略对提高性能和用户体验非常重要。缓存策略一般分为强缓存和协商缓存两种，各自有不同的应用场景和优劣。

### 强缓存（强制缓存）
强缓存意味着浏览器会在本地缓存中查找资源，并根据缓存时间来决定是否使用缓存，期间不与服务器沟通。强缓存主要通过 `Expires` 和 `Cache-Control` 头部来设置。

#### `Expires`
设置资源过期时间的绝对时间点，过了这个时间点，浏览器认为缓存过期，需要重新请求。如果本地时间与服务器时间不同步，可能会导致缓存策略失效。

```http
Expires: Wed, 21 Oct 2023 07:28:00 GMT
```

#### `Cache-Control`
更常用，设置相对时间且提供更精细的控制。常用选项有：
- `max-age=<seconds>`：资源在本地缓存多久（以秒为单位）。
- `public`：可以被所有的用户（包括终端用户和中间代理服务器）缓存。
- `private`：只能被终端用户的浏览器缓存，不能被中间代理服务器缓存。
- `no-cache`：资源不可直接使用，需要进行协商缓存。
- `no-store`：资源不应被缓存。

```http
Cache-Control: max-age=3600
```

#### 应用场景
- **静态资源**：如图片、CSS、JavaScript 文件等。经常使用强缓存策略，以减少对服务器的请求。
- **变化不频繁的资源**：例如，公司 logo、长期不变的静态文件。

### 协商缓存
协商缓存是指每次请求资源时，浏览器都会向服务器确认资源是否有更新。如果资源没有更新，服务器会返回 304 Not Modified 状态，浏览器会继续使用本地缓存的资源。这种缓存包括 `Last-Modified/If-Modified-Since` 和 `ETag/If-None-Match`。

#### `Last-Modified/If-Modified-Since`
- `Last-Modified`：服务器在响应头中返回资源的最后修改时间。
- `If-Modified-Since`：浏览器下一次请求时，会带上上次的 `Last-Modified` 时间，服务器对比资源的最后修改时间决定是否返回 304 状态码。

```http
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
```

#### `ETag/If-None-Match`
- `ETag`：返回资源的唯一标识符（一般是内容的哈希值）。
- `If-None-Match`：浏览器下一次请求时，会带上上次的 `ETag` 值，服务器对比资源新的 ETag 值决定是否返回 304 状态码。

```http
ETag: "6849e7b2dc3849e7b2d"
If-None-Match: "6849e7b2dc3849e7b2d"
```

#### 应用场景
- **频繁变化的资源**：如 API 响应、新闻信息等。使用协商缓存能在资源更新时及时反映变化。
- **大型文件**：如大图片、大文件。即使检查是否更新，也能节约带宽。
- **用户生成内容**：如博客文章、社交媒体平台内容。

### 综合应用

一个健全的缓存策略通常在强缓存和协商缓存之间取得平衡。以下提供一个 HTML 页面的示例，展示如何设置缓存策略：

```http
HTTP/1.1 200 OK
Date: Wed, 21 Oct 2023 07:28:00 GMT
Cache-Control: max-age=3600, public
Expires: Wed, 21 Oct 2023 08:28:00 GMT
Last-Modified: Tue, 20 Oct 2023 07:28:00 GMT
ETag: "6849e7b2dc3849e7b2d"
Content-Length: 1234
Content-Type: text/html
```

- 对于很少更新的静态文件（如公司 logo 或常用字体），你可以设置一个较长的 `max-age` 和 `Expires` 时间。
- 对于可能频繁更新但需要频繁访问的资源（如网站首页），你可以使用较短的 `max-age` 或 `no-cache`，并结合 `ETag` 或 `Last-Modified` 检查更新。

通过灵活应用强缓存和协商缓存，你可以显著提高网站的加载速度和响应性能，并减少带宽消耗，提升用户体验。

## etag和last-modify区别

`ETag`（实体标签）和 `Last-Modified` 是HTTP协议中的两种用于缓存控制和资源验证的头字段，它们帮助客户端和服务器之间有效地管理资源更新。两者的功能有些相似，但各自有不同的特点和使用场景。

### `ETag`（Entity Tag）
- **定义**：`ETag` 是由服务器为每个资源生成的一个唯一标识符，可以是文件内容的哈希值或其他形式的唯一指示符。
- **精确度**：非常精确，因为它可以基于文件内容的每一个字节生成。
- **用法**：主要用于资源的版本控制。如果资源内容发生变化，`ETag` 会相应变化。当客户端请求某个资源时，可以通过 `If-None-Match` 头字段将已知的 `ETag` 发送给服务器，服务器则通过检查 `ETag` 是否发生变化来决定返回完整的资源或仅返回304 Not Modified状态。
- **优点**：
  - 精确度高，不受时钟同步问题影响。
  - 可以检测到任何细微的内容变化。
- **缺点**：
  - 实现复杂，生成和比较 `ETag` 可能增加服务器负担。

### `Last-Modified`
- **定义**：`Last-Modified` 是一个用时间戳表示的头字段，记录资源最后修改的时间。
- **精确度**：精度相对较低，通常是在秒级，可能受到不同服务器时钟同步的影响。
- **用法**：当客户端请求资源时，可以通过 `If-Modified-Since` 头字段传递上次获取资源时的 `Last-Modified` 时间戳，服务器会比较该时间戳与资源的当前最后修改时间，以决定返回完整的资源或只是304状态码。
- **优点**：
  - 实现简单，通过文件系统提供的修改时间即可实现。
  - 适用于大部分静态内容。
- **缺点**：
  - 精度问题，容易受到客户端和服务器时钟不同步的影响。
  - 对于短时间内多次修改的资源不够精确。只能精确到秒，可能无法检测到一些细微变化。

### 总结
- **ETag 更适合**：需要对内容变化进行精确控制的场景，尤其是当资源的修改频率高或者多台服务器之间可能有时间同步问题时。
- **Last-Modified 更适合**：简单的静态资源场景，例如网页中的图像、样式表文件，使用起来非常简单并且性能影响较小。

通常在实际应用中，`ETag` 和 `Last-Modified` 可以结合使用，以提供更灵活且高效的缓存控制和资源验证机制。

## Cache-Contral:max-age和Expires的区别

### http/1.0用哪个，http/1.1用哪个，为什么要替换这个字段

### Cache-Control: max-age 与 Expires 的区别

`Cache-Control: max-age` 和 `Expires` 都是 HTTP 响应头，用于指示浏览器缓存资源的时间。两者主要区别如下:

| 特性      | Cache-Control: max-age | Expires             |
| --------- | ---------------------- | ------------------- |
| 单位      | 秒                     | HTTP 日期格式 (GMT) |
| 参考时间  | 收到响应的时间         | 服务器时间          |
| HTTP 版本 | HTTP/1.1 引入          | HTTP/1.0            |

**具体区别**:

* **时间单位:**  `max-age` 使用秒，更加直观和方便计算； `Expires` 使用 HTTP 日期格式，可读性较差，容易出错。
* **参考时间**:  `max-age`  以浏览器收到响应的时间为起点计算过期时间，不受服务器和浏览器时间差异的影响; `Expires` 以服务器时间为准，如果服务器和浏览器时间不同步，会导致缓存失效。
* **HTTP 版本**: `max-age` 是 HTTP/1.1 引入的新特性，兼容性更好;  `Expires` 是 HTTP/1.0 的遗留字段，在 HTTP/1.1 中仍然可用，但优先级低于  `max-age`.


### HTTP/1.0 和 HTTP/1.1 使用哪个

* **HTTP/1.0:** 只能使用 `Expires` 控制缓存。
* **HTTP/1.1:**  推荐使用 `Cache-Control: max-age`, 因为它更精确，更易于使用。

###  为什么用 `max-age` 替换  `Expires`

* **更精确:** `max-age`  使用相对时间，避免了服务器和浏览器时间不同步带来的问题，缓存控制更加精确。
* **更易于使用:** 秒为单位更容易理解和计算，同时也简化了服务器端的设置。
* **更强大的功能:**  `Cache-Control` 提供更丰富的缓存指令，例如：
    * `public`:  允许任何缓存服务器缓存该资源。
    * `private`:  只允许用户浏览器缓存，代理服务器不能缓存。
    * `no-cache`:  强制每次请求都向服务器验证缓存有效性。
    * `no-store`:  禁止浏览器和代理服务器缓存该资源。

**总结:**

`Cache-Control: max-age`  是比 `Expires` 更强大、更精准、更易于使用的缓存控制机制，推荐在 HTTP/1.1 中使用 `max-age`  来控制资源的缓存时间。

## 离线缓存、启发式缓存

离线缓存和启发式缓存是两种不同的缓存策略，用于提高Web应用的性能和用户体验。让我们详细了解这两种缓存方式：

### 离线缓存 (Offline Caching)

离线缓存允许Web应用在没有网络连接的情况下继续运行。

#### 主要特点：

- 允许应用在离线状态下访问
- 提高应用加载速度
- 减少服务器负载
- 改善用户体验，特别是在网络连接不稳定的情况下

#### 实现方式：

a) Application Cache (已废弃)
b) Service Workers (现代推荐方法)

使用Service Workers的基本步骤：
1. 注册Service Worker
2. 安装事件中缓存静态资源
3. 拦截网络请求，优先使用缓存响应

示例代码（Service Worker）:
```javascript
self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open('my-cache').then(function(cache) {
      return cache.addAll([
        '/',
        '/styles/main.css',
        '/script/main.js'
      ]);
    })
  );
});

self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      return response || fetch(event.request);
    })
  );
});
```

### 启发式缓存 (Heuristic Caching)

启发式缓存是浏览器在**没有明确缓存指令的情况下**，根据某些规则自动决定是否缓存内容以及缓存多长时间。

#### 主要特点：

- 由浏览器自动实现
- 在没有明确的Cache-Control或Expires头时触发
- 缓存时间通常基于Last-Modified头

#### 工作原理：

1. 如果响应没有Cache-Control或Expires头
2. 但有Last-Modified头
3. 浏览器计算一个启发式的过期时间：
   通常是(当前时间 - Last-Modified时间) * 10%

注意事项：

- 不同浏览器可能有不同的启发式算法
- 不如明确的缓存控制可靠
- 可能导致内容过期或缓存时间过短

最佳实践：
为了避免启发式缓存的不确定性，建议始终使用明确的缓存控制头，如：
```
Cache-Control: max-age=3600
```

### 总结：

- 离线缓存专注于使应用在离线状态下可用
- 启发式缓存是浏览器的一种自动行为，用于在缺少明确指令时决定缓存策略
- 在实际应用中，通常会结合使用明确的缓存控制、离线缓存等多种策略来优化性能和用户体验

## cdn为什么能加速访问

内容分发网络（CDN, Content Delivery Network）是一组分布在多个地理位置的服务器，旨在加速网站内容的交付，提高资源的可用性和可靠性。以下是 CDN 为什么能加速访问的几个关键原因：

### 1. 地理位置优化
CDN 会将内容分发到全球多个服务器节点（PoP，Points of Presence）。当用户请求资源时，CDN 会从离用户最近的服务器提供资源。这减少了网络延迟，因为数据传输距离缩短了。

### 2. 负载均衡
CDN 可以将请求分散到不同的服务器节点上，从而平衡负载，防止单一服务器过载。这可以提高网站的稳定性和响应速度，并确保在高流量情况下继续正常运行。

### 3. 缓存静态资源
CDN 会缓存静态资源（如图片、视频、CSS、JavaScript 文件等）。当用户请求这些资源时，CDN 可以直接从缓存中提供，而不需要每次都向源服务器请求。这大大减少了源服务器的压力，并加快了内容交付速度。

### 4. TCP 连接优化
CDN 提供了优化的 TCP 连接设置，如持久连接（Keep-Alive）、HTTP/2 支持、多路复用等。这些优化措施可以减少连接建立时间和数据传输延迟。

### 5. 压缩和优化
许多 CDN 提供自动的压缩和优化功能，例如 gzip 或 Brotli 压缩、图像优化等。这些功能可以减少传输的数据量，进一步加快内容加载速度。

### 6. 安全性和 DDoS 防护
CDN 通常可以提供安全增强和 DDoS 防护，如 SSL/TLS 加密、Web 应用防火墙（WAF）等。这些安全措施不仅保护了原始服务器，还避免了攻击对网站性能的影响。

### 7. 分布式架构
CDN 的分布式架构能够自动路由和重定向流量，确保即使某些节点出现故障，系统依然可以通过其他节点提供服务。这提高了网站的可用性和可靠性。

### 可视化示例

假设你有一个全球用户访问的站点，没有使用 CDN 时的资源访问路径如下：
1. 用户在美国请求一个资源，如图片。
2. 请求被发送到在中国的源服务器。
3. 数据从中国传回美国用户，这通过多个网络跳转，可能导致显著的延迟。

使用 CDN 后的资源访问路径可能如下：
1. 用户在美国请求同一个资源。
2. 请求被发送到在美国本地的 CDN 节点。
3. CDN 节点从缓存中提供资源，立即响应用户请求。

### 实际应用和配置

**典型配置**
假设你有一个站点 `https://example.com`。使用 CDN（例如 Cloudflare、Akamai、AWS CloudFront 等）时，你通常需要：

1. **CDN 设置**：在 CDN 服务商的控制台中添加你的域名 `example.com`，配置缓存策略、压缩、SSL 证书等。
2. **DNS 配置**：将域名的 DNS 记录指向 CDN 提供的地址。例如，将 `example.com` 的 A 记录或 CNAME 记录指向 CDN 的服务地址。
3. **源服务器配置**：确保源服务器配置正确，并能够与 CDN 正常通信，包括更新防火墙规则、SSL 证书等。

通过以上步骤，你的内容将通过 CDN 分发，并从最接近用户的节点提供。这将显著提高资源加载速度，提升用户体验。

### 小结
CDN 通过地理位置优化、负载均衡、缓存静态资源、TCP 连接优化、压缩和优化、安全性和 DDoS 防护以及分布式架构等多种方式，能够显著提升访问速度、可靠性和安全性。利用 CDN，可以确保用户无论在全球何处访问你的站点，都能获得快速而稳定的体验。

## HTTPS如何防范中间人攻击

HTTPS (Hypertext Transfer Protocol Secure)  通过结合加密和身份验证机制，有效地防范中间人攻击 (Man-in-the-middle attack, MITM)。以下是 HTTPS 如何实现这一目标的：

**1. 加密通信:**

* **对称加密:** HTTPS 使用加密算法（例如 AES）对客户端和服务器之间传输的数据进行加密,非对称加密用于交换对称加密的秘钥。对称加密因为速度较快，被用于大量数据的加密。这意味着只有拥有正确密钥的人才能解密和读取数据。
* **会话密钥:** 为了确保每次通信的安全性，HTTPS 会为每个会话生成一个唯一的密钥。这个密钥在连接建立时通过一种称为“密钥交换”的机制安全地进行协商。

**2. 数字证书和身份验证:**

* **数字证书:** 网站使用由受信任的证书颁发机构 (CA) 签发的数字证书来证明其身份。证书包含网站的公钥以及其他身份信息。
* **公钥加密:** 客户端使用证书中的公钥来加密一个“预主密钥”，然后将其发送到服务器。只有拥有对应私钥的服务器才能解密这个预主密钥。
* **身份验证:** 通过验证证书的真实性和有效性，客户端可以确信自己正在与预期的服务器通信，而不是一个伪装的中间人。

**3. 数据完整性:**

* **消息摘要:** HTTPS 使用一种称为“消息摘要”的加密哈希函数来确保数据的完整性。服务器会为每个数据包生成一个唯一的哈希值，并将其发送给客户端。
* **完整性校验:** 客户端在接收到数据包后，会使用相同的哈希函数计算其哈希值。如果计算出的哈希值与服务器发送的哈希值不匹配，则表示数据可能在传输过程中被篡改。

**HTTPS 如何防范 MITM 攻击：**

* **无法解密数据:** 中间人可以拦截客户端和服务器之间的通信，但由于数据是加密的，他们无法读取或修改数据内容。
* **无法伪造身份:** 中间人无法伪造有效的数字证书，因为他们没有相应的私钥。客户端会识别出伪造的证书，并拒绝连接。
* **无法篡改数据:**  如果中间人试图篡改数据，客户端会检测到哈希值不匹配，从而发现数据被篡改。

总而言之，HTTPS 通过加密、身份验证和数据完整性保护，为客户端和服务器之间的通信建立了一个安全的通道，有效地防范了中间人攻击。

## 什么是DDOS攻击，如何防范

DDoS攻击（Distributed Denial of Service，分布式拒绝服务攻击）是一种恶意攻击行为，其中攻击者利用多个计算机系统发起大量的请求，试图使目标服务器、服务或网络资源瘫痪。目标资源因为无法处理大量的请求而变得缓慢或不可用。DDoS攻击的常见形式包括：

1. **流量攻击**：产生大量的虚假流量淹没目标网络带宽。
2. **协议攻击**：利用协议漏洞或特性来耗尽服务器资源，如SYN Flood攻击。
3. **应用层攻击**：针对特定应用程序层的资源耗尽攻击，如HTTP Flood攻击。

防范DDoS攻击的方法包括：

1. **网络监控和检测**：
   - 部署监控工具以实时检测异常流量。例如，设置基于流量趋势分析的警报。
   - 使用入侵检测系统（IDS）和入侵防御系统（IPS）来识别和阻止可疑活动。
2. **扩展和冗余**：
   - 增加网络和服务器的带宽和容量来吸收攻击带来的高流量。
   - 使用内容分发网络（CDN）来分散流量，提供更好地抵御攻击的能力。
3. **清洗服务**：
   - 使用DDoS清洗服务来过滤恶意流量，同时允许合法流量通过。
   - 这些服务通常由专业的DDoS防护公司提供。
4. **配置防火墙和负载均衡器**：
   - 配置防火墙以阻止已知的恶意IP地址和端口。
   - 部署负载均衡器来分发流量，防止单一服务器被淹没。
5. **应用层防护**：
   - 使用Web应用防火墙（WAF）来检测和阻止应用层攻击。
   - 实现速率限制和验证码，以减少请求频率。

## 前端正向代理和反向代理

在Web开发和网络通信中，代理服务器是一个中间服务器，用于处理请求和响应。了解正向代理和反向代理的区别和应用场景，对改善前端性能、提高安全性和简化资源管理有着重要的作用。

### 一、正向代理（Forward Proxy）

#### 概述：
正向代理是指客户端向代理服务器发送请求，由代理服务器代替客户端向目标服务器请求资源，然后将资源返回给客户端。它主要用于客户端无法直接访问目标服务器的情况。

#### 典型应用场景：
1. **访问控制**：公司、学校等组织使用正向代理来控制和过滤员工或学生的上网行为。
2. **隐匿身份**：通过正向代理，客户端的IP地址会被代理服务器的IP地址代替，从而隐藏客户端的真实身份。
3. **内容缓存**：在网络带宽有限的情况下，正向代理可以缓存常访问的资源，提高访问速度和减少带宽消耗。
4. **突破限制**：访问被限制或屏蔽的资源，如通过正向代理访问被地理位置限制的内容。

#### 示意图：
```
[Client] -> [Forward Proxy] -> [Target Server]
```

#### 示例：

```javascript
// 使用`axios`进行跨域请求，通过配置代理服务器
// 在前端项目的配置文件（如vue.config.js）中添加代理
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
```

### 二、反向代理（Reverse Proxy）

#### 概述：
反向代理是指代理服务器接受来自客户端的请求，然后将请求转发给一个或多个后端服务器，并将后端服务器的响应返回给客户端。客户端并不知道实际的后端服务器，而只与反向代理服务器交互。

#### 典型应用场景：
1. **负载均衡**：将客户端请求分发给多个后端服务器，均衡负载，防止单个服务器过载。
2. **安全性**：隐藏后端服务器，保护内部网络的结构和信息，防止攻击。
3. **SSL/TLS 终止**：在反向代理服务器处理SSL/TLS加密和解密，减轻后端服务器的负担。
4. **静态内容缓存**：缓存常用的静态资源，减少后端服务器的请求压力，提高响应速度。

#### 示意图：
```
[Client] -> [Reverse Proxy] -> [Backend Servers]
                          -> [Server 1]
                          -> [Server 2]
                          -> [Server 3]
```

#### 示例：

使用Nginx配置反向代理

```nginx
server {
    listen 80;
    
    server_name example.com;
    
    location / {
        proxy_pass http://backend_server_pool;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

upstream backend_server_pool {
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;
}
```

在这个Nginx示例中，所有请求到`example.com`的流量将转发到定义为`backend_server_pool`的后端服务器池中的服务器，实现负载均衡和反向代理功能。

### 正向代理与反向代理的区别：

| 特性                   | 正向代理                               | 反向代理                                  |
| ---------------------- | -------------------------------------- | ----------------------------------------- |
| 客户端与代理服务器关系 | 客户端主动配置和使用                   | 客户端不知道代理的存在，透明访问          |
| 应用场景               | 隐藏客户端、访问受限资源、提高访问速度 | 负载均衡、增强安全性、SSL终结、隐藏服务器 |
| 直接受益方             | 客户端                                 | 服务器和网络架构                          |

### 总结：

- **正向代理**：主要服务于客户端，用于访问受限资源、隐匿身份、内容缓存和突破访问限制。
- **反向代理**：主要服务于服务器端，用于负载均衡、隐藏服务器、增强安全性、SSL终结和缓存静态内容。

理解正向代理和反向代理的各自特点和用途，能够更好地设计和优化网络架构，提升应用程序的性能和安全性。
