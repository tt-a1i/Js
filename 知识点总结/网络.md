## 常见的HTTP请求方法

幂等性（Idempotence）是一个数学和计算机科学中的概念，它表示一个操作可以重复执行多次而不会改变结果。换句话说，无论执行一次还是执行多次，幂等操作的最终效果是相同的。

1. ### 1. GET
   
   用于从服务器获取资源。GET 请求的方法是幂等的和安全的，即多次调用不会引起副作用。
   
   - **用途**：检索数据，例如网页内容、API 数据等。
   - **特点**：请求的参数通常追加到 URL 路径，数据是可缓存的。
   
   ### 2. POST
   
   用于向服务器提交数据以进行处理。POST 请求可能会产生副作用，例如更新数据库或创建新资源。
   
   - **用途**：表单提交、文件上传、创建新数据等。
   - **特点**：请求的数据包含在请求体（body）中，通常不可缓存。
   
   ### 3. PUT
   
   用于更新指定的资源，如果资源不存在，通常会创建资源。PUT 请求是幂等的，即多次调用的结果是相同的。
   
   - **用途**：更新整条记录或文件。
   - **特点**：请求的数据包含在请求体中。
   
   ### 4. DELETE
   
   用于删除指定的资源。DELETE 请求是幂等的。
   
   - **用途**：删除数据或资源。
   - **特点**：通常不包含请求体。
   
   ### 5. HEAD
   
   与 GET 方法类似，但只请求资源的头部信息，不包含实际数据内容。
   
   - **用途**：获取资源的元数据，例如检查资源是否存在，获取资源的大小等。
   - **特点**：不会返回响应体，仅返回响应头信息。
   
   ### 6. PATCH
   
   用于对资源进行部分更新。与 PUT 不同的是，PATCH 只更新资源的部分内容而不是整个资源。
   
   - **用途**：部分更新资源中的数据。
   - **特点**：请求的数据包含在请求体中，描述需要修改的内容。
   
   ### 7. OPTIONS
   
   用于描述目标资源的通信选项。服务器返回支持的 HTTP 方法和其他通信选项。
   
   - **用途**：查看服务器支持的 HTTP 方法，通常用于跨域请求中的预检请求。
   - **特点**：不会返回资源的实际内容。
   
   ### 8. TRACE
   
   用于对目标资源进行回环测试，主要用于诊断。服务器会原样返回客户端的请求内容。
   
   - **用途**：诊断和调试。
   - **特点**：从安全角度考虑，少用。
   
   ### 9. CONNECT
   
   用于将请求连接转换为透明的 TCP/IP 隧道，通常用于 SSL（HTTPS）连接，通过代理服务器建立隧道。
   
   - **用途**：主要用于 HTTPS，通过代理进行安全通信。
   - **特点**：用于代理通信。
   
   ### 总结
   
   | 方法    | 用途             | 幂等性 | 安全性 |
   | ------- | ---------------- | ------ | ------ |
   | GET     | 获取资源         | ✔️      | ✔️      |
   | POST    | 提交数据         | ✖️      | ✖️      |
   | PUT     | 创建或更新资源   | ✔️      | ✖️      |
   | DELETE  | 删除资源         | ✔️      | ✖️      |
   | HEAD    | 获取资源头部信息 | ✔️      | ✔️      |
   | PATCH   | 局部更新资源     | ✖️      | ✖️      |
   | OPTIONS | 获取通信选项     | ✔️      | ✔️      |
   | TRACE   | 诊断、回环测试   | ✖️      | ✖️      |
   | CONNECT | 建立隧道         | ✖️      | ✖️      |

## Https

为了解决Http不安全的特性

是HTTP协议的安全版本，旨在通过在传输层加密通信数据来保护用户和服务器之间的数据传输

让`Http运行在安全点SSL/TLS`协议上,`HTTPS = HTTP + SSL/TLS`,通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

### 主要过程

1. **客户端请求服务器**：
   - 用户在浏览器中输入URL，浏览器向服务器发送HTTPS请求。
2. **服务器发送证书**：
   - 服务器发送其SSL/TLS证书，证书中包括服务器的公钥和由可信的证书颁发机构（CA）签署的服务器身份信息。
3. **客户端验证证书**：
   - 浏览器验证服务器证书的有效性。它检查证书的签名、颁发机构的可信度、和证书的有效期等。
   - 如果验证通过，浏览器会生成一个随机的对称密钥（会话密钥）。
4. **密钥交换**：
   - 浏览器使用服务器的公钥加密这个对称密钥，并将其发送给服务器。
   - 服务器使用其私钥解密，获取对称密钥。
5. **建立安全连接**：
   - 现在客户端和服务器都拥有了相同的对称密钥。之后的通信将使用这个对称密钥进行加密和解密，以确保数据的机密性和完整性。
6. **数据传输**：
   - 使用对称密钥加密的数据在客户端和服务器之间传输，确保即使数据被拦截，也无法被读取。

### 应用场景

1. **银行与金融机构**：
   - 确保在线银行业务、股票交易等金融服务的安全通信。
2. **电子商务**：
   - 保护用户在进行网上购物时输入的敏感信息，如信用卡号、个人地址等。
3. **社交网络**：
   - 保护用户的个人信息和隐私，确保聊天、登录等功能的安全。
4. **在线服务与API**：
   - 保护各种在线服务和API接口的通信，防止数据泄露或被篡改。
5. **电子邮件和通信**：
   - 确保电子邮件服务的安全，防止邮件内容被第三方窥探。

#### 对称加密（Symmetric Encryption）

- **使用场景**：
  - 在通信的主要数据传输过程使用。
  - 通过共享的对称密钥对数据进行快速、高效的加密和解密。
- **优点**：
  - 加密和解密速度快，适合大数据量的传输。
- **缺点**：
  - 密钥分发难题：如何安全地在双方之间交换密钥是一个挑战（这正是非对称加密解决的）。

#### 非对称加密（Asymmetric Encryption）

- **使用场景**：
  - 在初始密钥交换过程中使用。
  - 客户端使用服务器的公钥加密会话密钥（对称密钥），服务器使用其私钥解密。
- **优点**：
  - 公钥公开，私钥保密，密钥分发相对安全。
  - 适合用于密钥交换和数字签名，确保身份验证和数据完整性。
- **缺点**：
  - 加密和解密速度较慢，不适合大数据量的传输。

 

- 首先客户端通过URL访问服务器建立SSL连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

## 区别

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

HTTP 报文是在应用程序之间发送的数据块，用于 HTTP 协议交互。它分为请求报文和响应报文两种类型。

## 说一下http报文都有哪些东西

### 请求报文（Request Message）

1. **请求行**：

   - 描述客户端想要如何操作服务端的资源。
   - 由三部分构成：
     - 请求`方法`：表示对资源期望进行何种操作，常用的如 GET、POST。
     - 请求`目标`：通常是一个 URL，表明要操作的资源。
     - `版本号`：表示报文使用的 HTTP 协议版本。

   示例：

   ```
   GET / HTTP/1.1
   ```

   

2. **请求头**：

   - 包含若干个属性，格式为“属性名: 属性值”，服务端据此获取客户端的信息。
   - 请求头可大致分为四种类型：
     - 通用首部字段
     - 请求首部字段
     - 响应首部字段
     - 实体首部字段

3. **请求体**：

   - 包含要传输的内容，可以是文本、图片、音频、视频等。

### 响应报文（Response Message）

1. **状态行**：

   - 包含`协议版本`、`状态码`和`状态描述`。
   - 三位数字状态码表示处理的结果，例如 200 表示成功，404 表示资源未找到。
   - 状态描述是状态码的补充，帮助人们理解原因。

   示例：

   ```
   HTTP/1.1 200 OK
   ```

   

2. **响应头部**：

   - 由键值对组成，每行一对，键和值用英文冒号 : 分隔。
   - 响应头允许服务器传递不能放在状态行的附加信息，描述服务器的信息和 Request-URI 进一步的信息。

3. **响应包体**：

   - 服务器返回给浏览器的响应信息，响应数据的格式根据服务器来决定，常见的有 text/html、application/json 等。

[总之，HTTP 报文的基本概念和格式包括请求行、请求头、请求体、状态行、响应头和响应包体。](https://zhuanlan.zhihu.com/p/450128753)[1](https://zhuanlan.zhihu.com/p/450128753)[2](https://zhuanlan.zhihu.com/p/389369982)[3](https://blog.poetries.top/http-protocol/notes/base/06-HTTP报文是什么样子的.html)

## UDP

**面向数据报的通信协议**

`UDP`报头包括4个字段,标题短，开销小

- 利用IP提供面向无连接的通信服务
- 传输中出现丢包,不重发
- 包的到达顺序出现乱序时,没有纠正功能
- 收到数据就发出,无法进行流量控制避免网络拥塞

## TCP

- **全双工通信（Full Duplex Communication）**：
  - **全双工**：指可以同时进行双向通信，即 A 可以在发送给 B 的同时，B 也可以在发送给 A。这和“半双工”不同，半双工通信只能在同一时间内进行单向传输（例如，对讲机，一个人说话时另一个人必须等待）。
- **序列号和确认机制**：
  - **序列号（Sequence Number）**：每个数据段都会被赋予一个序列号，用于确保数据按照正确的顺序到达。
  - **确认机制（Acknowledgment Mechanism）**：接收方接收到数据后会发送确认（ACK），发回到发送方以确认接收到特定序列号的数据段。
- **缓冲区**：
  - 发送方和接收方都需要准备缓冲区来存储即将发送或接收到的数据。通过调整缓冲区大小，可以优化数据传输的效率和吞吐量。
- **流控制**：
  - 为了避免发送方发送的数据超出接收方的处理能力，TCP 引入了流控制机制，即使用窗口大小（Window Size）来控制数据的流入速度。
- **拥塞控制**：
  - TCP 还有拥塞控制机制，以防止网络拥塞影响数据传输质量和效率。这包括慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）等技术。

## 区别

|          |               TCP                |              UDP               |
| -------- | :------------------------------: | :----------------------------: |
| 可靠性   |               可靠               |             不可靠             |
| 连接性   |             面向连接             |             无连接             |
| 报文     |            面向字节流            |            面向报文            |
| 效率     |            传输效率低            |           传输效率高           |
| 双共性   |              全双工              | 一对一、一对多、多对一、多对多 |
| 流量控制 |             滑动窗口             |               无               |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复 |               无               |
| 传输效率 |                慢                |               快               |

- 都位于传输层
- TCP适用于对效率要求低,对准确性要求高,有连接的场景
- UDP适用于对效率要求高,准确性要求低的场景

## 粘包

粘包是网络通信中常见的一个问题，尤其在使用 TCP 协议时。让我们深入了解这个概念：

粘包问题通常由以下原因导致：

1. **发送端**：数据在发送端被快速地连续发送，操作系统为了优化网络资源利用而合并了多个小的数据包。
2. **接收端**：接收端在从套接字读取数据时，可能一次性读取了多个数据包的内容，导致数据包间无明显边界。



1. 粘包定义：
   - 粘包是指多个数据包在传输过程中被合并成一个包，或者一个数据包被分割成多个包的现象。
2. 产生原因： a) TCP 面向字节流：TCP 是面向字节流的协议，不保存消息边界。 b) 发送端原因：
   - Nagle 算法：为了提高网络利用率，可能会将多个小包合并发送。
   - TCP 发送缓冲区：数据可能在缓冲区中被合并。 c) 接收端原因：
   - 接收缓冲区：数据可能在接收缓冲区中被合并。
   - 接收应用程序读取不及时，导致多个数据包在缓冲区中累积。
3. 粘包的影响：
   - 接收方无法正确区分数据包的边界，导致数据解析错误。
   - 可能造成数据丢失或错误解释。
4. 解决方案： a) 固定长度：每个消息都使用固定长度。 b) 分隔符：使用特殊字符作为消息的分隔符。 c) 消息长度+消息内容：在消息前加上长度字段。 d) 自定义协议：设计包含消息边界信息的应用层协议。
5. 具体实现方法：
   - 消息帧定界：如使用 JSON、XML 等格式，自带结构边界。
   - 长度前缀法：在每个消息前加上长度字段。
   - 特殊结束符：如 HTTP 使用空行表示消息头结束。

## OSI七层模型

`OSI`将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰

<img src="https://static.vue-js.com/eb1b2170-b61e-11eb-ab90-d9ae814b240d.png" alt="img" style="zoom: 67%;" />

#### **应用层:**

定义了应用进程之间的各种交互规则,通过不同的应用层协议为不同的网络应用提供服务

在应用层交互的单元称为报文



#### **表示层:**

作用是使通信的应用程序能够解释交换数据的含义，位于 第六层，向上为应用层提供服务，向下接收来自会话层的服务

服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异



#### 会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话

该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法



#### 传输层

传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题

传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层

其中，主要的传输层协议是`TCP`和`UDP`



#### 网络层

两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网

网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送

在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层

在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层



#### 数据链路层

数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 `IP`数据报组装成帧，在两个相邻节点间的链路上传送帧

每一帧的数据可以分成：报头`head`和数据`data`两部分:

- head 标明数据发送者、接受者、数据类型，如 MAC地址
- data 存储了计算机之间交互的数据

通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源



#### 物理层

作为`OSI` 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送

该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）

该层主要是和硬件有关，与软件关系不大

## 传输过程

- 应用层报文被传送到运输层
- 在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用
- 应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变
- 运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报
- 网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧
- 在物理层数据帧被封装成比特流，之后通过传输介质传送到对端
- 对端再一步步解开封装，获取到传送的数据

## TCP/IP协议

TCP/IP协议是一组广泛使用的网络通信协议，互联网和许多内部网络都是基于TCP/IP协议进行通信的。TCP/IP协议由传输控制协议（TCP，Transmission Control Protocol）和互联网协议（IP，Internet Protocol）组成，因此得名为TCP/IP。

### 1. **TCP/IP 协议栈的分层模型**

TCP/IP 协议栈通常被划分为四层结构（与更传统的OSI七层模型相对），分别是：

1. **应用层（Application Layer）**：负责网络服务和最终用户应用程序之间的交互。
2. **传输层（Transport Layer）**：提供端到端的数据传输服务。
3. **网络层（Internet Layer）**：处理数据的路由与寻址。
4. **链路层（Link Layer）**：处理与物理网络介质的直接交互。

### 1.1 应用层

应用层负责网络应用程序间的交互，是直接为用户服务的最上层协议，包括HTTP、FTP、SMTP等。

- **HTTP/HTTPS**（超文本传输协议）：用于在Web浏览器和服务器之间传递超文本。
- **FTP**（文件传输协议）：用于文件的上传和下载。
- **SMTP**（简单邮件传输协议）：用于电子邮件的传输。
- **DNS**（域名系统）：用于将域名解析为IP地址。

### 1.2 传输层

传输层提供端到端通信服务，负责数据分段、重组、错误检测和流量控制。主要有两类协议：

- **TCP**（传输控制协议）：面向连接的协议，确保数据可靠、有序和无差错地传输。主要特性包括：
    - 连接建立和释放（三次握手和四次挥手）
    - 流量控制（利用接收窗口进行）
    - 拥塞控制（如慢开始、快重传等算法）
    - 数据重传和确认机制

- **UDP**（用户数据报协议）：无连接的协议，不保证数据包顺序和送达。主要用于需要快速传输和实时应用，如视频流、在线游戏和DNS查询。

### 1.3 网络层

网络层负责数据包在不同网络之间的传输和最佳路径选择，主要协议包括：

- **IP**（互联网协议）：IPv4 和 IPv6
    - IPv4：使用32位地址，进行路由选择和数据包转发。
    - IPv6：使用128位地址，解决IPv4地址不足的问题，增加了更多的功能与改进。
- **ICMP**（互联网控制消息协议）：用于发送错误消息和操作信息。
- **ARP**（地址解析协议）：将IP地址解析为硬件MAC地址。
- **RARP**（逆地址解析协议）：将MAC地址解析为IP地址。

### 1.4 链路层

链路层负责直接和物理介质交互，定义数据帧的传输。协议和标准包括：

- **以太网**：数据链路层标准，大多数局域网使用。
- **PPP**（点对点协议）：用于点对点数据链路，常用于电话拨号连接。
- **MAC**（介质访问控制）：管理硬件地址和帧的传输。

### 2. **TCP/IP 通信过程**

以下是TCP建立连接、传输数据和终止连接的详细过程：

### 2.1 三次握手建立连接

1. **SYN**：客户端向服务器发送SYN（同步）包，表明客户端要建立连接，并发送初始序号 `Seq=x`。
2. **SYN-ACK**：服务器收到SYN包后，向客户端发送SYN-ACK包，表示接受连接请求，并发送 `Seq=y` 和应答 `Ack=x+1`。
3. **ACK**：客户端收到SYN-ACK包后，向服务器发送ACK包，确认连接，`Seq=x+1` 和 `Ack=y+1`。

### 2.2 数据传输

- **可靠传输**：TCP使用序号和确认机制保证数据可靠传输。
- **流量控制**：TCP使用窗口机制防止发送端过多发送数据。
- **拥塞控制**：TCP通过算法（慢启动、拥塞避免、快速重传）防止网络拥塞。

### 2.3 四次挥手终止连接

1. **FIN**：客户端向服务器发送FIN（终止）包，表示数据发送完毕，断开连接请求。
2. **ACK**：服务器收到FIN包，返回ACK包，确认接收到FIN包。
3. **FIN**：服务器发送自己的FIN包，表示服务器也完成数据发送，准备断开连接。
4. **ACK**：客户端收到服务器的FIN包，发送ACK包，确认断开。

### 3. **TCP/IP 地址和路由**

### 3.1 IP 地址

- **IPv4**：用点分十进制表示，例如：192.168.0.1。
- **IPv6**：用冒号分隔的十六进制数表示，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334。

### 3.2 子网划分

子网掩码用来确定IP地址的网络部分和主机部分，有助于网络分段和管理流量。

### 3.3 路由

路由器根据路由表确定数据包的传输路径，路由表记录了网络的拓扑结构和最佳路径选择，包括静态路由和动态路由（使用协议如RIP、OSPF、BGP）。

### 4. **常见 TCP/IP 工具**

- **ping**：使用ICMP协议检查网络连通性。
- **traceroute**：显示数据包到目的地的路径。
- **netstat**：显示网络连接和端口状态。
- **ifconfig/ipconfig**：显示和配置网络接口。
- **tcpdump/wireshark**：抓包工具，分析网络流量。

### 5. **TCP/IP 协议的优缺点**

### 优点

- **通用性和互操作性强**：广泛应用于各种类型的网络。
- **可扩展性**：支持各种应用层协议、传输层协议和网络层协议。
- **鲁棒性和容错性**：通过多种机制保证数据传输的可靠性和有效性。
- **高效路由机制**：使用动态路由协议，找到最佳传输路径。

### 缺点

- **效率问题**：对实时性要求高的应用（如视频会议）可能不够理想。
- **安全性问题**：需要结合其他安全协议（如TLS/SSL）来确保数据传输安全。
- **配置复杂性**：需要理解大量协议和技术细节，配置和管理较复杂。

通过以上深入介绍，你应该对TCP/IP协议有了更全面和深刻的理解。TCP/IP是互联网的基石，其重要性不可替代。理解和掌握TCP/IP协议是网络通信领域的基本功，对于网络工程师、系统管理员和开发者都非常重要。

## DNS

#### 域名协议系统

进行域名和与之相对应的 IP 地址进行转换的服务器

`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

- IP 地址：一长串能够唯一地标记网络上的计算机的数字
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

#### 查询方式

- 递归查询
- 迭代查询

#### `DNS`的记录分成两种缓存方式

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件

#### 查询过程

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

## CDN

### CDN（内容分发网络）概述

**CDN** 的全称是 **Content Delivery Network**，即内容分发网络。CDN 的主要目的是提高网站内容的传输速度、减少服务器负载，并提升用户的访问体验。

### CDN 的工作原理

CDN 的核心概念是将网站的静态资源（如图片、JavaScript、CSS、视频等）缓存到分布在全球各地的服务器节点上。当用户访问网站时，CDN 会根据用户的位置将请求路由到离用户最近的缓存节点，从而加快资源的加载速度。

具体来说，CDN 的工作原理分为以下几个步骤：

1. **资源缓存**：网站的静态资源被上传到 CDN 供应商的服务器，这些服务器通常称为 CDN 边缘节点。
2. **DNS 解析**：用户访问网站时，DNS 服务器会解析域名，将请求导向最近的 CDN 边缘节点。
3. **内容分发**：最近的 CDN 边缘节点直接将缓存的资源返回给用户。
4. **缓存更新**：当源站点上的资源更新时，CDN 边缘节点会根据缓存策略更新缓存内容，以确保用户获取到的是最新的资源。

### 使用 CDN 的优势

1. **提升加载速度**：由于 CDN 服务器分布在全球各地，用户可以从地理位置最近的服务器获取资源，从而减少加载时间。
2. **减轻服务器负载**：大部分静态资源的请求都由 CDN 边缘节点处理，减少了源服务器的压力。
3. **提高可用性**：即使某个节点出现故障，CDN 会自动切换到其他节点进行服务，从而提高网站的可用性和容错能力。
4. **安全性**：许多 CDN 提供 DDoS 防护和 Web 应用防火墙（WAF）等安全功能，以提高网站的安全防护水平。

### 如何在项目中使用 CDN

使用 CDN 提供的资源通常只需简单地修改资源的加载路径。例如，你本地的某个 JavaScript 文件可能这样引用：
```html
<script src="/js/app.js"></script>
```

如果你将这个文件通过 CDN 提供，可以这样修改为：
```html
<script src="https://cdn.example.com/js/app.js"></script>
```

许多流行的前端库已经提供了 CDN 地址，只需引用相应的 CDN 地址即可。例如，使用 CDN 加载 Vue.js：
```html
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
```

通过这种方式，你可以快速地利用 CDN 的优势，提升网站性能和用户体验。

- HTTP（HyperText Transfer Protocol）是 Web 的基础协议，用于在客户端（通常是浏览器）和服务器之间传输数据。HTTP 协议经历了几个版本的升级，每个版本都有不同的改进和优化，旨在解决前一个版本中的一些缺陷和不足。下面详细介绍 HTTP/1.1、HTTP/2 和 HTTP/3 之间的主要区别，以及每个版本在演进过程中解决的问题。

## HTTP1/2/3的区别

### HTTP/1.1
HTTP/1.1 是最广泛采用的 HTTP 协议版本，它带来了很多改进和优化，但仍存在一些问题。

**主要特点**：

1. **长连接**（Persistent Connections）：HTTP/1.1 引入了长连接，默认使用 `Connection: keep-alive`，允许多个请求和响应在同一 TCP 连接上传输，减少了连接建立和关闭的开销。
2. **管道化**（Pipelining）：支持请求管道化，即在收到响应之前可以发送下一个请求。比如发送了1,2,3，接收顺序也是1,2,3，但是如果网络问题第2个变成第1个接收到的，这个特性在实际中并不常用，因其难以实现和存在队头阻塞（Head-of-Line Blocking）问题。
3. **缓存控制**：增加了更多的缓存控制头，如 `Cache-Control`、`ETag` 等，提高了缓存机制的效率。
4. **字节范围请求**（Range Requests）：允许请求部分内容，特别适用于断点续传和多线程下载。
5. **明文**，报文主体压缩，首部不压缩

**存在的问题**：
1. **队头阻塞**（Head-of-Line Blocking）：通常会发送请求后需要等到收到相应后才能再次发送请求，同一连接上的请求必须按顺序发送和接收，这导致任何一个请求阻塞都会影响后续请求（队头阻塞）。
2. **效率低下**：每个请求都会带上完整的请求头，且请求头相对较大，导致带宽浪费。
3. **连接数量限制**：浏览器对同一域名的并发连接数量有限制，通常是 6 个，可以使用域名分片，资源放在多个子域（麻烦）。这可能会导致资源加载变慢。连接太多可能会导致DDOS攻击

### HTTP/2
HTTP/2 是对 HTTP/1.1 的改进，旨在解决其存在的问题，提高 Web 性能。

**主要特点**：

1. **二进制分帧层**：HTTP/2 使用二进制而非文本格式传输数据，大大减少了消息解析的复杂度。
   - 报文变为二进制的帧
   - 流标识符，根据标识符来进行组合

2. **多路复用**（Multiplexing）：在同一 TCP 连接上并行处理多个请求和响应，解决了 HTTP/1.1 的队头阻塞问题。
   - 把报文分成数据帧，首部帧和尾部帧，有流标识符，使得帧可以不用按顺序抵达，根据流标识符进行组合，帧还可以设置流标识优先级

3. **首部压缩**（Header Compression）：通过 HPACK 压缩算法减少头部传输的冗余，提高传输效率。
   - HPACK: 浏览器和服务器都保存一张静态只读的表
     - <img src="assets/image-20240811224949627.png" alt="image-20240811224949627" style="zoom:33%;" />

4. **服务器推送**（Server Push）：服务器可以主动向客户端推送资源，无需客户端显式请求，提高资源加载速度。
   - 把浏览器可能需要的文件一次性发送过去
     - 缺点：比如误点网页，多了很多缓存，安全性问题，DDOS攻击


**存在的问题**：
1. **队头阻塞的TCP层面问题**：尽管 HTTP/2 解决了应用层的队头阻塞问题，但在 TCP 层，上行和下行仍是顺序处理的，如有丢包现象还是需要重传，会影响整个连接的性能。除非把TCP变成二进制的帧那样，但是TCP是由操作系统内核实现的，不可行，所以有了http3

### HTTP/3
HTTP/3 在 HTTP/2 的基础上进一步改进，用以解决其在 TCP 连接层面上的问题。TCP和TLS是两个协议，所以为了HTTP3的部署，只能选择传输层的UDP协议，并且在UDP上新增协议QUIC

**主要特点**：
1. **基于 QUIC 协议**：HTTP/3 默认使用基于 UDP 的 QUIC 传输协议，解决了 TCP 层的队头阻塞问题。QUIC 集成了 TLS 加密和传输层（把TCP和TLS的握手整合在了一起），确保传输速度和安全性。
2. **快速重建连接**：应用层传来的数据封装为QUIC帧，加了流标识符，封装为QUIC数据包，加了ConnectionId,如果网络发生改变，比如wifi变成4G，根据连接Id确认为同一连接，避免再次握手，所以QUIC 连接一旦建立，不受 IP 地址变化的影响，适用于移动设备切换网络场景，提高了连接的可靠性。
3. **减少连接时延**：由于 QUIC 集成了加密握手过程，而且恢复的会话可以不用握手（0-RTT），减少了连接的建立延迟，提高了性能。

**解决的问题**：
1. **TCP 队头阻塞问题**：,解决了 TCP 层的队头阻塞问题，即使个别数据包丢失，也不会影响后续数据流的传输。
2. **传输效率和安全性**：QUIC 结合了 TLS，加密与传输一体化，简化了加密过程，提高了数据传输安全性。
3. **移动适应性和可靠性**：由于 QUIC 的连接无状态重置和快速重新建立连接的特性，适应性和可靠性相比 HTTP/2 有了很大提升。

### 总结

| 特性/版本  | HTTP/1.1           | HTTP/2        | HTTP/3          |
| ---------- | ------------------ | ------------- | --------------- |
| 传输格式   | 文本               | 二进制        | 二进制          |
| 多路复用   | 不支持             | 支持          | 支持            |
| 头部压缩   | 不支持             | 支持（HPACK） | 支持（QPACK）   |
| 服务器推送 | 不支持             | 支持          | 支持            |
| 队头阻塞   | 应用层和传输层都有 | 仅传输层      | 无              |
| 连接协议   | TCP                | TCP           | QUIC (基于 UDP) |
| 安全加密   | 可选 (TLS)         | 可选 (TLS)    | 必须 (内置TLS)  |

每个 HTTP 版本的演进，都在解决前一个版本中的缺陷，提升传输效率、减少延迟、提高安全性和可靠性。HTTP/3 结合了 QUIC 协议的特点，使得它在实际网络环境中表现更加出色，特别是在现代移动和微服务场景下。

## HTTP 常见的状态码有哪些，适用场景

`http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态`

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误

#### 1xx

`代表请求已被接受，需要继续处理`。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

常见的有：

- 100（客户端继续发送请求，这是临时响应）：这个临时响应是`用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝`。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101：`服务器根据客户端的请求切换协议`，主要用于websocket或http2升级

#### 2xx

代表`请求已成功被服务器接收、理解、并接受`

常见的有：

- 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
- 201（已创建）：请求成功并且服务器创建了新的资源
- 202（已创建）：服务器已经接收请求，但尚未处理
- 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
- 204（无内容）：服务器成功处理请求，但没有返回任何内容
- 205（重置内容）：服务器成功处理请求，但没有返回任何内容
- 206（部分内容）：服务器成功处理了部分请求

#### 3xx

`表示要完成请求，需要进一步操作`。 通常，这些状态代码用来`重定向`

常见的有：

- 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
- 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
- 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
- 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

#### 4xx

`代表了客户端看起来可能发生了错误，妨碍了服务器的处理`

常见的有：

- 400（错误请求）： 服务器不理解请求的语法
- 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403（禁止）： 服务器拒绝请求
- 404（未找到）： 服务器找不到请求的网页
- 405（方法禁用）： 禁用请求中指定的方法
- 406（不接受）： 无法使用请求的内容特性响应请求的网页
- 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
- 408（请求超时）： 服务器等候请求时发生超时

#### 5xx

表示服务器无法完成明显有效的请求。这类状态码`代表了服务器在处理请求的过程中有错误或者异常状态发生`

常见的有：

- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
- 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

#### 适用场景

下面给出一些状态码的适用场景：

- 100：客户端在`发送POST数据给服务器前，征询服务器情况`，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。`常用于POST大数据传输`
- 206：一般用来做`断点续传`，或者是`视频文件等大文件的加载`
- 301：永久重定向会缓存。`新域名替换旧域名`，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
- 302：临时重定向不会缓存，常用 于`未登陆的用户访问用户中心重定向到登录页面`
- 304：`协商缓存，告诉客户端有缓存，直接使用缓存中的数据`，返回页面的只有头部信息，是没有内容部分
- 400：`参数有误，请求无法被服务器识别`
- 403：`告诉客户端禁止访问该站点或者资源`，如在外网环境下，然后访问只有内网IP才能访问的时候则返回
- 404：`服务器找不到资源时，或者服务器拒绝请求又不想说明理由时`
- 503：`服务器停机维护时`，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
- 504：`网关超时`

## GET 和 POST 的区别

#### GET

`GET`方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据

#### get请求会被浏览器缓存吗

[**GET 请求有可能被浏览器缓存**。当服务器返回的响应头包含 “Cache-Control” 或 “Expires” 字段时，浏览器会缓存该请求的响应内容。在下一次请求同样的 URL 时，浏览器会先检查缓存中是否有该请求的响应内容，如果有则直接使用缓存中的内容，不再向服务器发送请求](https://juejin.cn/s/get请求会被浏览器缓存)[1](https://juejin.cn/s/get请求会被浏览器缓存)。

为了防止浏览器缓存，可以采取以下方法之一：

- **添加 HTTP 头**：告诉浏览器不要缓存数据。
- [**添加校验参数**：每次请求时添加一个后端会忽略的参数，例如时间戳。这样浏览器会认为每次都是不同的请求，不会从历史记录中读取数据](https://segmentfault.com/q/1010000021784624)[2](https://segmentfault.com/q/1010000021784624)[3](https://bing.com/search?q=get请求会被浏览器缓存吗)。

#### [#](https://vue3js.cn/interview/http/GET_POST.html#post)POST

`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**



本质上都是`TCP`链接，并无差别

但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别

#### 区别

- `GET在浏览器回退时是无害的`，而``POST会再次提交请求``。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- `GET请求会被浏览器主动cache`，而`POST不会`，除非手动设置。
- `GET请求只能进行url编码`，而`POST支持多种编码方式`。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- `GET请求在URL中传送的参数是有长度限制的`，而`POST没有`。
- 对参数的数据类型，`GET只接受ASCII字符`，而`POST没有限制`。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- `GET参数通过URL传递`，`POST放在Request body中`
- 携带参数的时候，GET`请求是放在`url`中，`POST`则放在`body`中

#### 安全

`POST`比`GET` 安全，因为数据在地址栏上不可见

然而，从传输的角度来说，他们都是不安全的，因为`HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文

只有使用`HTTPS`才能加密安全

#### 数据包

对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应200（返回数据）

对于`POST`，浏览器先发送`header`，服务器响应100 `continue`，浏览器再发送`data`，服务器响应200 ok

并不是所有浏览器都会在`POST`中发送两次包，`Firefox`就只发送一次

## HTTP 常见的请求头有哪些? 作用？

HTTP请求和响应消息中的消息头部分

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 Host: en.wikipedia.org             |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

####  协商缓存

协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

#### 会话状态

`cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `Cookie`有效期、安全性、使用范围的可选属性组成

`Cookie` 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等

## 地址栏输入 URL 敲下回车后发生了什么

- URL解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

#### 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析：

- 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等
- 查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式

关于页面的渲染过程如下：

- 解析HTML，构建 DOM 树
- 解析 CSS ，生成 CSS 规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
- 绘制 render 树（ paint ），绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上

## TCP为什么需要三次握手和四次挥手

### 握手过程（连接建立）

**三次握手 (Three-Way Handshake)**：

1. **SYN（Synchronize）帧**：客户端发送 SYN 包给服务器，表示请求建立连接，并同步序列号。
2. **SYN-ACK（Synchronize-Acknowledgment）帧**：服务器接收到 SYN 包后，回复一个带有 SYN 和 ACK 标志的包，表示同意连接并同步序列号，确认客户端的 SYN 包。
3. **ACK（Acknowledgment）帧**：客户端接收到服务器的 SYN-ACK 包之后，再发送一个 ACK 包，表示确认服务器的 SYN-ACK 包。连接建立成功，双方可以开始通信。

### 挥手过程（连接终止）

**四次挥手 (Four-Way Handshake)**：

1. **FIN（Finish）帧**：主动关闭连接的一方（例如客户端）发送一个 FIN 包，表明它已经没有数据要发了，请求关闭这个方向的连接。
2. **ACK（Acknowledgment）帧**：被动关闭连接的一方（例如服务器）收到 FIN 包后，发送一个 ACK 包，确认已经接收到 FIN 包，但它可能仍有数据要发送。
3. **FIN（Finish）帧**：被动关闭连接的一方（服务器）在完成数据发送后，发送一个 FIN 包，表明它也没有数据要发了，请求关闭连接。
4. **ACK（Acknowledgment）帧**：主动关闭连接的一方（客户端）收到服务器的 FIN 包后，发送一个 ACK 包，确认收到 FIN，连接正式关闭。

### 为什么挥手比握手多一次？

以下是原因和详细解释：

1. **全双工通信的特点**：
   - TCP 是全双工的，这意味着数据可以在连接双方的任意方向上同时传输。断开连接时，每个方向的连接都必须单独关闭，以确保所有未完成的数据传输能够完成。
2. **确保数据完整传输**：
   - 握手阶段主要目的是建立稳定的连接，因此三次握手就足够了。而在断开连接时，需要确保双方都已经完成了所有数据的传输，这需要更多的步骤。
3. **独立的关闭请求**：
   - 每一方都需要独立地发送一个 FIN 包来表示自己没有数据可发送了。例如，客户端发送一个 FIN 包后，还需要等待服务器完成自己的数据发送。这使得 ACK 和 FIN 的交互过程变成了两步。

### 示例流程示意图

```
客户端                      服务器
   |                            |
   | —————> (SYN) —————>        |  初次请求连接
   | <————— (SYN-ACK) <—————    |  同意建立连接
   | —————> (ACK) —————>        |  确认连接建立
   |                            |
   |           连接建立         |
   |                            |
   | —————> (FIN) —————>        |  请求关闭连接
   | <————— (ACK) <—————        |  确认关闭请求
   |                            |
   |                            | —————> (FIN) —————>
   |                            |   数据传输完成后关闭连接
   | <————— (ACK) <—————        |  确认关闭连接
   |                            |
   |        连接关闭            |
   |                            |
```

### 总结

1. **三次握手**：用于可靠地建立连接，主要包括同步序列号和确认双方具备通信能力。
2. **四次挥手**：用于可靠地终止连接，确保双方都已经关闭且没有未发送的数据，分别关闭两个方向的连接。

## 说说对WebSocket的理解？应用场景？

WebSocket，是一种`网络传输协议`，位于`OSI`模型的`应用层`。可在`单个TCP`连接上进行`全双工通信`，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器`只需要完成一次握手`，两者之间就可以创建`持久性的连接`，并进行`双向数据传输`



`websocket`出现之前，开发实时`web`应用的方式为`轮询`

不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果`轮询的频率比较高，那么就可以近似地实现“实时通信”的效果`

轮询的`缺点`也很明显，反复发送无效查询请求`耗费了大量的带宽`和 `CPU`资源



#### 全双工

通信`允许数据在两个方向上同时传输`，它在能力上相当于两个单工通信方式的结合

例如指 A→B 的同时 B→A ，是瞬时同步的

#### 二进制帧

采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比`http/2`，`WebSocket`更侧重于“实时通信”，而`HTTP/2` 更侧重于提高传输效率，所以两者的帧结构也有很大的区别

#### 协议名

引入`ws`和`wss`分别代表明文和密文的`websocket`协议，且默认端口使用80或443，几乎与`http`一致

#### 握手

`WebSocket`也要有一个握手过程，然后才能正式收发数据

#### 优点

- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

#### 应用场景

基于`websocket`的事实通信的特点，其存在的应用场景大概有：

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新

## url有长度限制吗

URL 的长度在不同浏览器和协议中有一定的限制。让我们来详细了解一下：

1. **HTTP/1.1 规范**：
   - 最初的 HTTP/1.1 规范（RFC 2616）并没有对 URI（Uniform Resource Identifier，即 URL）的长度设定明确的上限。
   - [服务器应该能够处理任何资源的 URI，如果服务器无法处理过长的 URI，应该返回状态码 414（Request-URI Too Long）](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)[1](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)。
2. **实际使用情况**：
   - 实际上，不同浏览器和服务器软件对请求行长度都有一些限制。
   - 通常，如果你将 URL 保持在 **2000 个字符以内**，它们将在几乎所有组合的客户端和服务器软件以及搜索引擎中正常工作。
   - 对于特定用例，可以考虑使用更长的 URL。
3. **推荐长度**：
   - 根据最新的规范（RFC 9110），建议所有发送方和接收方至少支持 **8000 个八位字节** 长度的 URI。
   - [这意味着如果你的 URL 在 8000 个字符以内，它应该在大多数情况下都能正常工作](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)[1](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)。

[总之，如果你的 URL 在 **2000 个字符以内**，它将在几乎所有组合的客户端和服务器软件中正常工作。但是，如果你有特定的用例，可以考虑使用更长的 URL。](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)



## Http协议的Content-Type

在HTTP协议中，“Content-Type”是一个头部字段（header field），用于`指示资源的媒体类型`（也称为`MIME`类型）。这个头部字段告诉客户端实际返回的内容的格式是什么，以此来确保正确的解析和处理数据。

例如：

1. 如果服务器返回的是普通文本，头部可能会标注为：

   ```javascript
   Content-Type: text/plain
   ```

2. 如果返回的是HTML文档，则头部可能是：

   ```
   Content-Type: text/html
   ```

3. 对于JSON格式的数据，头部则会标注为：

   ```
   Content-Type: application/json
   ```

4. 对于图片和视频，Content-Type也有不同的值，例如：

   - 图片PNG格式：`Content-Type: image/png`
   - 视频MP4格式：`Content-Type: video/mp4`

在编写HTTP服务器响应客户端请求时，正确设置“Content-Type”头部非常重要，以确保客户端软件（如浏览器）能正确解析和显示内容。

## SSE

服务器发送事件(Server-Sent Events, SSE)是一种网络通信技术，允许服务器向客户端推送实时数据。以下是对SSE的详细介绍：

1. 基本概念：

   - SSE是HTML5规范的一部分。
   - 它提供了一种单向通信机制，从服务器到客户端。
   - 基于HTTP协议，使用标准的GET请求。

2. 工作原理：

   - 客户端发起一个HTTP连接到服务器。
   - 服务器保持这个连接开放，并通过它发送事件。
   - 连接长期保持开放状态，直到客户端关闭或服务器终止。

3. 数据格式：

   - 服务器发送的数据格式为"text/event-stream"。

   - 每条消息以一个或多个文本行组成，以换行符分隔。

   - 典型的消息格式：

     ```
     event: eventName
     data: Your message here
     id: messageId
     ```

4. 客户端API：

   - 使用EventSource对象创建连接：

     ```javascript
     const eventSource = new EventSource('/events');
     ```

   - 监听事件：

     ```javascript
     eventSource.onmessage = (event) => {
       console.log(event.data);
     };
     ```

5. 服务器实现：

   - 服务器需要设置正确的头部：

     ```
     Content-Type: text/event-stream
     Cache-Control: no-cache
     Connection: keep-alive
     ```

   - 然后发送格式化的事件数据。

6. 优点：

   - 简单易用，基于标准HTTP。
   - 自动重连机制。
   - 跨域支持（通过CORS）。
   - 服务器端实现简单。

7. 限制：

   - 单向通信（服务器到客户端）。
   - 不是所有浏览器都支持（但主流浏览器支持良好）。
   - 连接数限制（每个浏览器对同一域名的连接数有限制）。

8. 应用场景：

   - 实时新闻推送。
   - 股票价格更新。
   - 社交媒体实时通知。
   - 即时聊天应用的部分功能。

9. 与WebSocket比较：

   - SSE更轻量，实现更简单。
   - WebSocket支持双向通信，功能更强大。
   - SSE基于HTTP，更容易通过防火墙。

10. 安全性考虑：

    - 使用HTTPS加密传输。
    - 实施适当的认证和授权机制。

11. 性能优化：

    - 合理控制消息发送频率。
    - 在客户端实现错误处理和重连逻辑。

## 浏览器的同源策略

### 1.1同源策略概述


同源策略是`浏览器为确保资源安`全，而`遵循的一种策略`，该策略`对访问资源进行了一些限制`。
W3C 上对同源策略的说明：[Same origin policy](https://www.w3.org/Security/wiki/Same_Origin_Policy)。

### 1.2什么是源（origin）？


**1源的组成部分**



![image.png](https://img-blog.csdnimg.cn/img_convert/33a80a2d737e19650ae7757eccd938f6.png)


**下面表格中，只有最后一行的两个源是同源。**

| 源 1                         | 源 2                           | 是否同源 |
| ---------------------------- | ------------------------------ | -------- |
| http://www.xyz.com/home      | https://www.xyz.com/home       | ⛔非同源️  |
| http://www.xyz.com/home      | http://mail.xyz.com/home       | ⛔非同源  |
| http://www.xyz.com:8080/home | http://www.xyz.com:8090/home   | ⛔非同源  |
| http://www.xyz.com:8080/home | http://www.xyz.com:8080/search | ✅同 源︎   |



**同源请求**



![image.png](https://img-blog.csdnimg.cn/img_convert/2081b3b2d85c9d7a0ea9ff82e8663e92.png)


**4非同源请求**





![image.png](https://img-blog.csdnimg.cn/img_convert/9474242fbaf1ee01437a76fd89a4c2e6.png)


**5总结:『所处源』与『目标源』不一致，就是『非同源』，又称『异源』或『跨域』**

## 2跨域会受到哪些限制


例如有两个源：『源A』和『源B』，它们是『非同源』的，那么浏览器会有如下限制：

### 2.1限制DOM访问

『源A』的脚本不能访问『源B』的 DOM。

```cobol
<!-- <iframe id="framePage" src="./demo.html"></iframe> -->

<iframe id="framePage" src="https://www.baidu.com"></iframe>

<script type="text/javascript" >

  function showDOM(){

    const framePage = document.getElementById('framePage')

    console.log(framePage.contentWindow.document) //同源的可以获取，非同源的无法获取
  }
</script>
```

### 2.2限制Cookie访问

『源A』不能访问『源B』的 cookie

```cobol
<iframe id="baidu" src="http://www.baidu.com" width="500" height="300"></iframe>

<script type="text/javascript" >
  // 访问的是当前源的cookie，并不是baidu的cookie
  console.log(document.cookie)
</script>
```

### 2.3限制Ajax获取数据

『源A』可以给『源B』发请求，但是无法获取『源B』响应的数据。

```typescript
const url = 'https://www.toutiao.com/hot-event/hot-board/?origin=toutiao_pc'
let result = await fetch(url)
let data = await result.json();
console.log(data)
```

>  备注：在上述限制中，浏览器对 Ajax 获取数据的限制是影响最大的一个，且实际开发中经常遇到。

## 3几个注意点 

1. `跨域限制仅存在浏览器端`，`服务端不存在`跨域限制。
2. `即使跨域`了，`Ajax 请求也可以正常发出`，但`响应数据不会交给开发者`。
3. <link>、<script>、<img>...... 这些标签发出的请求也可能跨域，只不过浏览器对标签跨域不做严格限制，对开发几乎无影响



![image.png](https://img-blog.csdnimg.cn/img_convert/6ef6a9a11e46dc02ba24e4e6fc18162e.png)

## CORS 解决 Ajax 跨域问题

### 4.1CORS 概述

`CORS` 全称：`Cross-Origin Resource Sharing`（`跨域资源共享`），是用于控制浏览器校验跨域请求的一套规范，服务器依照 CORS 规范，`添加特定响应头来控制浏览器校验`，大致规则如下：

1. 服务器明确表示拒绝跨域请求，或没有表示，则浏览器校验不通过。
2. 服务器明确表示允许跨域请求，则浏览器校验通过。
3. 备注说明：使用 CORS 解决跨域是最正统的方式，且要求服务器是“自己人”。

###  4.2CORS 解决简单请求跨域

整体思路：服务器在给出响应时，通过`添加Access-Control-Allow-Origin响应头`，来`明确表达允许某个源发起跨域请求`，随后浏览器在校验时，直接通过。



![image.png](https://img-blog.csdnimg.cn/img_convert/7fc3d4076e0424a705f91a39b41533fe.png)

服务端核心代码（以express框架为例）：

```cobol
// 处理跨域中间件
function corsMiddleWare(req,res,next){
  // 允许 http://127.0.0.1:5500 这个源发起跨域请求
  // res.setHeader('Access-Control-Allow-Origin','http://127.0.0.1:5500')
  // 允许所有源发起跨域请求
  res.setHeader('Access-Control-Allow-Origin','*')
  next()
}
// 配置路由并使用中间件
app.get('/',corsMiddleWare,(req,res)=>{
  res.send('hello!')
})
```

## 简单请求与复杂请求

CORS 会把请求分为两类，分别是：① `简单请求`、② `复杂请求`。

| 简单请求                                                     | 复杂请求                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ✅请求方法（method）为：`GET`、`HEAD`、`POST`                 | 1不是简单请求，就是复杂请求。 2复杂请求会`自动发送预检请求`。 |
| ✅请求头字段要符合[《CORS 安全规范》](https://fetch.spec.whatwg.org/#cors-safelisted-request-header) 简记：只要不手动修改请求头，一般都能符合该规范。 |                                                              |
| ✅请求头的Content-Type的值只能是以下三种： ●text/plain ●multipart/form-data ●application/x-www-form-urlencoded |                                                              |

### 

**关于预检请求：**

- 发送`时机`：`预检请求在实际跨域请求之前发出`，是由`浏览器自动发起`的。
- 主要`作用`：用于`向服务器确认是否允许接下来的跨域请求`。
- 基本`流程`：先`发起OPTIONS请求`，如果`通过预检`，`继续发起实际的跨域请求`。
- 请求`头内容`：一个`OPTIONS预检请求`，通常会包含如下请求头：

| 请求头                           | 含义                                     |
| -------------------------------- | ---------------------------------------- |
| `Origin`                         | `发起请求的源`                           |
| `Access-Control-Request-Method`  | 实际请求的` HTTP 方法`                   |
| `Access-Control-Request-Headers` | 实际请求中使用的`自定义头`（如果有的话） |

### 4.4CORS 解决复杂请求跨域

1第一步：服务器先通过浏览器的预检请求，服务器需要返回如下响应头：

| 响应头                       | 含义                           |
| ---------------------------- | ------------------------------ |
| Access-Control-Allow-Origin  | 允许的源                       |
| Access-Control-Allow-Methods | 允许的方法                     |
| Access-Control-Allow-Headers | 允许的自定义头                 |
| Access-Control-Max-Age       | 预检请求的结果缓存时间（可选） |





![image.png](https://img-blog.csdnimg.cn/img_convert/b518d361e5d112a0b6cf9f118df52c6e.png)

2第二步：处理实际的跨域请求（与处理简单请求跨域的方式相同）

![image.png](https://img-blog.csdnimg.cn/img_convert/7fc3d4076e0424a705f91a39b41533fe.png)

服务端核心代码：

```javascript
// 处理预检请求
app.options('/students', (req, res) => {
  // 设置允许的跨域请求源
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  // 设置允许的请求方法
  res.setHeader('Access-Control-Allow-Methods', 'GET')
  // 设置允许的请求头
  res.setHeader('Access-Control-Allow-Headers', 'school')
  // 设置预检请求的缓存时间（可选）
  res.setHeader('Access-Control-Max-Age', 7200)
  // 发送响应
  res.send()
})

// 处理实际请求
app.get('/students', (req, res) => {
  // 设置允许的跨域请求源
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  // 随便设置一个自定义响应头
  res.setHeader('abc',123)
  // 设置允许暴露给客户端的响应头
  res.setHeader('Access-Control-Expose-Headers', 'abc')
  // 打印请求日志
  console.log('有人请求/students了')
  // 发送响应数据
  res.send(students)
})
```

### 4.5借助 cors 库快速完成配置

上述的配置中需要自己配置响应头，或者需要自己手动封装中间件，借助cors库，可以更方便完成配置



●安装cors

```less
npm i cors
```

●简单配置cors

```php
app.use(cors())
```

●完整配置cors

```cobol
// cors中间件配置
const corsOptions = {
  origin: 'http://127.0.0.1:5500', // 允许的源
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS'], // 允许的方法
  allowedHeaders: ['school'], // 允许的自定义头

  exposedHeaders: ['abc'], // 要暴露的响应头

  optionsSuccessStatus: 200 // 预检请求成功的状态码
};
app.use(cors(corsOptions)); // 使用cors中间件
```

> 默认`js是不能访问后端设置的响应头的`，`需要后端暴露`

## JSONP 解决跨域问题

1JSONP 概述： JSONP 是`利用了<script>标签可以跨域加载脚本`，且`不受严格限制的特性`，可以说是程序员智慧的结晶，早期一些浏览器不支持 CORS 的时，可以靠 JSONP 解决跨域。


2基本流程：

- 第一步：`客户端创建一个<script>标签`，并将其`src属性设置为包含跨域请求的 URL`，同时`准备一个回调函数`，这个回调函数`用于处理返回的数据`。
- 第二步：`服务端接收到请求后`，将`数据封装在回调函数中并返回`。
- 第三步：`客户端的回调函数被调用`，`数据以参数的形势传入回调函数`。

3图示：



![image.png](https://img-blog.csdnimg.cn/img_convert/a9b69cb4c148848bc9bd6aa7a0474312.png)

4代码示例：

```cobol
<button onclick="getTeachers()">获取数据</button>
<script type="text/javascript" >
  function callback(data){
    console.log(data)
  }

  function getTeachers(url){
    // 创建script元素
    const script = document.createElement('script')
    // 指定script的src属性
    script.src= 'http://127.0.0.1:8081/teachers'
    // 将script元素添加到body中触发脚本加载
    document.body.appendChild(script)
    // script标签加载完毕后移除该标签
    script.onload = ()=>{
      script.remove()
    }
  }
</script>
```

jQuery 封装的 jsonp

> ?callback=?' 为固定格式 会自动解析

```typescript
$.getJSON('http://127.0.0.1:8081/teachers?callback=?',(data)=>{
  console.log(data)
})
```

## 配置代理解决跨域

### 6.1自己配置代理服务器



> 服务器之间是没有跨域问题的，要使用express 启动静态资源保证自己的服务器跟页面在同源下

```php
// 启动静态资源 让服务器跟页面同一个源
app.use(express.static("./public"));
```

借助http-proxy-middleware配置代理

```php
const { createProxyMiddleware } = require('http-proxy-middleware');
app.use('/api',createProxyMiddleware({

  target:'https://www.toutiao.com',

  changeOrigin:true,

  pathRewrite:{

    '^/api':''

  }
```

 

优点：

- 功能丰富：http-proxy-middleware提供了丰富的配置选项，可以满足各种代理需求。
- 可以灵活配置多个代理：可以配置多个代理服务器，分别对应不同的接口路径。
- 可以拦截请求：可以通过自定义的处理函数对请求进行拦截和修改。

缺点：

- 配置相对复杂：需要了解http-proxy-middleware库的配置规则和参数。
- 不适用于生产环境：http-proxy-middleware主要用于开发环境，不适用于生产环境。

使用场景：

- 适用于使用任何构建工具的前端项目，可以与任何开发服务器配合使用。
- 适用于需要灵活配置多个代理服务器的场景。
- 适用于需要对请求进行拦截和修改的场景。

### 使用 Nginx 搭建代理服务器

整体思路：让nginx充当两个角色，既是 静态内容服务器，又是代理服务器。

修改nginx配置如下，注意nginx的根目录最好不是 C 盘

```cobol
# 配置nginx根目录
location / {
  root   D:\dist;
  index  index.html index.htm;
}
# 配置代理
location /dev/ {
  # 设置代理目标
  proxy_pass http://sph-h5-api.atguigu.cn/;
}
```

2修改前端项目，让所有请求都转发给 /dev，随后重新打包

```php
const request = axios.create({
  baseURL:'/dev',
  timeout:10000
})
```

随后直接访问nginx服务器即可，例如 nginx如果运行在8099端口，则访问

```cobol
http://localhost:8099
```

随后会遇到刷新404问题，追加nginx配置来解决

```cobol
# 配置nginx根目录
location / {
  root   D:\dist;
  index  index.html index.htm;
  try_files $uri $uri/ /index.html; # 解决刷新404
}
# 配置代理
location /dev/ {
  # 设置代理目标
  proxy_pass http://sph-h5-api.atguigu.cn/;
}
```

加上这两个“/”就剔除掉了dev

![img](https://i-blog.csdnimg.cn/direct/cfaa51e3932442a488eb2a44ac542ccd.png)

### 6.3借助脚手架搭建服务器 

1. 使用vue.config.js文件配置代理：

在Vue项目的根目录下创建一个vue.config.js文件，并添加以下代码：

```java
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}
```

上述代码中，我们使用`devServer`配置项来配置代理服务器。其中`proxy`属性用于配置代理的规则，`/api`表示需要代理的接口路径。`target`属性表示代理的目标服务器地址，`changeOrigin`属性表示是否改变请求的源地址，`pathRewrite`属性用于重写请求的路径。

优点：

- 配置简单：使用webpack-dev-server的代理配置，只需要在webpack配置文件中进行简单的配置即可。
- 功能全面：webpack-dev-server提供了丰富的配置选项，可以满足大部分代理需求。
- 可以拦截请求：可以通过自定义的处理函数对请求进行拦截和修改。

缺点：

- 需要重启服务器：配置修改后需要重新启动webpack-dev-server才能生效。
- 不适用于生产环境：webpack-dev-server主要用于开发环境，不适用于生产环境。

使用场景：

- 适用于使用webpack构建的前端项目，通过webpack-dev-server来启动开发服务器的场景。
- 适用于需要简单的代理配置，并且不需要频繁修改代理配置的场景。

## url的长度限制

1. `HTTP协议本身没有对URL长度做出明确限制`：

   - `HTTP/1.1规范(RFC 2616)并没有规定URL的最大长度`。

2. 然而，在实际应用中，`URL长度可能受到以下因素的限制`：

   a)` 服务器限制`：

   - 不同的Web服务器可能有自己的URL长度限制。
   - 例如，`Apache服务器默认限制URL长度为8192字符`。
   - `Microsoft Internet Information Server` (IIS)默认`限制URL长度为16384字符`。

   b) `浏览器限制：`

   - 不同的浏览器可能对URL长度有不同的处理能力。
   - 例如，Internet Explorer的最大URL长度是2083字符。

   c) `代理服务器和防火墙`：

   - 一些代理服务器或防火墙`可能对长URL有特殊处理或限制`。

   d) 客户端操作系统：

   - 某些操作系统可能对命令行长度有限制，这可能间接影响URL长度。

3. 最佳实践：

   - 尽管理论上URL可以很长，但出于实用性和兼容性考虑，通常建议将URL长度控制在2000字符以内。
   - 对于需要传递大量数据的情况，建议使用POST方法而不是GET。

4. GET方法的注意事项：

   - 虽然`GET方法的URL理论上没有严格限制`，但`过长的URL可能导致以下问题`：
     - `可读性差`
     - `容易出错`
     - 可能`超出服务器或浏览器的处理能力`
     - `安全风险（敏感信息暴露在URL中）`

## 代理服务器转发是正向代理还是反向代理，有什么区别

代理服务器可以实现正向代理和反向代理，这两种类型的代理有不同的用途和特点。让我们来详细了解一下：

正向代理：

1. 定义：正向代理代表客户端向目标服务器发送请求。

2. 工作流程：
   客户端 -> 正向代理服务器 -> 互联网 -> 目标服务器

3. 特点：
   - 客户端知道目标服务器的存在，但目标服务器不知道客户端的真实身份。
   - 通常由客户端配置使用。

4. 用途：
   - 访问被限制的资源（如翻墙）
   - 提高访问速度（缓存）
   - 保护客户端隐私
   - 绕过内容过滤

5. 例子：VPN服务、某些网络加速器

反向代理：

1. 定义：反向代理代表服务器接收来自客户端的请求。

2. 工作流程：
   客户端 -> 互联网 -> 反向代理服务器 -> 目标服务器

3. 特点：
   - 客户端不知道真正的目标服务器，只知道反向代理服务器。
   - 通常由服务器端配置使用。

4. 用途：
   - 负载均衡
   - 保护后端服务器安全
   - 缓存静态内容
   - SSL终结
   - 压缩
   - 提供统一接口

5. 例子：Nginx、HAProxy、CDN服务

主要区别：

1. 代表对象：
   - 正向代理代表客户端
   - 反向代理代表服务器

2. 配置位置：
   - 正向代理通常在客户端配置
   - 反向代理在服务器端配置

3. 可见性：
   - 正向代理对服务器透明
   - 反向代理对客户端透明

4. 主要用途：
   - 正向代理主要用于帮助客户端访问无法直接访问的资源
   - 反向代理主要用于保护和优化服务器资源

5. IP地址：
   - 正向代理隐藏了客户端的真实IP
   - 反向代理隐藏了真实服务器的IP

6. 安全性：
   - 正向代理可能被用来绕过安全限制
   - 反向代理通常用来增强安全性

总的来说，代理服务器转发既可以是正向代理，也可以是反向代理，具体取决于其配置和用途。在实际应用中，正确选择和配置代理类型对于实现预期的网络架构和功能至关重要。

## websocket

websocket之前通过轮询实现高频次的传输,明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源

WebSocket 在建立连接时，初始的握手使用的是标准的 HTTP 协议，这个握手过程中会包含 HTTP 请求和响应头。但是，一旦 WebSocket 连接建立之后，数据交换就不再使用 HTTP 协议，而是转而使用 WebSocket 特有的数据帧格式来传输数据。

WebSocket 使用的是自己的协议，称为 WebSocket 协议。它是一个独立的、基于 TCP 的协议

### 握手过程

- 初始连接使用 HTTP/HTTPS 升级请求
- 之后切换到 WebSocket 协议
  - ws:// (非加密)
  - wss:// (加密，使用 TLS/SSL)
- 端口
  - 默认使用 80 端口 (ws://)
  - 默认使用 443 端口 (wss://)

### 优点

1. 实时性强：WebSocket提供了真正的全双工通信，数据可以实时双向传输。
2. 减少延迟：一旦建立连接，数据传输没有额外的HTTP请求开销，减少了延迟。
3. 更少的网络流量：相比轮询等技术，WebSocket减少了不必要的网络流量。
4. 支持跨域：WebSocket天生支持跨域通信。
5. 保持连接状态：长连接可以保持客户端状态，更容易实现客户端与服务器的实时交互。
6. 更好的二进制支持：相比HTTP，WebSocket更适合传输二进制数据。
   1. 支持二进制帧，可以直接发送和接收二进制数据
   2. 建立连接后，传输数据的帧头很小，减少了额外开销

### 缺点

1. 复杂性增加：相比简单的HTTP请求，WebSocket的实现和管理更为复杂。

2. 服务器压力：长时间保持连接可能会增加服务器的负载。

3. 兼容性问题：某些老旧浏览器可能不支持WebSocket。

4. 连接中断处理：网络不稳定时，需要处理连接中断和重连的情况。

5. 扩展性挑战：在处理大量并发WebSocket连接时，可能面临扩展性问题。

## websocket和http的区别

WebSocket和HTTP是两种用于在客户端（通常是浏览器）和服务器之间进行通信的协议，它们虽然都用于网络通信，但在设计和应用场景上存在显著的区别。

### HTTP

HTTP（Hypertext Transfer Protocol）是一种无状态的协议，主要用于网页浏览和Web应用程序的通信。以下是HTTP的一些关键特性：

1. **请求-响应模式**：
   - HTTP是基于请求-响应模式的协议。客户端发送请求到服务器，服务器处理请求并发送响应回客户端。
   
2. **无状态**：
   - HTTP是无状态的，这意味着每个请求都是独立的，与之前或之后的请求没有关联。虽然可以通过使用Cookies、Sessions等技术来维持某种状态，但HTTP本身是无状态的。

3. **短连接**：
   - HTTP/1.0每次请求都需要新建一个TCP连接。HTTP/1.1 引入了持久连接（Keep-Alive），允许在一个TCP连接上发送多个请求/响应，但在响应完毕后连接通常会关闭。

4. **文本协议**：
   - HTTP是一个文本协议，消息体可以是纯文本、HTML、JSON/XML等，头部信息也是人类可读的文本。

5. **应用层协议**：
   - HTTP是一个基于TCP的应用层协议，使用IP、TCP等协议进行数据传输。默认使用TCP端口80（HTTP）或443（HTTPS）。

#### 示例

```http
GET /index.html HTTP/1.1
Host: www.example.com

HTTP/1.1 200 OK
Content-Type: text/html

<html>
<!-- HTML content here -->
</html>
```

### WebSocket

WebSocket是为了解决HTTP无法持续连接的问题而设计的协议，旨在提供全双工通信——客户端和服务器都可以随时发送消息。以下是WebSocket的关键特性：

1. **全双工通信**：
   - WebSocket允许服务器和客户端之间进行双向通信，客户端和服务器可以在任何时候发送数据，而无需等待对方先发送数据。

2. **持久连接**：
   - WebSocket通过单个TCP连接进行通信，从建立连接到关闭连接期间，这个连接始终保持打开状态。

3. **低开销**：
   - 与HTTP相比，WebSocket因其头部较少（只有在握手阶段使用HTTP的头部信息），因此发送的消息更小，开销更低，更适合实时应用。

4. **二进制和文本传输**：
   - WebSocket不仅支持文本数据传输，还支持二进制数据传输，例如ArrayBuffer和Blob。

5. **建立在TCP之上**：
   - WebSocket也是基于TCP协议的，类似于HTTP，但其设计是用来处理实时通信的应用，默认使用TCP端口80（WebSocket）或443（WebSocket over TLS/SSL，即wss）。

#### 示例

WebSocket连接的建立过程首先通过HTTP的GET请求进行WebSocket握手，然后切换协议：

握手请求：

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

握手响应：

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

之后通信将切换到WebSocket协议，两端可以随时双向发送数据。

客户端示例：

```javascript
let socket = new WebSocket("ws://www.example.com/chat");

socket.onopen = function(event) {
    console.log("Connection established");
    socket.send("Hello Server!");
};

socket.onmessage = function(event) {
    console.log("Received message from server: " + event.data);
};

socket.onclose = function(event) {
    console.log("Connection closed");
};

socket.onerror = function(error) {
    console.log("WebSocket error: " + error.message);
};
```

### 详细对比

| 特性           | HTTP                                           | WebSocket                                                  |
| -------------- | ---------------------------------------------- | ---------------------------------------------------------- |
| 通信模式       | 请求-响应                                      | 全双工                                                     |
| 连接类型       | 短连接（HTTP/1.1可以保持连接，但通常为短连接） | 长连接                                                     |
| 传输的数据类型 | 主要为文本（HTML、JSON、XML等）                | 文本和二进制数据（ArrayBuffer、Blob等）                    |
| 头部开销       | 较大                                           | 较小（握手后开销极低）                                     |
| 适用场景       | 适用于请求-响应模式的通信，如网页浏览、API调用 | 适用于需要实时通信的应用，如在线聊天、实时游戏、股票行情等 |
| 连接端口       | 80（HTTP）或 443（HTTPS）                      | 80（WS）或 443（WSS）                                      |
| 标准           | HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3             | RFC 6455                                                   |

### 适用场景

- **HTTP**：
  - 适合大多数Web服务场景，如加载网页、获取静态资源（CSS、JS、图像等）、调用RESTful API等。
  - 适用于一次性请求和响应的场景，且请求间互不相关。

- **WebSocket**：
  - 适合需要实时交流的场景，例如在线聊天应用、实时游戏、股票行情推送、实时协作工具等。
  - 适用于需要长时间持续通信，且短时间内需要频繁数据交换的场景。

总结来说，HTTP适合传统的请求-响应模式，而WebSocket适合需要高效实时双向通信的应用。了解两者的区别和应用场景，有助于开发者为各类应用选择合适的网络通信协议。

## restful API

RESTful API （Representational State Transfer API） 是一种基于REST（Representational State Transfer）架构风格的设计规范，用于设计和实现网络服务。RESTful API广泛应用于Web服务和网络应用，通过HTTP协议实现资源的创建、读取、更新和删除（CRUD操作）。下面将详细深入地介绍RESTful API的各个方面。

### REST架构风格

REST是一种分布式系统的架构风格，由Roy Fielding在他的博士论文中首次定义。REST架构风格基于以下几个关键原则：

1. **客户端-服务器架构**：
   - 使用客户端-服务器模型实现分离关注点（Separation of Concerns）。客户端负责用户界面和用户交互，而服务器负责数据存储和业务逻辑。

2. **无状态性**：
   - 服务器不在请求之间保存客户端的状态。每个请求都应包含处理该请求所需要的所有信息，这使得请求彼此独立。

3. **可缓存性**：
   - 客户端和服务器都可以缓存响应以提高性能。响应必须定义其是否可缓存以及缓存的有效期。

4. **统一接口**：
   - 通过统一的接口简化和分离客户端和服务器。统一接口包括资源标识、资源操作和消息格式。

5. **分层系统**：
   - 系统可以分为多个层，每一层只与相邻层交互。分层系统有助于构建更灵活、可扩展的系统架构。

6. **按需代码**：
   - 服务器可以扩展客户端的功能，通过提供可执行代码（例如，通过JavaScript），使得客户端可以动态加载功能。

### RESTful API的基本概念

#### 资源

在RESTful API中，资源是API的核心概念。资源可以是任何东西，例如用户、文章、图片等。资源通过URI（Uniform Resource Identifier）标识。URI是资源在网络中的唯一标识符。

例如：
  - `/users`：表示用户资源集合。
  - `/users/123`：表示ID为123的特定用户。

#### HTTP动词

RESTful API使用标准的HTTP动词来进行不同的操作，每个动词对应一种操作：

- **GET**：读取资源。
  - `/users`：获取用户列表。
  - `/users/123`：获取ID为123的用户信息。

- **POST**：创建资源。
  - `/users`：创建新用户。

- **PUT**：更新资源（替换资源）。
  - `/users/123`：更新ID为123的用户信息。

- **PATCH**：部分更新资源。
  - `/users/123`：部分更新ID为123的用户信息。

- **DELETE**：删除资源。
  - `/users/123`：删除ID为123的用户信息。

#### HTTP状态码

RESTful API使用HTTP状态码来指示操作的结果。常用的状态码包括：

- **200 OK**：请求成功。
- **201 Created**：资源成功创建（通常用于POST操作）。
- **204 No Content**：请求成功但没有返回内容。
- **400 Bad Request**：客户端请求错误，例如参数不合法。
- **401 Unauthorized**：未授权，需要认证。
- **403 Forbidden**：已认证但没有权限访问资源。
- **404 Not Found**：资源未找到。
- **500 Internal Server Error**：服务器内部错误。

#### 消息格式

RESTful API通常使用JSON作为消息格式，因为JSON是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成。不过，API也可以使用其他格式如XML。

请求示例（创建新用户 - POST）：

```http
POST /users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "johndoe@example.com"
}
```

响应示例：

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "id": 123,
  "name": "John Doe",
  "email": "johndoe@example.com"
}
```

### RESTful API设计

以下是设计RESTful API的一些最佳实践：

#### 1. 资源命名

资源的命名应使用名词且尽量保持简洁。应当使用复数形式表示资源集合。

```text
/users           // 用户资源集合
/users/123       // 单个用户资源
/products        // 产品资源集合
/products/456    // 单个产品资源
```

#### 2. 动词使用

应利用HTTP动词进行操作，而不是在URL中包含动词：

```text
GET    /users             // 获取用户列表
POST   /users             // 创建新用户
GET    /users/123         // 获取ID为123的用户信息
PUT    /users/123         // 更新ID为123的用户信息
DELETE /users/123         // 删除ID为123的用户信息
```

#### 3. 使用嵌套资源

当资源具有层级关系时，可以使用嵌套的URL结构：

```text
GET /users/123/orders          // 获取用户123的订单列表
GET /users/123/orders/789      // 获取订单ID为789的详细信息
```

#### 4. 过滤、排序和分页

通过查询参数实现数据过滤、排序和分页，以提高查询性能和可用性：

```text
GET /products?category=books&sort=price&order=asc&page=2&limit=10
```

#### 5. API版本控制

为了确保API的可升级性和兼容性，往往需要对API进行版本控制：

```text
GET /v1/users/123          // 使用URL路径指定版本
GET /users/123?version=1   // 使用查询参数指定版本
Header: Accept: application/vnd.example.v1+json  // 使用HTTP头部指定版本
```

#### 6. 错误处理

应使用合适的HTTP状态码和错误消息返回详细的错误信息：

```json
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "InvalidRequest",
  "message": "The field 'email' is required."
}
```

### RESTful API的优缺点

**优点**：

1. **简洁直观**：基于URI和HTTP动词的设计，很自然且易于理解和使用。
2. **无状态、可扩展**：无状态设计使得服务器更容易扩展，负载均衡更简单。
3. **缓存支持**：基于HTTP协议的RESTful API天然支持缓存，提高了性能。
4. **多格式支持**：可以使用JSON、XML等多种格式进行数据传输，灵活性高。

**缺点**：

1. **无状态的限制**：在某些场景下REST无状态性可能会带来额外的开发复杂度，需通过其他方式（如JWT Token等）管理状态。
2. **实时性不足**：对于需要实时通信的应用场景，REST可能无法满足实时要求，而需要使用WebSocket等其他协议。

### RESTful API vs RPC

REST和RPC（Remote Procedure Call）是两种不同的API设计风格：

- **RPC**：基于方法调用的API设计，通常会暴露调用的方法或函数。常见的RPC技术包括SOAP、gRPC等。
- **REST**：基于资源的API设计，更倾向于将操作施加于资源上，而非直接的方法调用。

REST更具资源导向，避免了暴露服务器的内部方法细节，而RPC更关注功能点的暴露和调用方式。

### 结语

RESTful API是当前Web服务设计的主流范式，具备简洁性、可扩展性和灵活性。通过合理设计RESTful API，可以构建出高效、易维护、良好扩展性和高可用性的网络服务。理解REST的核心原则和最佳实践是构建优秀RESTful API的基础。

## https的加密过程（SSL、TLS）

HTTPS (HTTP Secure) 的加密过程主要依赖于 SSL (Secure Sockets Layer) 或其继任者 TLS (Transport Layer Security) 协议。这个过程包括几个关键步骤，主要目的是确保客户端和服务器之间的通信是安全的、加密的、且不被篡改的。以下是 HTTPS 的加密过程的详细说明：

1. 客户端发起请求

当用户在浏览器中输入 HTTPS 网址时，客户端（浏览器）会向服务器发送一个 ClientHello 消息，包含：
- 支持的 SSL/TLS 协议版本
- 支持的加密算法列表
- 一个随机数（Client Random）

2. 服务器响应

服务器收到请求后，会返回 ServerHello 消息，包含：
- 选择的 SSL/TLS 协议版本
- 选择的加密算法
- 服务器的数字证书（包含公钥）
- 另一个随机数（Server Random）

3. 证书验证

客户端收到服务器的响应后，会验证服务器的数字证书：
- 检查证书是否由受信任的证书颁发机构（CA）签发
- 验证证书的有效期
- 检查证书的域名是否匹配

4. 密钥交换

如果证书验证通过，客户端会生成一个预主密钥（Pre-master Secret），并使用服务器的公钥加密这个预主密钥，然后发送给服务器。

5. 会话密钥生成

客户端和服务器都使用预主密钥、Client Random 和 Server Random 来独立计算出相同的会话密钥。这个会话密钥将用于后续的对称加密通信。

6. 完成握手

客户端和服务器互相发送 "Finished" 消息，确认握手过程完成，并验证双方计算出的会话密钥是否一致。

7. 安全通信

握手完成后，客户端和服务器使用协商好的对称加密算法和会话密钥进行后续的通信加密。

关键点：

- 非对称加密（如 RSA）用于安全地交换对称加密的密钥。
- 对称加密（如 AES）用于实际的数据传输，因为它比非对称加密更快。
- 数字证书用于验证服务器的身份，防止中间人攻击。
- 会话密钥是临时的，每次会话都会重新生成，增加安全性。

这个过程确保了 HTTPS 通信的机密性（数据被加密）、完整性（数据不被篡改）和认证（确认通信对象的身份）。

##  OPTIONS 请求

HTTP OPTIONS 请求是一种 HTTP 方法，用于获取目标资源所支持的通信选项的信息。它主要用于以下几个方面：

1. 跨域资源共享（CORS）预检请求：
   - 在进行复杂跨域请求之前，浏览器会先发送一个 OPTIONS 请求，以确定实际请求是否安全。
   - 服务器通过响应头指示允许的方法、头部和源。
2. 服务器功能探测：
   - 客户端可以使用 OPTIONS 请求来确定服务器支持哪些 HTTP 方法。
3. 缓存验证：
   - 可用于检查缓存的响应是否仍然有效。

主要特点：

1. 安全性：OPTIONS 是一个安全的方法，不应改变服务器状态。
2. 幂等性：多次相同的 OPTIONS 请求应该产生相同的结果。
3. 响应头：
   - Allow：列出支持的 HTTP 方法
   - Access-Control-Allow-Methods：CORS 中允许的方法
   - Access-Control-Allow-Headers：CORS 中允许的请求头
   - Access-Control-Allow-Origin：允许的源
4. 无响应体：通常 OPTIONS 请求不需要响应体，所有信息都在头部。

示例 OPTIONS 请求：

```
OPTIONS /resource/foo HTTP/1.1
Host: example.org
Access-Control-Request-Method: POST
Access-Control-Request-Headers: origin, x-requested-with
Origin: https://foo.example
```

示例响应：

```
HTTP/1.1 204 No Content
Allow: GET, POST, HEAD, OPTIONS
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: origin, x-requested-with
Access-Control-Max-Age: 86400
```

使用场景：

1. 浏览器自动发起，用于 CORS 预检。
2. API 开发中，用于检查端点支持的操作。
3. 安全扫描，探测服务器配置。

注意事项：

- 正确配置 OPTIONS 响应对于 CORS 至关重要。
- 不应在 OPTIONS 中暴露敏感信息。
- 某些防火墙可能会阻止 OPTIONS 请求，需要适当配置。

了解 OPTIONS 请求有助于处理跨域问题和设计 RESTful API。

## RESTful API

RESTful API（Representational State Transfer API）是一种基于 HTTP 协议设计的软件架构风格，用于创建可扩展的 Web 服务。它由 Roy Fielding 在 2000 年的博士论文中提出。RESTful API 遵循一系列约束和原则，旨在简化和标准化 Web 服务的设计和实现。

RESTful API 的主要特征和原则：

1. 资源导向（Resource-Oriented）：
   - 所有内容都被视为资源
   - 每个资源都有唯一的标识符（URI）
   - 示例：/users, /products/123

2. 使用 HTTP 方法：
   - GET：读取资源
   - POST：创建新资源
   - PUT：更新整个资源
   - PATCH：部分更新资源
   - DELETE：删除资源

3. 无状态（Stateless）：
   - 每个请求包含所有必要的信息
   - 服务器不保存客户端状态

4. 客户端-服务器分离：
   - 提高可移植性和可扩展性

5. 统一接口：
   - 简化和解耦架构

6. 分层系统：
   - 允许架构由多个层组成

7. 可缓存性：
   - 响应应明确标记是否可以缓存

8. 表现层（Representations）：
   - 资源可以有多种表现形式（如 JSON, XML）
   - 使用 Accept 和 Content-Type 头部协商

RESTful API 设计最佳实践：

1. 使用名词而非动词作为 URI：
   好：/users
   差：/getUsers

2. 使用复数形式：
   /users 而不是 /user

3. 使用 HTTP 状态码：
   200 OK, 201 Created, 400 Bad Request, 404 Not Found 等

4. 版本控制：
   /api/v1/users

5. 分页和过滤：
   /users?page=2&limit=20

6. HATEOAS（Hypertext As The Engine Of Application State）：
   在响应中包含相关资源的链接

7. 使用嵌套资源表示关系：
   /users/123/orders

8. 一致性命名约定

示例 RESTful API 端点：

1. GET /users - 获取所有用户
2. GET /users/123 - 获取特定用户
3. POST /users - 创建新用户
4. PUT /users/123 - 更新用户
5. DELETE /users/123 - 删除用户
6. GET /users/123/orders - 获取用户的订单
7. POST /users/123/orders - 为用户创建新订单

RESTful API 的优势：

1. 简单性和可读性
2. 可扩展性
3. 高性能（通过缓存）
4. 可靠性
5. 适合无状态的移动应用开发

注意事项：

1. 安全性：需要实现适当的身份验证和授权
2. 速率限制：防止 API 滥用
3. 文档：提供清晰的 API 文档
4. 错误处理：提供有意义的错误信息

## 浏览器的最大请求数量是多少，为什么这么设计？

不同浏览器对同一个域名（origin）施加的最大并发请求数量各不相同，这个限制通常被称为“并发连接限制”或“并行连接限制”。这些限制存在的原因是为了均衡网络资源，避免服务器过载，并优化整体网络性能和用户体验。

### 常见浏览器的最大并发请求数量

一个大致的参考数据是这样的（具体版本可能会有所不同）：

- **Google Chrome**: 6 个并发请求
- **Mozilla Firefox**: 6 个并发请求
- **Microsoft Edge**: 6 个并发请求 (基于 Chromium)
- **Safari**: 6 个并发请求
- **Internet Explorer 11**: 6 个并发请求

### 设计这种限制的原因

1. **网络资源优化**：
    - **减少带宽争用**：如果允许任意数量的并发连接，一个页面可能会占用不公平的网络带宽，从而导致网络拥塞，影响其他用户的体验。
    
2. **减轻服务器负载**：
    - **防止服务器过载**：过多的并发连接可能会导致服务器资源枯竭，影响其稳定性。在这种情况下，限制每个客户端的并发连接数有助于维持服务器的正常运行。
    
3. **用户体验**：
    - **页面加载优化**：有限制的并发连接数量有助于更好地管理资源，可以避免因为过多的连接而导致的页面加载帧的阻塞，从而提高用户体验。
    
4. **防止滥用**：
    - **防止 DoS 攻击**：限制并发连接数量可以在一定程度上防止某些类型的拒绝服务（DoS）攻击，有效管理服务器的负载。

### 设计实践

浏览器的并发请求限制并不是一个绝对数值，在实际设计中，可能会根据不同环境和需求进行调整，但通常都有类似的目的和理由：

- **保持公平性**：确保所有用户都能公平地使用网络资源，而不会因为某些请求特别多的用户影响其他人的体验。
- **优化性能**： 在大多数情况下，6 个并发连接数量在现代网络环境下能够提供良好的用户体验。它有助于浏览器在能够并行加载资源的同时，不至于导致过度的资源竞争。
- **兼容性**：浏览器开发者在设定这些限制的时候，也会考虑与现有网络基础设施的兼容性，包括服务器、CDN 以及常见的网络拓扑结构[error]

## 浏览器的缓存？etag的优缺点

浏览器缓存是指浏览器保存一些特定资源（如 HTML、CSS、JavaScript、图像等）的副本，以便在后续请求相同资源时能更快地加载，提高页面加载的效率和用户体验。

### 浏览器缓存类型

1. **强制缓存 (Force Cache)**：
   - **Expires**：HTTP 响应头中的 `Expires` 字段指定了一个确切的日期和时间，在此之前，资源被认为是新鲜的，可以直接从缓存中加载，而不需要向服务器发送请求。
   - **Cache-Control**：相比 `Expires` 更为现代和灵活，如 `max-age` 指定在多少秒内资源被认为是新鲜的，`public` 和 `private` 表示缓存的范围等。

2. **协商缓存 (Conditional Cache)**：
   - **ETag**：实体标签，服务器为每个资源生成的唯一标识，通常是资源内容的哈希值。浏览器在执行缓存验证时，会将上一次返回的 `ETag` 值通过 `If-None-Match` 头发送到服务器，服务器比较这些值，如果资源没有改变，返回 304 状态码，告诉浏览器继续使用缓存。
   - **Last-Modified**：指示资源最后一次修改的时间。浏览器在执行缓存验证时，将上一次返回的 `Last-Modified` 值通过 `If-Modified-Since` 头发送到服务器，服务器比较这些值，如果资源没有修改，返回 304 状态码。

### ETag 的优缺点

#### 优点

1. **更精确**：
   - **精确的内容验证**：ETag 基于内容生成，能够在资源内容稍微变化时检测到变化，相比 `Last-Modified`，ETag 更为精确。
   - **部分内容更新支持**：当资源进行部分更新（如文件的某些部分改变），ETag 可以通过不同的标识来实现细粒度的缓存控制和验证。

2. **跨时间区和文件系统一致性**：
   - **跨时区问题**：不用担心服务器和客户端间的时区差异，ETag 采用内容哈希值，避免了时间不一致的问题。
   - **文件系统精度问题**：在某些系统上，时间戳的精度可能不够，而 ETag 可以提供字节级的变化检测。

#### 缺点

1. **生成开销**：
   - **服务器计算资源**：生成 ETag 需要计算资源，通常通过哈希算法生成，对于大型资源或高并发服务器，会有额外的计算开销。
   
2. **缓存一致性问题**：
   - **负载均衡问题**：在负载均衡环境下，如果多个服务器返回不同的 ETag 标识，则会影响缓存的一致性。通常需要确保所有服务器生成 ETag 的算法和策略一致。
   
3. **缓存头长度**：
   - **Header 头长度**：ETag 是一个哈希值，可能会增加 HTTP 请求和响应头部的长度，在某些网络条件下会有影响。

### 小结

- **ETag 的优点在于其精确而灵活的缓存控制，适用于需要精确缓存验证的场景。**
- **缺点主要在于服务器负载和复杂的缓存一致性管理。**

在实际应用中，可以综合使用 ETag 和其他缓存策略（如 `Last-Modified`、`Cache-Control`）来优化缓存性能和用户体验，权衡不同方案的优缺点，根据具体需求和环境选择合适的策略。

## axios原理

`axios` 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js。它提供了一系列用于发送 HTTP 请求和处理响应的函数，同时提供了便利的配置和高级功能。但了解它背后的工作原理可以帮助我们更好地使用它。

### axios 的核心组成

1. **主模块**：这是 `axios` 的主要入口模块，负责创建 `axios` 实例，对外暴露 API。
2. **请求适配器（Adapter）**：针对不同的环境（浏览器环境和 Node.js 环境），`axios` 提供了不同的请求适配器来实际发起请求。在浏览器中使用 `XMLHttpRequest` 或 `fetch` API，在 Node.js 中使用 `http` 模块。
3. **拦截器（Interceptors）**：提供请求和响应的拦截功能，允许在请求或响应被处理前做一些处理操作。
4. **请求/响应配置**：配置请求/响应的默认参数，如请求头、超时时间等。

### axios 的工作流程

1. **实例初始化**：用户调用 `axios.create` 或直接调用 `axios`，创建一个 `axios` 实例。
2. **配置处理**：合并用户指定的配置和默认配置。
3. **请求拦截器**：在请求被发送前会依次通过所有配置的请求拦截器，进行预处理（如添加 token、修改请求头等）。
4. **请求发送**：根据当前环境（浏览器或 Node.js），选择合适的适配器发送 HTTP 请求。
5. **响应拦截器**：请求响应回来后，通过所有配置的响应拦截器进行处理（如全局错误处理、响应格式化等）。
6. **返回结果**：最终返回处理后的响应结果给调用者。

### axios 的基本工作原理

```javascript
const axios = require('axios');

// 创建实例
const instance = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 1000,
  headers: { 'Authorization': 'Bearer token' }
});

// 添加请求拦截器
instance.interceptors.request.use(config => {
  // 在请求发送前做一些处理
  config.headers['X-Custom-Header'] = 'foobar';
  return config;
}, error => {
  // 处理请求错误
  return Promise.reject(error);
});

// 添加响应拦截器
instance.interceptors.response.use(response => {
  // 对响应数据做一些处理
  return response.data;
}, error => {
  // 处理响应错误
  return Promise.reject(error);
});

// 发送请求
instance.get('/user')
  .then(response => {
    console.log(response); // 处理响应数据
  })
  .catch(error => {
    console.error(error); // 处理响应错误
  });
```

### axios 的重要模块说明

#### 1. 适配器（Adapter）

适配器是 `axios` 用于不同环境下的请求发起机制。在浏览器里面，适配器一般使用 `XMLHttpRequest` 来发送请求；在 Node.js 环境中，适配器使用 Node.js 的 `http` 模块。

```javascript
// 伪代码示例
function xhrAdapter(config) {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open(config.method.toUpperCase(), config.url);
    request.timeout = config.timeout;
    request.onload = () => resolve(request.response);
    request.onerror = () => reject(new Error('Network Error'));
    request.ontimeout = () => reject(new Error('Timeout Error'));
    request.send(config.data);
  });
}
```

#### 2. 拦截器（Interceptors）

拦截器使得 `axios` 在发送请求和处理响应时有较高的灵活性，可以实现全局统一的处理和自定义操作。

```javascript
// 添加请求拦截器
axios.interceptors.request.use(config => {
  // 在请求发送前做一些处理
  return config;
}, error => {
  // 处理请求错误
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(response => {
  // 对响应数据做一些处理
  return response;
}, error => {
  // 处理响应错误
  return Promise.reject(error);
});
```

#### 3. 配置管理

`axios` 允许在全局和实例级别管理默认配置，每个请求也可以单独配置，最终是通过合并配置来实现灵活性。

```javascript
// 创建实例时配置默认参数
const axiosInstance = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 1000,
  headers: { 'Authorization': 'Bearer token' }
});

// 单个请求时也可以自定义参数
axiosInstance.get('/user', {
  params: { ID: 12345 }
})
.then(response => {
  console.log(response);
})
.catch(error => {
  console.error(error);
});
```

### 总结

`axios` 通过模块化的设计、灵活的配置和强大的拦截器机制，使得 HTTP 请求处理变得非常简洁和高效。它的核心在于通过不同环境适配器发起请求，使用拦截器进行请求和响应的预处理和后处理，以及灵活的配置管理来满足不同场景的需求。这样，即使在复杂的应用中，`axios` 仍然可以提供一致且简便的接口来处理 HTTP 请求。

## 有了IPV4为什么还要有IPV6

IP地址是用来标识网络上的设备的唯一标识符。互联网协议版本4（IPv4）和版本6（IPv6）是当前主要的两种网络协议。虽然IPv4在过去几十年里成功地支持了互联网的蓬勃发展，但随着时间的推移，它的局限性逐渐显现，IPv6应运而生。以下是对两者的深入分析及IPv6发展强调的原因：

### IPv4的局限性

1. **地址空间有限**：
   - IPv4使用32位地址空间，总共可以提供约43亿（\(2^{32}\)）个唯一地址。对于互联网早期，这个数量似乎足够，但随着互联网设备（智能手机、物联网设备、计算机等）的爆炸性增长，公网IPv4地址资源变得稀缺。

2. **地址耗尽与分配复杂性**：
   - 在全球范围内，IPv4地址耗尽已成为长期存在的问题。网络地址翻译（NAT）出现，以缓解地址耗尽问题，通过允许多个设备共享单个IP地址起作用，但也增加了网络复杂性，并对点对点连接提出了挑战。

3. **网络性能与安全**：
   - 随着扩展和复杂的网络结构的加入，NAT在安全、路由和性能上都存在诸多挑战。此外，IPv4没有内置的端到端加密和更强的认证方案。

### IPv6的优势

1. **更大的地址空间**：
   - IPv6采用128位地址空间，这意味着可以提供约 \(3.4 \times 10^{38}\) 个地址（340多万亿个亿个地址），可以充分满足未来的互联网需求，包括物联网的快速发展。

2. **简化的地址配置**：
   - IPv6支持自动配置（Stateless Address Autoconfiguration），使得设备可以在不需要外部配置服务（如DHCP）的情况下自动获得IP地址，从而简化了网络配置和管理。

3. **内置安全**：
   - IPv6协议设计时就集成了IPsec（Internet Protocol Security），这为网络层提供了更高的安全保证，支持数据包的加密以及更安全的身份验证。

4. **更优的路由效率**：
   - IPv6采用简化的报头格式，以及更有效的分组转发与处理，提升了路由效率。对于较大规模的网络，IPv6可以更好地简化路由表，并提高路由精度。

5. **去掉NAT的需求**：
   - 由于IPv6拥有充足的地址空间，可以分配给每台设备唯一的公网地址，因此消除了NAT的需求，促进了端到端的直接通信，这对新兴的应用场景如P2P、VoIP有非常积极的影响。

6. **支持新的服务**：
   - IPv6通过扩展报头和更灵活的数据传输，为未来网络服务发展提供了可能性，例如基于IPv6多播的更丰富的多媒体应用。

### IPv6的挑战

虽然IPv6具有许多优越性，但其推广面临一些挑战：

1. **过渡成本**：
   - 如果企业或运营商已有完善的现有IPv4基础设施，转向IPv6需要投入额外的成本进行升级硬件、软件和培训。

2. **兼容性**：
   - IPv4与IPv6是不可互通讯的（本质上两个独立的网络层协议），因此在过渡期需要具有“两栖”性，可以同IPv4、IPv6同时工作以保证互操作性。

3. **普及缓慢**：
   - 尽管IPv6的部署和应用正在加速，但全球快速全面应用仍需时间。

### 总结

IPv6的出现与发展是对互联网繁荣发展的有效响应，提供了一个具备相对长远适用性的解决方案。伴随着全球数字化和互联网通信需求的不断扩大，IPv6在支持更广阔网络生态系统中的关键角色愈发显著。推动IPv6的发展不仅解决了IPv4的局限性，也为互联网的未来创新服务提供了更坚实的基础。

## http-only

HTTP-only 是一个设置在 Cookie 上的标记，它是一个安全特性，用于帮助防止跨站脚本攻击（XSS）。当一个 Cookie 被标记为 HTTP-only 时，它具有以下特性：

1. 限制访问：

   - JavaScript 无法通过 document.cookie 访问这个 Cookie。
   - 这个 Cookie 只能被服务器访问，不能被客户端脚本读取。

2. 安全性提升：

   - 即使网站存在 XSS 漏洞，攻击者也无法通过 JavaScript 窃取这个 Cookie。
   - 特别适合存储敏感信息，如身份验证令牌。

3. 设置方法：

   - 服务器在设置 Cookie 时，通过添加 HttpOnly 标志来创建 HTTP-only Cookie。

   例如，在 HTTP 响应头中：

   ```
   Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; HttpOnly
   ```

4. 兼容性：

   - 大多数现代浏览器都支持 HTTP-only Cookie。

5. 限制：

   - HTTP-only Cookie 不能通过客户端 JavaScript 设置，只能由服务器设置。

6. 用途：

   - 通常用于存储 session ID、认证令牌等敏感信息。
   - 不适用于需要在客户端 JavaScript 中访问的数据。

7. 注意事项：

   - 虽然增加了安全性，但不应该被视为唯一的安全措施。
   - 应该与其他安全实践（如 HTTPS、适当的 CORS 策略等）结合使用。

8. 验证：

   - 可以通过浏览器的开发者工具查看 Cookie 是否设置了 HTTP-only 标志。

示例（Node.js 中设置 HTTP-only Cookie）:

```javascript
res.cookie('session_id', '1234567890', {
    httpOnly: true,
    secure: true, // 仅在 HTTPS 连接中发送
    sameSite: 'strict' // 防止 CSRF 攻击
});
```

总之，HTTP-only Cookie 是一种重要的安全机制，特别是在处理用户认证和会话管理时。它通过限制客户端脚本对 Cookie 的访问，显著降低了某些类型的攻击风险，尤其是跨站脚本攻击（XSS）。
