====

## Http

超文本传输协议

用于在`Web浏览器和网站服务器`之间传输数据,以`明文发送,不提供数据加密`

传输的数据是完整的,有意义的数据,能被上层应用识别

- `支持客户/服务器模式`
- `简单快速`:客户向服务器发送请求时,只传送请求方法和路径.通信速度快
- `灵活`:允许传输任何类型的数据对象
- `无连接`:限制每次连接只处理一个请求,服务器处理完请求,并收到客户应答后,即断开连接.节省传输时间
- `无状态`:无法根据之前的状态进行本次请求处理

### 常见的HTTP请求方法

1. `GET`
   - 用途：请求指定的资源
   - 特点：
     - `参数通常附加在URL中`
     - 不应该用于修改服务器上的数据
     - 请求`可以被缓存`
     - `有URL长度限制`
2. `POST`
   - 用途：向指定资源提交数据进行处理
   - 特点：
     - `数据包含在请求体中`
     - `可用于提交表单数据或上传文件`
     - 不受URL长度的限制
     - `不易被缓存`
3. `PUT`
   - 用途：`上传指定的资源（整体替换）`
   - 特点：
     - 幂等性操作（多次执行结果相同）
     - 通常`用于更新资源`
4. `DELETE`
   - 用途：`删除指定的资源`
   - 特点：
     - 幂等性操作
     - `请求成功返回200（OK）或204（No Content）`
5. `HEAD`
   - 用途：`获取与GET请求响应相同的头部信息`
   - 特点：
     - `不返回响应正文`
     - `用于检查资源是否存在`，或`获取资源元信息`
6. `OPTIONS`
   - 用途：`获取目标资源支持的通信选项`
   - 特点：
     - 用于`CORS预检请求`
     - `获取服务器支持的HTTP方法`
7. `PATCH`
   - 用途：对`资源进行部分修改`
   - 特点：
     - `与PUT不同`，`PATCH用于部分更新`
8. `TRACE`
   - 用途：`回显服务器收到的请求，用于测试或诊断`
   - 特点：
     - 主要用于`调试`
     - 潜在的安全风险，通常在生产环境中禁用
9. `CONNECT`
   - 用途：`建立网络连接隧道`，通常`用于HTTPS协议`
   - 特点：
     - `用于代理服务器`

使用建议：

1. GET用于安全和幂等的操作，如查询数据。
2. POST用于可能修改服务器状态的操作。
3. PUT用于更新已存在的资源。
4. DELETE用于删除资源。
5. 选择合适的方法以符合RESTful API设计原则。

安全考虑：

1. 某些方法（如DELETE）可能需要额外的安全措施。
2. 服务器应正确实现和限制各种HTTP方法的使用。

## Https

为了解决Http不安全的特性

让`Http运行在安全点SSL/TLS`协议上,`HTTPS = HTTP + SSL/TLS`,通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

<img src="F:\360MoveData\Users\28018\Desktop\知识点图片\image-20240325125036955.png" alt="image-20240325125036955" style="zoom:33%;" />

- 首先客户端通过URL访问服务器建立SSL连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

## 区别

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

HTTP 报文是在应用程序之间发送的数据块，用于 HTTP 协议交互。它分为请求报文和响应报文两种类型。

## 说一下http报文都有哪些东西

### 请求报文（Request Message）

1. **请求行**：

   - 描述客户端想要如何操作服务端的资源。
   - 由三部分构成：
     - 请求`方法`：表示对资源期望进行何种操作，常用的如 GET、POST。
     - 请求`目标`：通常是一个 URL，表明要操作的资源。
     - `版本号`：表示报文使用的 HTTP 协议版本。

   示例：

   ```
   GET / HTTP/1.1
   ```

   

2. **请求头**：

   - 包含若干个属性，格式为“属性名: 属性值”，服务端据此获取客户端的信息。
   - 请求头可大致分为四种类型：
     - 通用首部字段
     - 请求首部字段
     - 响应首部字段
     - 实体首部字段

3. **请求体**：

   - 包含要传输的内容，可以是文本、图片、音频、视频等。

### 响应报文（Response Message）

1. **状态行**：

   - 包含`协议版本`、`状态码`和`状态描述`。
   - 三位数字状态码表示处理的结果，例如 200 表示成功，404 表示资源未找到。
   - 状态描述是状态码的补充，帮助人们理解原因。

   示例：

   ```
   HTTP/1.1 200 OK
   ```

   

2. **响应头部**：

   - 由键值对组成，每行一对，键和值用英文冒号 : 分隔。
   - 响应头允许服务器传递不能放在状态行的附加信息，描述服务器的信息和 Request-URI 进一步的信息。

3. **响应包体**：

   - 服务器返回给浏览器的响应信息，响应数据的格式根据服务器来决定，常见的有 text/html、application/json 等。

[总之，HTTP 报文的基本概念和格式包括请求行、请求头、请求体、状态行、响应头和响应包体。](https://zhuanlan.zhihu.com/p/450128753)[1](https://zhuanlan.zhihu.com/p/450128753)[2](https://zhuanlan.zhihu.com/p/389369982)[3](https://blog.poetries.top/http-protocol/notes/base/06-HTTP报文是什么样子的.html)

## UDP

**面向数据报的通信协议**

`UDP`报头包括4个字段,标题短，开销小

- 利用IP提供面向无连接的通信服务
- 传输中出现丢包,不重发
- 包的到达顺序出现乱序时,没有纠正功能
- 收到数据就发出,无法进行流量控制避免网络拥塞

## TCP

**面向字节流的通信协议**

`TCP`报文首部20个字节，额外开销大

- 实现了数据传输时的各种控制功能,可以进行丢包的重发控制,乱序的分包进行控制
- 面向有连接的协议,只有确认通信对端存在时才会发生数据,从而控制通信流量浪费
- 也能在IP这种无连接的网络上实现高可靠性的通信

## 区别

|          |               TCP                |              UDP               |
| -------- | :------------------------------: | :----------------------------: |
| 可靠性   |               可靠               |             不可靠             |
| 连接性   |             面向连接             |             无连接             |
| 报文     |            面向字节流            |            面向报文            |
| 效率     |            传输效率低            |           传输效率高           |
| 双共性   |              全双工              | 一对一、一对多、多对一、多对多 |
| 流量控制 |             滑动窗口             |               无               |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复 |               无               |
| 传输效率 |                慢                |               快               |

- 都位于传输层
- TCP适用于对效率要求低,对准确性要求高,有连接的场景
- UDP适用于对效率要求高,准确性要求低的场景

## OSI七层模型

`OSI`将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰

<img src="https://static.vue-js.com/eb1b2170-b61e-11eb-ab90-d9ae814b240d.png" alt="img" style="zoom: 67%;" />

#### **应用层:**

定义了应用进程之间的各种交互规则,通过不同的应用层协议为不同的网络应用提供服务

在应用层交互的单元称为报文



#### **表示层:**

作用是使通信的应用程序能够解释交换数据的含义，位于 第六层，向上为应用层提供服务，向下接收来自会话层的服务

服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异



#### 会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话

该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法



#### 传输层

传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题

传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层

其中，主要的传输层协议是`TCP`和`UDP`



#### 网络层

两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网

网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送

在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层

在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层



#### 数据链路层

数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 `IP`数据报组装成帧，在两个相邻节点间的链路上传送帧

每一帧的数据可以分成：报头`head`和数据`data`两部分:

- head 标明数据发送者、接受者、数据类型，如 MAC地址
- data 存储了计算机之间交互的数据

通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源



#### 物理层

作为`OSI` 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送

该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）

该层主要是和硬件有关，与软件关系不大

## 传输过程

- 应用层报文被传送到运输层
- 在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用
- 应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变
- 运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报
- 网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧
- 在物理层数据帧被封装成比特流，之后通过传输介质传送到对端
- 对端再一步步解开封装，获取到传送的数据

## TCP/IP协议是什么

`能够在多个不同网络间实现信息传输的协议簇`

TCP/IP协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇，

只是因为在`TCP/IP`协议中`TCP`协议和`IP`协议最具代表性，所以通称为TCP/IP协议

## DNS

#### 域名协议系统

进行域名和与之相对应的 IP 地址进行转换的服务器

`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

- IP 地址：一长串能够唯一地标记网络上的计算机的数字
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

#### 查询方式

- 递归查询
- 迭代查询

#### `DNS`的记录分成两种缓存方式

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件

#### 查询过程

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

## CDN

CDN (全称 Content Delivery Network)，即内容分发网络

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，`使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。``CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是`根据用户位置分配最近的资源`

这段内容在面试中涉及CDN的关键要点如下：

1. **CDN定义与功能**：
   - CDN全称为Content Delivery Network，是一种基于现有网络架构的智能虚拟网络。
   - CDN通过在全球各地部署边缘服务器，利用中心平台的负载均衡、内容分发、调度等功能，确保用户能够从最近的服务器获取内容，从而减少网络拥塞，提高访问速度和命中率。

2. **CDN工作原理**：
   - 在未使用CDN时，用户访问过程需经历域名解析、获取IP地址、请求数据等步骤。
   - 使用CDN后，DNS返回的是CNAME记录，指向CDN的全局负载均衡系统，而非IP地址。全局负载均衡系统根据用户IP地址定位其地理位置，综合考虑运营商网络、节点负载、健康状况、服务能力等因素，智能调度到最近且最适合的边缘节点供用户访问。

3. **负载均衡系统**：
   - 负载均衡系统是CDN的核心组件之一，负责根据多种因素智能选择最优边缘节点，并将该节点信息返回给用户，以便用户就近访问。

4. **缓存代理机制**：
   - CDN的缓存系统会策略性地缓存热门资源，命中率和回源率是评价CDN服务质量的重要指标。
   - 缓存系统可划分为一级缓存节点（直连源站，配置较高）和二级缓存节点（直连用户，配置较低），以优化资源获取效率，降低真正回源的需求。

5. **CDN目标与价值**：
   - `CDN` 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度
   
     `CDN` 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速
   
     通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源

## HTTP1.0/1.1/2.0 的区别

#### HTTP1.0

`HTTP`协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本

`HTTP 1.0` 浏览器与服务器`只保持短暂的连接`，`每次`请求都需要与服务器建立一个`TCP`连接

服务器完成请求处理后立即断开`TCP`连接，服务器不跟踪每个客户也不记录过去的请求

简单来讲，`每次与服务器交互，都需要新开一个连接`

建立长连接，需要设置一个非标准的Connection字段 `Connection: keep-alive`

#### HTTP1.1

在`HTTP1.1`中，默认支持长连接（`Connection: keep-alive`），即在一个TCP连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟

建立一次连接，多次请求均由这个连接完成

`HTTP 1.1`还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间

同时，`HTTP1.1`在`HTTP1.0`的基础上，增加更多的请求头和响应头来完善的功能，如下：

- `引入了更多的缓存控制策略`，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略
- 引入range，`允许值请求资源某个部分`
- 引入host，实现了在一台WEB服务器上可以在`同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点`

#### HTTP2.0

`HTTP2.0`在相比之前版本，性能上有很大的提升，添加了如下特性：

- 多路复用
- 二进制分帧
- 首部压缩
- 服务器推送

##### 多路复用

`HTTP/2` 复用`TCP`连接，在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”

##### 二进制分帧

帧是`HTTP2`通信中最小单位信息

`HTTP/2` 采用`二进制格式传输数据`，而非 `HTTP 1.x`的`文本格式`，解析起来更高效

将请求和响应数据分割为更小的帧，并且它们采用二进制编码

`HTTP2`中，`同域名`下所有`通信都在单个连接上完成`，该连接可以承载任意数量的双向数据流

每个数据流都`以消息的形式发送`，而消息又由一个或多个帧组成。`多个帧之间可以乱序发送`，根据帧首部的流标识`可以重新组装`，这也是多路复用同时发送数据的实现条件

##### 首部压缩首部压缩

`HTTP/2`在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新

例如： 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

##### 服务器推送

`HTTP2`引入服务器推送，允许服务端推送资源给客户端

服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源

免得客户端再次创建连接发送请求到服务器端获取

这种方式非常合适加载静态资源

#### 总结

HTTP1.0：

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 在同一个TCP连接里面，客户端可以同时发送多个请求
- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
- 新增了一些请求方法
- 新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式
- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
- 使用报头压缩，降低开销
- 服务器推送

## HTTP 常见的状态码有哪些，适用场景

`http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态`

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误

#### 1xx

`代表请求已被接受，需要继续处理`。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

常见的有：

- 100（客户端继续发送请求，这是临时响应）：这个临时响应是`用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝`。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101：`服务器根据客户端的请求切换协议`，主要用于websocket或http2升级

#### 2xx

代表`请求已成功被服务器接收、理解、并接受`

常见的有：

- 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
- 201（已创建）：请求成功并且服务器创建了新的资源
- 202（已创建）：服务器已经接收请求，但尚未处理
- 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
- 204（无内容）：服务器成功处理请求，但没有返回任何内容
- 205（重置内容）：服务器成功处理请求，但没有返回任何内容
- 206（部分内容）：服务器成功处理了部分请求

#### 3xx

`表示要完成请求，需要进一步操作`。 通常，这些状态代码用来`重定向`

常见的有：

- 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
- 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
- 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
- 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

#### 4xx

`代表了客户端看起来可能发生了错误，妨碍了服务器的处理`

常见的有：

- 400（错误请求）： 服务器不理解请求的语法
- 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403（禁止）： 服务器拒绝请求
- 404（未找到）： 服务器找不到请求的网页
- 405（方法禁用）： 禁用请求中指定的方法
- 406（不接受）： 无法使用请求的内容特性响应请求的网页
- 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
- 408（请求超时）： 服务器等候请求时发生超时

#### 5xx

表示服务器无法完成明显有效的请求。这类状态码`代表了服务器在处理请求的过程中有错误或者异常状态发生`

常见的有：

- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
- 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

#### 适用场景

下面给出一些状态码的适用场景：

- 100：客户端在`发送POST数据给服务器前，征询服务器情况`，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。`常用于POST大数据传输`
- 206：一般用来做`断点续传`，或者是`视频文件等大文件的加载`
- 301：永久重定向会缓存。`新域名替换旧域名`，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
- 302：临时重定向不会缓存，常用 于`未登陆的用户访问用户中心重定向到登录页面`
- 304：`协商缓存，告诉客户端有缓存，直接使用缓存中的数据`，返回页面的只有头部信息，是没有内容部分
- 400：`参数有误，请求无法被服务器识别`
- 403：`告诉客户端禁止访问该站点或者资源`，如在外网环境下，然后访问只有内网IP才能访问的时候则返回
- 404：`服务器找不到资源时，或者服务器拒绝请求又不想说明理由时`
- 503：`服务器停机维护时`，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
- 504：`网关超时`

## GET 和 POST 的区别

#### GET

`GET`方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据

#### get请求会被浏览器缓存吗

[**GET 请求有可能被浏览器缓存**。当服务器返回的响应头包含 “Cache-Control” 或 “Expires” 字段时，浏览器会缓存该请求的响应内容。在下一次请求同样的 URL 时，浏览器会先检查缓存中是否有该请求的响应内容，如果有则直接使用缓存中的内容，不再向服务器发送请求](https://juejin.cn/s/get请求会被浏览器缓存)[1](https://juejin.cn/s/get请求会被浏览器缓存)。

为了防止浏览器缓存，可以采取以下方法之一：

- **添加 HTTP 头**：告诉浏览器不要缓存数据。
- [**添加校验参数**：每次请求时添加一个后端会忽略的参数，例如时间戳。这样浏览器会认为每次都是不同的请求，不会从历史记录中读取数据](https://segmentfault.com/q/1010000021784624)[2](https://segmentfault.com/q/1010000021784624)[3](https://bing.com/search?q=get请求会被浏览器缓存吗)。

#### [#](https://vue3js.cn/interview/http/GET_POST.html#post)POST

`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**



本质上都是`TCP`链接，并无差别

但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别

#### 区别

- `GET在浏览器回退时是无害的`，而``POST会再次提交请求``。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- `GET请求会被浏览器主动cache`，而`POST不会`，除非手动设置。
- `GET请求只能进行url编码`，而`POST支持多种编码方式`。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- `GET请求在URL中传送的参数是有长度限制的`，而`POST没有`。
- 对参数的数据类型，`GET只接受ASCII字符`，而`POST没有限制`。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- `GET参数通过URL传递`，`POST放在Request body中`
- 携带参数的时候，GET`请求是放在`url`中，`POST`则放在`body`中

#### 安全

`POST`比`GET` 安全，因为数据在地址栏上不可见

然而，从传输的角度来说，他们都是不安全的，因为`HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文

只有使用`HTTPS`才能加密安全

#### 数据包

对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应200（返回数据）

对于`POST`，浏览器先发送`header`，服务器响应100 `continue`，浏览器再发送`data`，服务器响应200 ok

并不是所有浏览器都会在`POST`中发送两次包，`Firefox`就只发送一次

## HTTP 常见的请求头有哪些? 作用？

HTTP请求和响应消息中的消息头部分

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 Host: en.wikipedia.org             |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

####  协商缓存

协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

#### 会话状态

`cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `Cookie`有效期、安全性、使用范围的可选属性组成

`Cookie` 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等

## 地址栏输入 URL 敲下回车后发生了什么

- URL解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

#### 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析：

- 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等
- 查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式

关于页面的渲染过程如下：

- 解析HTML，构建 DOM 树
- 解析 CSS ，生成 CSS 规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
- 绘制 render 树（ paint ），绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上

## TCP为什么需要三次握手和四次挥手

#### 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包

主要作用就是`为了确认双方的接收能力和发送能力是否正常`、`指定自己的初始化序列号为后面的可靠性传送做准备`

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

#### 上述每一次握手的作用如下：

- 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了

#### 为什么不是两次握手?

如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到

并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源

#### `tcp`终止一个连接，需要经过四次挥手

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态

#### 四次挥手原因

服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手

TCP 需要四次挥手来关闭连接，主要有以下原因：

1. 全双工通信：TCP 是全双工通信协议，意味着通信双方都可以同时进行数据的发送和接收。在关闭连接时，需要双方都确认自己不再发送数据并且对方也没有数据要发送给自己，因此需要双向的确认和关闭操作。
2. 保证数据传输的完整性：四次挥手的过程可以确保双方都正确地处理完数据。当一方发送 FIN 表示自己没有数据要发送时，另一方可能还有数据正在传输中，所以不能立即关闭连接，需要等待数据传输完毕后再发送 FIN 进行关闭。
3. 防止数据丢失和重复：通过四次挥手的交互过程，双方可以确认对方的关闭请求和确认，避免在关闭连接过程中出现数据丢失或重复的情况，保证连接的可靠关闭。

综上所述，四次挥手是为了保证 TCP 连接能够安全、可靠地关闭，确保双方都能正确处理数据传输和连接释放的过程。

## 说说对WebSocket的理解？应用场景？

WebSocket，是一种`网络传输协议`，位于`OSI`模型的`应用层`。可在`单个TCP`连接上进行`全双工通信`，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器`只需要完成一次握手`，两者之间就可以创建`持久性的连接`，并进行`双向数据传输`



`websocket`出现之前，开发实时`web`应用的方式为`轮询`

不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果`轮询的频率比较高，那么就可以近似地实现“实时通信”的效果`

轮询的`缺点`也很明显，反复发送无效查询请求`耗费了大量的带宽`和 `CPU`资源



#### 全双工

通信`允许数据在两个方向上同时传输`，它在能力上相当于两个单工通信方式的结合

例如指 A→B 的同时 B→A ，是瞬时同步的

#### 二进制帧

采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比`http/2`，`WebSocket`更侧重于“实时通信”，而`HTTP/2` 更侧重于提高传输效率，所以两者的帧结构也有很大的区别

#### 协议名

引入`ws`和`wss`分别代表明文和密文的`websocket`协议，且默认端口使用80或443，几乎与`http`一致

#### 握手

`WebSocket`也要有一个握手过程，然后才能正式收发数据

#### 优点

- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

#### 应用场景

基于`websocket`的事实通信的特点，其存在的应用场景大概有：

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新

## url有长度限制吗

URL 的长度在不同浏览器和协议中有一定的限制。让我们来详细了解一下：

1. **HTTP/1.1 规范**：
   - 最初的 HTTP/1.1 规范（RFC 2616）并没有对 URI（Uniform Resource Identifier，即 URL）的长度设定明确的上限。
   - [服务器应该能够处理任何资源的 URI，如果服务器无法处理过长的 URI，应该返回状态码 414（Request-URI Too Long）](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)[1](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)。
2. **实际使用情况**：
   - 实际上，不同浏览器和服务器软件对请求行长度都有一些限制。
   - 通常，如果你将 URL 保持在 **2000 个字符以内**，它们将在几乎所有组合的客户端和服务器软件以及搜索引擎中正常工作。
   - 对于特定用例，可以考虑使用更长的 URL。
3. **推荐长度**：
   - 根据最新的规范（RFC 9110），建议所有发送方和接收方至少支持 **8000 个八位字节** 长度的 URI。
   - [这意味着如果你的 URL 在 8000 个字符以内，它应该在大多数情况下都能正常工作](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)[1](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)。

[总之，如果你的 URL 在 **2000 个字符以内**，它将在几乎所有组合的客户端和服务器软件中正常工作。但是，如果你有特定的用例，可以考虑使用更长的 URL。](https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers)



## Http协议的Content-Type

在HTTP协议中，“Content-Type”是一个头部字段（header field），用于`指示资源的媒体类型`（也称为`MIME`类型）。这个头部字段告诉客户端实际返回的内容的格式是什么，以此来确保正确的解析和处理数据。

例如：

1. 如果服务器返回的是普通文本，头部可能会标注为：

   ```javascript
   Content-Type: text/plain
   ```

2. 如果返回的是HTML文档，则头部可能是：

   ```
   Content-Type: text/html
   ```

3. 对于JSON格式的数据，头部则会标注为：

   ```
   Content-Type: application/json
   ```

4. 对于图片和视频，Content-Type也有不同的值，例如：

   - 图片PNG格式：`Content-Type: image/png`
   - 视频MP4格式：`Content-Type: video/mp4`

在编写HTTP服务器响应客户端请求时，正确设置“Content-Type”头部非常重要，以确保客户端软件（如浏览器）能正确解析和显示内容。

## SSE

服务器发送事件(Server-Sent Events, SSE)是一种网络通信技术，允许服务器向客户端推送实时数据。以下是对SSE的详细介绍：

1. 基本概念：

   - SSE是HTML5规范的一部分。
   - 它提供了一种单向通信机制，从服务器到客户端。
   - 基于HTTP协议，使用标准的GET请求。

2. 工作原理：

   - 客户端发起一个HTTP连接到服务器。
   - 服务器保持这个连接开放，并通过它发送事件。
   - 连接长期保持开放状态，直到客户端关闭或服务器终止。

3. 数据格式：

   - 服务器发送的数据格式为"text/event-stream"。

   - 每条消息以一个或多个文本行组成，以换行符分隔。

   - 典型的消息格式：

     ```
     event: eventName
     data: Your message here
     id: messageId
     ```

4. 客户端API：

   - 使用EventSource对象创建连接：

     ```javascript
     const eventSource = new EventSource('/events');
     ```

   - 监听事件：

     ```javascript
     eventSource.onmessage = (event) => {
       console.log(event.data);
     };
     ```

5. 服务器实现：

   - 服务器需要设置正确的头部：

     ```
     Content-Type: text/event-stream
     Cache-Control: no-cache
     Connection: keep-alive
     ```

   - 然后发送格式化的事件数据。

6. 优点：

   - 简单易用，基于标准HTTP。
   - 自动重连机制。
   - 跨域支持（通过CORS）。
   - 服务器端实现简单。

7. 限制：

   - 单向通信（服务器到客户端）。
   - 不是所有浏览器都支持（但主流浏览器支持良好）。
   - 连接数限制（每个浏览器对同一域名的连接数有限制）。

8. 应用场景：

   - 实时新闻推送。
   - 股票价格更新。
   - 社交媒体实时通知。
   - 即时聊天应用的部分功能。

9. 与WebSocket比较：

   - SSE更轻量，实现更简单。
   - WebSocket支持双向通信，功能更强大。
   - SSE基于HTTP，更容易通过防火墙。

10. 安全性考虑：

    - 使用HTTPS加密传输。
    - 实施适当的认证和授权机制。

11. 性能优化：

    - 合理控制消息发送频率。
    - 在客户端实现错误处理和重连逻辑。

## 浏览器的同源策略

### 1.1同源策略概述


同源策略是`浏览器为确保资源安`全，而`遵循的一种策略`，该策略`对访问资源进行了一些限制`。
W3C 上对同源策略的说明：[Same origin policy](https://www.w3.org/Security/wiki/Same_Origin_Policy)。

### 1.2什么是源（origin）？


**1源的组成部分**



![image.png](https://img-blog.csdnimg.cn/img_convert/33a80a2d737e19650ae7757eccd938f6.png)


**下面表格中，只有最后一行的两个源是同源。**

| 源 1                         | 源 2                           | 是否同源 |
| ---------------------------- | ------------------------------ | -------- |
| http://www.xyz.com/home      | https://www.xyz.com/home       | ⛔非同源️  |
| http://www.xyz.com/home      | http://mail.xyz.com/home       | ⛔非同源  |
| http://www.xyz.com:8080/home | http://www.xyz.com:8090/home   | ⛔非同源  |
| http://www.xyz.com:8080/home | http://www.xyz.com:8080/search | ✅同 源︎   |



**同源请求**



![image.png](https://img-blog.csdnimg.cn/img_convert/2081b3b2d85c9d7a0ea9ff82e8663e92.png)


**4非同源请求**





![image.png](https://img-blog.csdnimg.cn/img_convert/9474242fbaf1ee01437a76fd89a4c2e6.png)


**5总结:『所处源』与『目标源』不一致，就是『非同源』，又称『异源』或『跨域』**

## 2跨域会受到哪些限制


例如有两个源：『源A』和『源B』，它们是『非同源』的，那么浏览器会有如下限制：

### 2.1限制DOM访问

『源A』的脚本不能访问『源B』的 DOM。

```cobol
<!-- <iframe id="framePage" src="./demo.html"></iframe> -->

<iframe id="framePage" src="https://www.baidu.com"></iframe>

<script type="text/javascript" >

  function showDOM(){

    const framePage = document.getElementById('framePage')

    console.log(framePage.contentWindow.document) //同源的可以获取，非同源的无法获取
  }
</script>
```

### 2.2限制Cookie访问

『源A』不能访问『源B』的 cookie

```cobol
<iframe id="baidu" src="http://www.baidu.com" width="500" height="300"></iframe>

<script type="text/javascript" >
  // 访问的是当前源的cookie，并不是baidu的cookie
  console.log(document.cookie)
</script>
```

### 2.3限制Ajax获取数据

『源A』可以给『源B』发请求，但是无法获取『源B』响应的数据。

```typescript
const url = 'https://www.toutiao.com/hot-event/hot-board/?origin=toutiao_pc'
let result = await fetch(url)
let data = await result.json();
console.log(data)
```

>  备注：在上述限制中，浏览器对 Ajax 获取数据的限制是影响最大的一个，且实际开发中经常遇到。

## 3几个注意点 

1. `跨域限制仅存在浏览器端`，`服务端不存在`跨域限制。
2. `即使跨域`了，`Ajax 请求也可以正常发出`，但`响应数据不会交给开发者`。
3. <link>、<script>、<img>...... 这些标签发出的请求也可能跨域，只不过浏览器对标签跨域不做严格限制，对开发几乎无影响



![image.png](https://img-blog.csdnimg.cn/img_convert/6ef6a9a11e46dc02ba24e4e6fc18162e.png)

## CORS 解决 Ajax 跨域问题

### 4.1CORS 概述

`CORS` 全称：`Cross-Origin Resource Sharing`（`跨域资源共享`），是用于控制浏览器校验跨域请求的一套规范，服务器依照 CORS 规范，`添加特定响应头来控制浏览器校验`，大致规则如下：

1. 服务器明确表示拒绝跨域请求，或没有表示，则浏览器校验不通过。
2. 服务器明确表示允许跨域请求，则浏览器校验通过。
3. 备注说明：使用 CORS 解决跨域是最正统的方式，且要求服务器是“自己人”。

###  4.2CORS 解决简单请求跨域

整体思路：服务器在给出响应时，通过`添加Access-Control-Allow-Origin响应头`，来`明确表达允许某个源发起跨域请求`，随后浏览器在校验时，直接通过。



![image.png](https://img-blog.csdnimg.cn/img_convert/7fc3d4076e0424a705f91a39b41533fe.png)

服务端核心代码（以express框架为例）：

```cobol
// 处理跨域中间件
function corsMiddleWare(req,res,next){
  // 允许 http://127.0.0.1:5500 这个源发起跨域请求
  // res.setHeader('Access-Control-Allow-Origin','http://127.0.0.1:5500')
  // 允许所有源发起跨域请求
  res.setHeader('Access-Control-Allow-Origin','*')
  next()
}
// 配置路由并使用中间件
app.get('/',corsMiddleWare,(req,res)=>{
  res.send('hello!')
})
```

## 简单请求与复杂请求

CORS 会把请求分为两类，分别是：① `简单请求`、② `复杂请求`。

| 简单请求                                                     | 复杂请求                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ✅请求方法（method）为：`GET`、`HEAD`、`POST`                 | 1不是简单请求，就是复杂请求。 2复杂请求会`自动发送预检请求`。 |
| ✅请求头字段要符合[《CORS 安全规范》](https://fetch.spec.whatwg.org/#cors-safelisted-request-header) 简记：只要不手动修改请求头，一般都能符合该规范。 |                                                              |
| ✅请求头的Content-Type的值只能是以下三种： ●text/plain ●multipart/form-data ●application/x-www-form-urlencoded |                                                              |

### 

**关于预检请求：**

- 发送`时机`：`预检请求在实际跨域请求之前发出`，是由`浏览器自动发起`的。
- 主要`作用`：用于`向服务器确认是否允许接下来的跨域请求`。
- 基本`流程`：先`发起OPTIONS请求`，如果`通过预检`，`继续发起实际的跨域请求`。
- 请求`头内容`：一个`OPTIONS预检请求`，通常会包含如下请求头：

| 请求头                           | 含义                                     |
| -------------------------------- | ---------------------------------------- |
| `Origin`                         | `发起请求的源`                           |
| `Access-Control-Request-Method`  | 实际请求的` HTTP 方法`                   |
| `Access-Control-Request-Headers` | 实际请求中使用的`自定义头`（如果有的话） |

### 4.4CORS 解决复杂请求跨域

1第一步：服务器先通过浏览器的预检请求，服务器需要返回如下响应头：

| 响应头                       | 含义                           |
| ---------------------------- | ------------------------------ |
| Access-Control-Allow-Origin  | 允许的源                       |
| Access-Control-Allow-Methods | 允许的方法                     |
| Access-Control-Allow-Headers | 允许的自定义头                 |
| Access-Control-Max-Age       | 预检请求的结果缓存时间（可选） |





![image.png](https://img-blog.csdnimg.cn/img_convert/b518d361e5d112a0b6cf9f118df52c6e.png)

2第二步：处理实际的跨域请求（与处理简单请求跨域的方式相同）

![image.png](https://img-blog.csdnimg.cn/img_convert/7fc3d4076e0424a705f91a39b41533fe.png)

服务端核心代码：

```javascript
// 处理预检请求
app.options('/students', (req, res) => {
  // 设置允许的跨域请求源
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  // 设置允许的请求方法
  res.setHeader('Access-Control-Allow-Methods', 'GET')
  // 设置允许的请求头
  res.setHeader('Access-Control-Allow-Headers', 'school')
  // 设置预检请求的缓存时间（可选）
  res.setHeader('Access-Control-Max-Age', 7200)
  // 发送响应
  res.send()
})

// 处理实际请求
app.get('/students', (req, res) => {
  // 设置允许的跨域请求源
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  // 随便设置一个自定义响应头
  res.setHeader('abc',123)
  // 设置允许暴露给客户端的响应头
  res.setHeader('Access-Control-Expose-Headers', 'abc')
  // 打印请求日志
  console.log('有人请求/students了')
  // 发送响应数据
  res.send(students)
})
```

### 4.5借助 cors 库快速完成配置

上述的配置中需要自己配置响应头，或者需要自己手动封装中间件，借助cors库，可以更方便完成配置



●安装cors

```less
npm i cors
```

●简单配置cors

```php
app.use(cors())
```

●完整配置cors

```cobol
// cors中间件配置
const corsOptions = {
  origin: 'http://127.0.0.1:5500', // 允许的源
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS'], // 允许的方法
  allowedHeaders: ['school'], // 允许的自定义头

  exposedHeaders: ['abc'], // 要暴露的响应头

  optionsSuccessStatus: 200 // 预检请求成功的状态码
};
app.use(cors(corsOptions)); // 使用cors中间件
```

> 默认`js是不能访问后端设置的响应头的`，`需要后端暴露`

## JSONP 解决跨域问题

1JSONP 概述： JSONP 是`利用了<script>标签可以跨域加载脚本`，且`不受严格限制的特性`，可以说是程序员智慧的结晶，早期一些浏览器不支持 CORS 的时，可以靠 JSONP 解决跨域。


2基本流程：

- 第一步：`客户端创建一个<script>标签`，并将其`src属性设置为包含跨域请求的 URL`，同时`准备一个回调函数`，这个回调函数`用于处理返回的数据`。
- 第二步：`服务端接收到请求后`，将`数据封装在回调函数中并返回`。
- 第三步：`客户端的回调函数被调用`，`数据以参数的形势传入回调函数`。

3图示：



![image.png](https://img-blog.csdnimg.cn/img_convert/a9b69cb4c148848bc9bd6aa7a0474312.png)

4代码示例：

```cobol
<button onclick="getTeachers()">获取数据</button>
<script type="text/javascript" >
  function callback(data){
    console.log(data)
  }

  function getTeachers(url){
    // 创建script元素
    const script = document.createElement('script')
    // 指定script的src属性
    script.src= 'http://127.0.0.1:8081/teachers'
    // 将script元素添加到body中触发脚本加载
    document.body.appendChild(script)
    // script标签加载完毕后移除该标签
    script.onload = ()=>{
      script.remove()
    }
  }
</script>
```

jQuery 封装的 jsonp

> ?callback=?' 为固定格式 会自动解析

```typescript
$.getJSON('http://127.0.0.1:8081/teachers?callback=?',(data)=>{
  console.log(data)
})
```

## 配置代理解决跨域

### 6.1自己配置代理服务器



> 服务器之间是没有跨域问题的，要使用express 启动静态资源保证自己的服务器跟页面在同源下

```php
// 启动静态资源 让服务器跟页面同一个源
app.use(express.static("./public"));
```

借助http-proxy-middleware配置代理

```php
const { createProxyMiddleware } = require('http-proxy-middleware');
app.use('/api',createProxyMiddleware({

  target:'https://www.toutiao.com',

  changeOrigin:true,

  pathRewrite:{

    '^/api':''

  }
```

 

优点：

- 功能丰富：http-proxy-middleware提供了丰富的配置选项，可以满足各种代理需求。
- 可以灵活配置多个代理：可以配置多个代理服务器，分别对应不同的接口路径。
- 可以拦截请求：可以通过自定义的处理函数对请求进行拦截和修改。

缺点：

- 配置相对复杂：需要了解http-proxy-middleware库的配置规则和参数。
- 不适用于生产环境：http-proxy-middleware主要用于开发环境，不适用于生产环境。

使用场景：

- 适用于使用任何构建工具的前端项目，可以与任何开发服务器配合使用。
- 适用于需要灵活配置多个代理服务器的场景。
- 适用于需要对请求进行拦截和修改的场景。

### 使用 Nginx 搭建代理服务器

整体思路：让nginx充当两个角色，既是 静态内容服务器，又是代理服务器。

修改nginx配置如下，注意nginx的根目录最好不是 C 盘

```cobol
# 配置nginx根目录
location / {
  root   D:\dist;
  index  index.html index.htm;
}
# 配置代理
location /dev/ {
  # 设置代理目标
  proxy_pass http://sph-h5-api.atguigu.cn/;
}
```

2修改前端项目，让所有请求都转发给 /dev，随后重新打包

```php
const request = axios.create({
  baseURL:'/dev',
  timeout:10000
})
```

随后直接访问nginx服务器即可，例如 nginx如果运行在8099端口，则访问

```cobol
http://localhost:8099
```

随后会遇到刷新404问题，追加nginx配置来解决

```cobol
# 配置nginx根目录
location / {
  root   D:\dist;
  index  index.html index.htm;
  try_files $uri $uri/ /index.html; # 解决刷新404
}
# 配置代理
location /dev/ {
  # 设置代理目标
  proxy_pass http://sph-h5-api.atguigu.cn/;
}
```

加上这两个“/”就剔除掉了dev

![img](https://i-blog.csdnimg.cn/direct/cfaa51e3932442a488eb2a44ac542ccd.png)

### 6.3借助脚手架搭建服务器 

1. 使用vue.config.js文件配置代理：

在Vue项目的根目录下创建一个vue.config.js文件，并添加以下代码：

```java
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}
```

上述代码中，我们使用`devServer`配置项来配置代理服务器。其中`proxy`属性用于配置代理的规则，`/api`表示需要代理的接口路径。`target`属性表示代理的目标服务器地址，`changeOrigin`属性表示是否改变请求的源地址，`pathRewrite`属性用于重写请求的路径。

优点：

- 配置简单：使用webpack-dev-server的代理配置，只需要在webpack配置文件中进行简单的配置即可。
- 功能全面：webpack-dev-server提供了丰富的配置选项，可以满足大部分代理需求。
- 可以拦截请求：可以通过自定义的处理函数对请求进行拦截和修改。

缺点：

- 需要重启服务器：配置修改后需要重新启动webpack-dev-server才能生效。
- 不适用于生产环境：webpack-dev-server主要用于开发环境，不适用于生产环境。

使用场景：

- 适用于使用webpack构建的前端项目，通过webpack-dev-server来启动开发服务器的场景。
- 适用于需要简单的代理配置，并且不需要频繁修改代理配置的场景。

## url的长度限制

1. `HTTP协议本身没有对URL长度做出明确限制`：

   - `HTTP/1.1规范(RFC 2616)并没有规定URL的最大长度`。

2. 然而，在实际应用中，`URL长度可能受到以下因素的限制`：

   a)` 服务器限制`：

   - 不同的Web服务器可能有自己的URL长度限制。
   - 例如，`Apache服务器默认限制URL长度为8192字符`。
   - `Microsoft Internet Information Server` (IIS)默认`限制URL长度为16384字符`。

   b) `浏览器限制：`

   - 不同的浏览器可能对URL长度有不同的处理能力。
   - 例如，Internet Explorer的最大URL长度是2083字符。

   c) `代理服务器和防火墙`：

   - 一些代理服务器或防火墙`可能对长URL有特殊处理或限制`。

   d) 客户端操作系统：

   - 某些操作系统可能对命令行长度有限制，这可能间接影响URL长度。

3. 最佳实践：

   - 尽管理论上URL可以很长，但出于实用性和兼容性考虑，通常建议将URL长度控制在2000字符以内。
   - 对于需要传递大量数据的情况，建议使用POST方法而不是GET。

4. GET方法的注意事项：

   - 虽然`GET方法的URL理论上没有严格限制`，但`过长的URL可能导致以下问题`：
     - `可读性差`
     - `容易出错`
     - 可能`超出服务器或浏览器的处理能力`
     - `安全风险（敏感信息暴露在URL中）`
