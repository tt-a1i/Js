# 利用闭包和自执行函数实现私有变量

在 JavaScript 中，**闭包**和**自执行函数（IIFE）**是两种非常强大的特性。不仅在函数式编程中广泛应用，而且在实现模块化、封装私有变量等方面也具有重要作用。本篇文章将详细介绍这两个概念，并通过一个实际例子，展示如何使用闭包和自执行函数来实现私有变量。

## 1. 什么是闭包？

###  1.1闭包的定义

闭包是 JavaScript 中一个重要的特性。它指的是当一个函数访问它外部函数作用域中的变量时，即使外部函数已经执行完毕，这些变量依然可以被访问。换句话说，闭包使得函数能够“记住”并访问它创建时所在的作用域中的变量。

### 1.2闭包的作用

- **持久化状态**：通过闭包，函数可以在多次调用之间“记住”变量的值。
- **封装私有数据**：闭包可以将一些数据（如变量）封装在函数内部，对外部隐藏，从而实现数据的私有性。
- **避免全局污染**：通过闭包，变量可以被限定在局部作用域内，避免污染全局命名空间。

### 1.3闭包示例

来看一个简单的闭包例子：

```javascript
function counter() {
    let count = 0; // 私有变量
    return function() {
        count++;
        return count;
    };
}

const increment = counter();
console.log(increment()); // 输出: 1
console.log(increment()); // 输出: 2
```

在这个例子中，`count` 是一个私有变量，由于闭包的特性，`increment` 函数可以访问并修改 `count` 的值，即使外部无法直接访问它。

## 2. 什么是自执行函数（IIFE）？

### 2.1 自执行函数的定义

自执行函数（IIFE，全称 Immediately Invoked Function Expression）是一种在定义后立即执行的函数表达式。它通常用于创建一个新的作用域，从而避免污染全局作用域。

### 2.2 自执行函数的特点

- 自执行函数通常是匿名函数。
- 它会在定义之后立即被调用执行。
- 常用来创建私有作用域，封装变量和函数。

### 2.3 自执行函数的示例

```javascript
(function() {
    let privateVar = 'I am private';
    console.log(privateVar);
})(); // 输出: I am private

// 这里无法访问 privateVar，因为它被封装在自执行函数内
```

`privateVar` 是自执行函数内的私有变量，它只能在函数内部访问，外部无法直接访问。

## 3. 结合闭包和自执行函数实现私有变量

### 3.1 闭包和自执行函数的结合

闭包和自执行函数结合使用时，可以在不暴露全局变量的情况下，封装和持久化函数的内部状态。自执行函数用于创建一个私有的作用域，而闭包则允许我们在该作用域内存储和访问数据。

### 3.2 实现私有变量的例子：质数生成器

通过一个实际的例子来展示如何利用闭包和自执行函数实现私有变量。这个例子也是我之前遇到的一道面试题，在这个例子中，创建一个 `getPrime` 方法，每次调用时返回下一个质数。

```javascript
const getPrime = (function() {
    let current = 2; // 私有变量，用于保存当前正在检查的数字

    // 内部函数，用于判断一个数是否是质数
    function isPrime(n) {
        if (n < 2) return false;
        for (let i = 2; i <= Math.sqrt(n); i++) {
            if (n % i === 0) return false;
        }
        return true;
    }

    // 返回一个匿名函数，这个匿名函数是闭包
    return function() {
        while (true) {
            if (isPrime(current)) {
                return current++; // 返回质数，并将当前数字自增
            }
            current++; // 如果不是质数，检查下一个数字
        }
    };
})();

// 示例使用
console.log(getPrime()); // 输出: 2
console.log(getPrime()); // 输出: 3
console.log(getPrime()); // 输出: 5
console.log(getPrime()); // 输出: 7
console.log(getPrime()); // 输出: 11
```

### 3.3 代码分析

1. **自执行函数**：
   - `getPrime` 是通过一个自执行函数实现的。这个自执行函数立即执行并返回一个匿名函数（闭包），该匿名函数就是我们用来获取质数的函数。
   - 自执行函数的作用是封装了 `current` 和 `isPrime` 这两个私有变量，这些变量对外部不可见。
2. **私有变量 `current`**：
   - `current` 是一个私有变量，用来追踪当前正在检查的数字。每次调用 `getPrime` 时，`current` 会自增，直到找到下一个质数。
   - 由于 `current` 是在自执行函数内部定义的，它只能通过闭包函数进行访问和修改，从而实现了私有性。
3. **闭包 `getPrime`**：
   - 返回的匿名函数是一个闭包，它能够访问并操作 `current` 和 `isPrime`。每次调用 `getPrime()` 时，它会返回下一个质数，同时更新 `current` 的值。

### 3.4 闭包和自执行函数的优势

- **封装性**：通过自执行函数，`current` 和 `isPrime` 都被封装在局部作用域内，外部无法直接访问或修改这些变量，从而实现了私有数据的保护。
- **持久性**：闭包让 `current` 变量在多次调用中得以持续更新，保持其状态不被丢失。
- **避免全局污染**：因为这些变量和函数都被封装在自执行函数内，所以不会污染全局作用域，减少了命名冲突的可能性。

