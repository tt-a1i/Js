### 题目描述

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

### 思路

如果数组是有序的，我们对排序后的数组从前往后进行遍历，对于当前遍历的值，分三种情况

- 如果当前值小于等于0，那么遍历数组后面的数，双指针记录数组后的一位数和数组末尾的数，计算他们的累加和
  - 如果累加和等于0，添加进结果
  - 如果小于0，更新左指针往后（升序排序后的数组越往后值越大）
  - 如果大于0，更新右指针向前（同理，越往前越小）
- 如果当前值大于0，那么一定不存在累加和为0的数

#### 优化

- 如果当前遍历的值与其前一个值相同，直接跳过
- 在更新左右指针的时候也可以对重复的数字去重

#### 注意点

<code>if(i > 0 && n === copyNums[i - 1]) continue</code>

对于数组`[-2，-2，0,4]`

如果我们的判断条件是<code>if(i < len - 1 && n === copyNums[i + 1]) continue</code>

那么我们在遍历的时候就会直接跳到第二个2，就遗漏了

### 复杂度分析

#### 时间复杂度

- **排序部分**：
  - nums.sort((a, b) => a - b) 的时间复杂度为 **O(N log N)**，其中 **N** 是数组 nums 的长度。
- **双指针遍历部分**：
  - 外层 `for` 循环遍历数组，时间复杂度为 **O(N)**。
  - 内层 `while` 循环使用双指针 l和 r，每次移动至少一个指针，总体来说每个元素最多被访问一次，因此内层循环的时间复杂度为 **O(N)**。
  - 综合外层和内层，双指针部分的时间复杂度为 **O(N²)**。
- **总时间复杂度**：
  - **O(N log N) + O(N²) = O(N²)**。

#### 空间复杂度

- **排序部分**：
  - JavaScript 的 sort 方法通常是原地排序，空间复杂度为 **O(1)**（取决于具体实现，某些情况下可能为 **O(N)**）。
- **结果存储**：
  - 数组 res 用于存储结果，最坏情况下可能包含 **O(N²)** 个三元组，因此空间复杂度为 **O(N²)**。
- **其他变量**：
  - 使用了常数个额外变量，如 n, l, r, sum等，空间复杂度为 **O(1)**。
- **总空间复杂度**：
  - **O(N²)**，主要由结果存储 res决定。

### code

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
    const res = [], len = nums.length
    const copyNums = nums.sort((a, b) => a - b)
    for (let i = 0; i < len - 1; i++) {
        n = copyNums[i]
        if (n > 0) break
        if(i > 0 && n === copyNums[i - 1]) continue
        let l = i + 1, r = len - 1
        while (l < r) {
            const sum = n + copyNums[l] + copyNums[r]
            if (sum === 0) {
                res.push([n, copyNums[l], copyNums[r]])
                while (l < len && copyNums[l] === copyNums[l + 1]) l++
                while(r > 0 && copyNums[r] === copyNums[r-1]) r--
                l++
                r--
            } else if (sum > 0){
                r--
            }else{
                l++
            }
        }
    }
    return res
};
```





