### Boyer-Moore 投票算法：寻找多数元素的利器

在计算机科学中，寻找数组中的多数元素（即出现次数超过一半的元素）是一个经典问题。Boyer-Moore 投票算法（Boyer-Moore Voting Algorithm）是一种高效且优雅的解决方案，能够在时间复杂度为 O(n) 和空间复杂度为 O(1) 的情况下找到多数元素。

#### 1. 问题背景

假设我们有一个长度为 n 的数组，我们需要找到其中出现次数超过一半的元素。例如，在数组 `[3, 3, 4, 2, 4, 4, 2, 4, 4]` 中，元素 `4` 出现了 5 次，超过了数组长度的一半（9/2 = 4.5），因此 `4` 是多数元素。

#### 2. Boyer-Moore 投票算法的基本思想

Boyer-Moore 投票算法的核心思想是通过“投票”和“抵消”的过程来找到多数元素。具体步骤如下：

1. **初始化**：选择数组中的第一个元素作为候选元素（candidate），并设置计数器（count）为 1。
2. **遍历数组**：
   - 如果当前元素与候选元素相同，则计数器加 1。
   - 如果当前元素与候选元素不同，则计数器减 1。
   - 如果计数器变为 0，则将当前元素设为新的候选元素，并将计数器重置为 1。

#### 3.代码示例

```javascript
function majorityElement(array) {
    let candidate = array[0]; // 初始候选人
    let count = 1; // 计数器
    for (let i = 1; i < array.length; i++) {
        if (array[i] === candidate) {
            count++; // 相同元素，计数器加一
        } else {
            count--; // 不同元素，计数器减一
            if (count === 0) {
                candidate = array[i]; // 更换候选人
                count = 1; // 重置计数器
            }
        }
    }
    return candidate; // 返回最终的候选人
}
```

**算法原理：**

1. **候选人初始化**：假设第一个元素是候选人，计数器设为 1。

2. 遍历数组

   ：

   - 如果遇到的元素和候选人相同，计数器加一。
   - 如果不同，计数器减一。

3. **更换候选人**：当计数器减到 0 时，换下一个元素作为候选人，计数器重置为 1。

4. **结果**：遍历完成后，当前的候选人就是出现次数超过一半的元素。

**为什么有效：**

- 出现次数超过一半的元素，累加次数一定会大于其他元素。
- 非主要元素会相互抵消，最终剩下的就是主要元素。

**举个例子：**

对于数组 `[5, 5, 5, 1, 2, 5, 5]`：

- 初始候选人是 `5`，计数器为 1。
- 第二个元素是 `5`，计数器加一，变为 2。
- 第三个元素是 `5`，计数器加一，变为 3。
- 第四个元素是 `1`（非候选人），计数器减一，变为 2。
- 第五个元素是 `2`（非候选人），计数器减一，变为 1。
- 第六个元素是 `5`，计数器加一，变为 2。
- 第七个元素是 `5`，计数器加一，变为 3。
- 遍历结束，候选人是 `5`，计数器为 3。

最终返回的候选人 `5` 就是出现次数超过一半的元素。

#### 4. 算法分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。算法需要遍历数组两次，因此总的时间复杂度为 O(2n)，即 O(n)。
- **空间复杂度**：O(1)。算法只需要常数级别的额外空间来存储候选元素和计数器。