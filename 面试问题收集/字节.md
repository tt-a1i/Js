## 左侧固定宽度100px,右侧宽度占满空间,可以通过什么方式实现

#### Flexbox 布局

```javascript
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  display: flex;
}
.left {
  width: 100px;
  flex-shrink: 0;
}
.right {
  flex-grow: 1;
}
```

#### Grid 布局

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  display: grid;
  grid-template-columns: 100px 1fr;
}
```

#### Float 布局

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  overflow: hidden;
}
.left {
  float: left;
  width: 100px;
}
.right {
  margin-left: 100px;
}
```

#### 绝对定位

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  position: relative;
}
.left {
  position: absolute;
  width: 100px;
}
.right {
  margin-left: 100px;
}
```

#### Table 布局

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  display: table;
  width: 100%;
}
.left, .right {
  display: table-cell;
}
.left {
  width: 100px;
}
```

## flex属性

1. flex-grow

- 定义：决定 flex 项目相对于容器中其他 flex 项目如何增长。
- 取值：非负数字，默认为 0。
- 作用：当容器有多余空间时，flex-grow 值越大的项目会获得更多的剩余空间。

例如：

```css
.item1 { flex-grow: 1; }
.item2 { flex-grow: 2; }
```

在这个例子中，如果有多余空间，item2 会比 item1 获得两倍的额外空间。

1. flex-shrink

- 定义：决定 flex 项目相对于容器中其他 flex 项目如何收缩。
- 取值：非负数字，默认为 1。
- 作用：当容器空间不足时，flex-shrink 值越大的项目会收缩得更多。

例如：

```css
.item1 { flex-shrink: 1; }
.item2 { flex-shrink: 2; }
```

在这个例子中，如果空间不足，item2 会比 item1 收缩得更多。

1. flex-basis

- 定义：指定 flex 项目在主轴方向上的初始大小。
- 取值：长度值（如 px、em）、百分比或 auto（默认）。
- 作用：设置 flex 项目的基准尺寸，然后再应用 flex-grow 或 flex-shrink。

例如：

```css
.item { flex-basis: 200px; }
```

这会给项目一个 200px 的初始宽度（如果主轴是水平方向）。

flex 简写：

flex 属性是这三个属性的简写，顺序为 flex-grow、flex-shrink、flex-basis。

例如：

```css
.item { flex: 1 1 auto; }
```

常用的简写值：

- `flex: 1;` 等同于 `flex: 1 1 0%;`，允许项目增长和收缩。
- `flex: auto;` 等同于 `flex: 1 1 auto;`，类似于上面，但考虑项目的内容尺寸。
- `flex: none;` 等同于 `flex: 0 0 auto;`，创建不可伸缩的项目。
- `flex: 0 auto;` 或 `flex: initial;` 等同于 `flex: 0 1 auto;`，是默认值。

## 怎么算选择器权重

选择器权重的计算方法：

1. 内联样式：1000 分
2. ID 选择器：100 分
3. 类选择器、属性选择器、伪类：10 分
4. 元素选择器、伪元素：1 分
5. 通配符(*)、组合器（如 >、+、~）：0 分

计算步骤：

1. 统计选择器中每种类型的数量
2. 按照上述分值计算总分
3. 比较不同选择器的总分

例子：

1. `#nav .list li a:hover`
   - 1 个 ID 选择器：100
   - 1 个类选择器：10
   - 2 个元素选择器：2
   - 1 个伪类：10 总分：100 + 10 + 2 + 10 = 122
2. `body #content .data img:hover`
   - 1 个 ID 选择器：100
   - 1 个类选择器：10
   - 2 个元素选择器：2
   - 1 个伪类：10 总分：100 + 10 + 2 + 10 = 122
3. `div p .class`
   - 1 个类选择器：10
   - 2 个元素选择器：2 总分：10 + 2 = 12

注意事项：

1. !important 声明会覆盖所有其他声明，应谨慎使用。
2. 如果权重相同，后面的规则会覆盖前面的规则。
3. 继承的样式没有权重。
4. 通用选择器（*）、组合器（+、>、~、空格）和否定伪类（:not()）对优先级没有影响。

## 怎么判断变量是否为数组

1. Array.isArray() 方法

这是最推荐的方法，因为它是专门用来检测数组的。

```javascript
Array.isArray([1, 2, 3]);  // 返回 true
Array.isArray({});         // 返回 false
```

1. instanceof 操作符

```javascript
let arr = [1, 2, 3];
arr instanceof Array;  // 返回 true
```

注意：这种方法在跨窗口或跨框架的情况下可能会失效。

1. Object.prototype.toString.call()

这是一种更通用的方法，可以检测多种类型。

```javascript
Object.prototype.toString.call([1, 2, 3]) === '[object Array]';  // 返回 true
```

1. 检查 constructor 属性

```javascript
let arr = [1, 2, 3];
arr.constructor === Array;  // 返回 true
```

1. 检查 length 属性和数字索引（不太可靠）

```javascript
function isArray(obj) {
    return obj && 
           typeof obj === 'object' && 
           typeof obj.length === 'number' && 
           !(obj.propertyIsEnumerable('length'));
}
```

这种方法不太可靠，因为类数组对象也可能通过这个测试。

1. ES6+ 的扩展运算符

```javascript
const isArray = obj => !!obj && obj.constructor === Array;
```

## 304

HTTP 304 状态码代表"Not Modified"（未修改），这是一个非常重要的优化相关的状态码。它主要用于缓存验证，其含义和用途如下：

1. 含义： 304 状态码表示`客户端 `发送了一个`条件性GET请求`，服务器判断`请求的资源未被修改`，可以直接使用客户端`已缓存的版本`。
2. 工作原理：
   - 客户端在请求头中包含条件验证信息（如 If-Modified-Since 或 If-None-Match）。
   - 服务器检查资源是否被修改。
   - 如果资源未被修改，服务器返回 304 状态码，不返回资源内容。
   - 客户端收到 304 响应后，使用本地缓存的版本。
3. 主要用途：
   - 减少网络传输：避免重复传输未修改的资源。
   - 提高加载速度：使用本地缓存比重新下载更快。
   - 节省带宽：减少不必要的数据传输。
4. 相关的请求头：
   - If-Modified-Since：基于时间的验证。
   - If-None-Match：基于 ETag 的验证。
5. 相关的响应头：
   - Last-Modified：资源的最后修改时间。
   - ETag：资源的唯一标识符。
6. 示例场景：
   - 浏览器首次请求一个页面。
   - 服务器返回页面内容，并包含 Last-Modified 或 ETag 头。
   - 浏览器缓存这个页面。
   - 下次请求同一页面时，浏览器发送包含 If-Modified-Since 或 If-None-Match 的请求。
   - 如果页面未修改，服务器返回 304 状态码。
   - 浏览器使用缓存的版本。
7. 优点：
   - 提高网站性能和响应速度。
   - 减少服务器负载。
   - 节省带宽和流量费用。
8. 注意事项：
   - 304 响应通常不包含响应体。
   - 即使返回 304，也可能更新缓存相关的头信息。
9. 实现：
   - 服务器端需要正确实现条件请求的处理逻辑。
   - 客户端（如浏览器）需要正确处理 304 响应。

总之，HTTP 304 状态码是一种重要的性能优化机制，通过有效利用客户端缓存来减少不必要的数据传输，从而提高 Web 应用的整体性能和用户体验。

## TCP和UDP的区别

TCP和UDP的主要区别：

1. 连接：
   - TCP: `面向连接`，需要`先建立连接`再`传输数据`
   - UDP: `无连接`，`直接发送`数据
2. 可靠性：
   - TCP: `可靠`传输，保证`数据完整性`和`顺序`
   - UDP:` 不保证可靠`传输，可能`丢包`、`乱序`
3. 传输速度：
   - TCP: 相对`较慢`，因为有`各种控制机制`
   - UDP: `较快`，没有额外的控制开销
4. 数据边界：
   - TCP: 面向`字节流`，不保留数据边界
   - UDP: 面向`报文`，保留数据边界
5. 流量控制：
   - TCP: 有流量控制机制
   - UDP: 无流量控制
6. 拥塞控制：
   - TCP: 有拥塞控制机制
   - UDP: 无拥塞控制
7. 错误检测：
   - TCP: 有错误检测和纠正机制
   - UDP: 仅有简单的错误检测，不进行纠正
8. 应用场景：
   - TCP: `适用于`要求`可靠传输`的应用，如网页浏览、`文件传输`、`电子邮件`等
   - UDP: 适用于`实时性`要求高、`允许少量丢包`的应用，如`视频流`、在线游戏、VoIP等
9. 首部开销：
   - TCP: `首部至少20字节`
   - UDP: 首部仅`8字节`，开销小
10. 数据传输方式：
    - TCP: `全双工`，`双向传输`
    - UDP: 支持`一对一`、`一对多`、`多对一`和`多对多`交互通信
11. 状态维护：
    - TCP: 需要在端系统中维护连接状态
    - UDP: 无状态

## 事件循环例题

```javascript
async function async1(){
    console.log('async1 start');
    await async2()
    console.log('async1 end');
}

async function async2(){
    console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1()

new Promise(function (resolve){
    console.log('promise1');
    resolve()
}).then(function(){
    console.log('promise2');
})

console.log('script end');
```

这段代码涉及到 JavaScript 的事件循环、宏任务、微任务以及 async/await 的执行机制。让我们逐步分析输出顺序：

首先执行同步代码：

打印 "script start"

遇到 setTimeout，将其回调函数放入宏任务队列

调用 async1 函数：

打印 "async1 start"

遇到 await async2()，执行 async2 函数

打印 "async2"

async2 函数结束，返回一个 Promise

await 使 async1 函数剩余部分被放入微任务队列

遇到 new Promise，执行其中的同步代码：

打印 "promise1"

调用 resolve()，将 then 中的回调放入微任务队列

执行最后一行同步代码：

打印 "script end"

同步代码执行完毕，开始执行微任务队列：

执行 async1 函数剩余部分，打印 "async1 end"

执行 Promise 的 then 回调，打印 "promise2"

微任务队列清空，执行宏任务队列：

执行 setTimeout 的回调，打印 "setTimeout"

因此，最终的输出顺序是：

script start

async1 start

async2

promise1

script end

async1 end

promise2

setTimeout

这个顺序反映了 JavaScript 的事件循环机制：先执行同步代码，然后执行微任务，最后执行宏任务。

async/await 本质上是 Promise 的语法糖，await 后面的代码相当于放在 Promise.then 中执行，因此也是作为微任务处理的。 

## Vue3的响应式是如何实现的

Vue3 的响应式系统是通过 `Proxy` 和` Reflect` 实现的，这是一个重大的改进，相比 Vue2 使用的 `Object.defineProperty `方法更加强大和灵活。以下是 Vue3 响应式系统的主要实现原理：

Proxy 代理：

Vue3 使用 `Proxy` 来`创建响应式对象`。Proxy 可以`拦截对象的基本操作`，如`属性读取`、`赋值`、`删除`等。

依赖追踪（track）：

当访问响应式对象的属性时，系统会追踪这个属性的依赖关系。

触发更新（trigger）：

当响应式对象的属性被修改时，系统会触发相关的依赖进行更新。

## 盒子模型

描述了 HTML `元素`在`文档布局中`所`占空间`的`计算方式`。每个 HTML 元素都可以被视为一个盒子，由以下部分组成：

1. `内容`区域（Content）：包含元素的实际内容，如文本、图像等。
2. `内边距`（Padding）：内容区域与边框之间的空间。
3. `边框`（Border）：围绕在内边距和内容区域外的边界。
4. `外边距`（Margin）：盒子与其他元素之间的空间。

盒子模型有两种主要类型：

1. `标准盒子模型`（Standard Box Model）：
   - 元素的宽度和高度只包括内容区域。
   - 总宽度 = `width `+ `padding `+ `border `+ `margin`
   - 总高度 = height + padding + border + margin
2. IE 盒子模型（IE Box Model）或`怪异盒子模型`：
   - 元素的宽度和高度包括内容、内边距和边框。
   - 总宽度 = `width `(包含 padding 和 border) + `margin`
   - 总高度 = height (包含 padding 和 border) + margin

在 CSS3 中，可以使用 `box-sizing` 属性来控制盒子模型的类型：

- box-sizing: ` content-box;` （默认值）使用`标准`盒子模型
- box-sizing: `border-box;` 使用` IE `盒子模型

## 浏览器的事件循环

浏览器的事件循环（Event Loop）是 JavaScript `运行时环境`中`处理异步操作`的`机制`。它确保了 JavaScript 的`单线程`执行模型能够高效地`处理异步任务`，而`不`会`阻塞主线程`。以下是事件循环的主要组成部分和工作原理：

1. 调用栈（Call Stack）：
   - 用于存储正在执行的函数调用。
   - 遵循后进先出（LIFO）的原则。
2. 堆（Heap）：
   - 用于存储对象，是内存分配发生的地方。
3. 任务队列（Task Queue）：
   - 也称为`宏任务队列`（Macrotask Queue）。
   - 存储待执行的任务（如 `setTimeout`、`setInterval `的回调、`DOM 事件`等）。
4. `微任务队列`（Microtask Queue）：
   - 存储优先级更高的任务（如 `Promise `的回调、`MutationObserver `等）。

事件循环的工作`流程`：

1. `执行调用栈`中的`同步代码`。
2. `调用栈为空`时，`检查微任务队列`：
   - 如果`微任务队列不为空`，`依次执行`所有`微任务`。
   - 执行`过程中`新`产生的微任务`也会被`添加到队列末尾`并`执行`。
3. `微任务队列清空后`，从任务队列中取出一个宏任务执行。
4. 重复步骤 2-3，直到both3. 微任务队列清空后，从任务队列中取出一个任务执行。
5. 重复步骤 2-3，直到所有队列都为空。

重要概念：

1. `宏任务`（Macrotasks）：
   - `setTimeout`, `setInterval`, `setImmediate`
   - `I/O 操作`
   - `UI 渲染`
   - `requestAnimationFrame`
2. `微任务`（Microtasks）：
   - `Promise`.then(), Promise.catch(), Promise.finally()
   - `MutationObserver`
   - queueMicrotask()
   - `process.nextTick` (Node.js)
3. 任务`优先级`： `微任务`==总是在==`下一个宏任务之前`==执行==。
4. `渲染时机`： `浏览器`通常会在`执行完一个宏任务`和`所有可用的微任务`后`进行页面渲染`。
5. 事件循环与异步编程： `事件循环`==使得 JavaScript 能够执行`非阻塞`的异步操作==。
6. 单线程模型： 尽管 JavaScript 是单线程的，但==通过事件循环可以模拟并发==。

示例：

```javascript
console.log('1'); // 同步代码

setTimeout(() => {
    console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() => {
    console.log('3'); // 微任务
});

console.log('4'); // 同步代码

// 输出顺序：1, 4, 3, 2
```

理解事件循环对于编写高效的异步代码和理解 JavaScript 的执行顺序至关重要。它帮助开发者避免阻塞主线程，提高应用的响应性和性能。

## 浏览器输入url之后发生了什么

1. - `URL 解析`

   - 浏览器`解析` URL 的`各个部分`：`协议`、`域名`、路径等。
   - 检查 HSTS（HTTP严格传输安全）列表。

   1. `DNS 解析`

   - 浏览器`检查本地 DNS 缓存`。
   - `如果`缓存中`没有`，`向 DNS 服务器`发起`请求`，`获取 IP 地址`。

   1. `TCP 连接`

   - 与`目标 IP 地址`建立 `TCP 连接`（三次握手）。
   - 如果是` HTTPS`，还需要进行 `TLS 握手`。

   1. `发送 HTTP 请求`

   - `浏览器``构造 HTTP 请求报文`。
   - `添加请求头`，如 User-Agent、`Cookie `等。

   1. `服务器处理请求并返回 HTTP 响应`

   - 服务器处理请求，可能涉及数据库查询、业务逻辑处理等。
   - 服务器`返回 HTTP 响应`，包含`状态码`、`响应头`和`响应体`。

   1. `浏览器处理响应`

   - 根据响应头中的 Content-Type 解析响应体。
   - 如果是重定向（3xx），则重新发起新的请求。

   1. `解析 HTML`

   - `构建 DOM`（文档对象模型）`树`。
   - `遇到外部资源`（如 `CSS`、`JavaScript`、`图片`）时，`发起新的请求`。

   1. `解析 CSS`

   - `构建 CSSOM`（CSS 对象模型）`树`。
   - `结合 DOM 树和 CSSOM 树`，`生成渲染树`（Render Tree）。

   1. `布局`（Layout）

   - `计算`每个`可见元素`的`精确位置`和`大小`。

   1. `绘制`（Paint）

   - 将`渲染树`中的`各个节点`绘制到`屏幕上`。

   1. 合成（Compositing）

   - 将`不同`的`绘制层合成到一起`。

   1. JavaScript 执行

   - `解析并执行 JavaScript 代码`。
   - `可能会修改 DOM 和 CSSOM`，`触发`重新布局、`绘制或合成`。

   1. 加载完成

   - 触发 window.onload 事件。

## 浏览器是如何渲染网页的

浏览器渲染网页是一个复杂的过程，主要包括以下几个关键步骤：

1. `解析 HTM`L（Parsing HTML）
   - 浏览器从服务器接收到HTML文档后，开始解析HTML。
   - `构建DOM`（Document Object Model）`树`，表示文档的结构。
2. `解析 CSS`（Parsing CSS）
   - 解析外部CSS文件和<style>标签中的样式。
   - `构建CSSOM`（CSS Object Model）`树`。
3. `构建渲染树`（Render Tree Construction）
   - 将D`OM和CSSOM结合`，`创建渲染树`。
   - 渲染树只包含需要显示的节点及其样式信息。
4. 布局（Layout）
   - `计算`每个`可见元素`的`精确位置`和`大小`。
   - 这个过程也称为"`回流`"（Reflow）。
5. 绘制（Painting）
   - 将`渲染树中的各个节点`绘制到`屏幕`上。
   - 这个过程涉及填充像素的过程。
6. 合成（Compositing）
   - 将`页面的不同部分分层`，`分别进行绘制`，然后在`屏幕上进行合成`。

## 垃圾回收机制

#### 标记清理

1. `从根对象`（如程序的全局变量、当前执行栈中的变量等）开始，通过`递归`的方式`遍历并标记`所有`可达对象`。可达对象是指从根对象出发，`通过引用关系可以访问到的对象`。
2. **清理阶段（Sweep Phase）**：对堆内存进行线性扫描，`未被标记的对象即为垃圾对象`，将这些垃圾对象所占用的内存`空间回收`。
3. 可以处理循环引用的情况

#### 引用计数

1. 为每个对象`维护一个引用计数器`，当`有新的引用指向该对象`时，引用`计数器加 1`；当某个引用`不再指向`该对象时，引用计`数器减 1`。当对象的引用计数器变`为 0 时`，该对象就被`认定为垃圾对象`，其占用的内存可以被回收。
2. 可以实时进行，不需要暂停整个应用程序的执行
3. 无法处理循环引用问题

## 宏任务与微任务



## 进程和线程的区别和联系

`进程`：是计算机中的程序关于某数据集合上的一次运行活动，是`系统进行资源分配和调度`的`基本单位`。

`线程`：是进程的一个`执行流`，是`CPU调度和分派的基本单位`。一个`进程`可以`包含多个线程`。

#### 主要区别：

##### 资源占用：

- 进程是`资源分配`的`最小单位`，每个`进程`都有`自己`的`独立内存空间`。
- 线程是`CPU调度`的`最小单位`，`同一进程中`的`多个线程共享`该`进程的内存空间`。

##### 开销：

- `进程`的`创建`、`切换`和`销毁`的`开销较大`。
- `线程`的`创建`、`切换`和`销毁`的`开销较小`。

##### 通信：

- 进程间`通信相对复杂`，需要使用IPC（进程间通信）机制。
- `同一进程内`的`线程通信更简单`，可以`直接读写进程数据`。

#### 安全性：

- `进程间``相互独立`，`一个进程崩溃``不会影响其他进程`。
- `线程间`共`享进程资源`，`一个线程崩溃`可能`导致整个进程崩溃`。

#### 在前端开发中的应用：

##### 浏览器架构：

- 现代浏览器通常采用多进程架构。主要包括`浏览器进程`、`渲染进程`、`插件进程`等。
- 在`渲染进程`中，包含`多个线程`，如`JS引擎线程`、`渲染线程`、`事件触发线程`等。

##### JavaScript的单线程：

- `JavaScript是单线程执行的`，这意味着在`同一时间`只能`执行一个任务`。
- 虽然JavaScript是单线程的，但`浏览器是多线程`的，这使得`异步操作成为可能`。

##### Web Workers：

- `Web Workers 允许`在`浏览器中创建后台线程`，`执行耗时的计算`而`不影响用户界面`。
- 虽然称为"workers"，但它们实际上是`轻量级的进程`，而`不是线程`。

#### 联系：

- `线程是进程内的执行单元`，`每个进程至少包含一个线程`。
- `进程和线程`都是`操作系统进行任务调度`的`基本单位`，只是`粒度不同`。

## 进程之间的通信有哪些

1. 管道（Pipe）和命名管道（Named Pipe）:
   - `管道`是最简单的 IPC 方式，通常用于`父子进程间通信`。
   - 在前端开发中，我们可能在使用 Node.js 的 child_process 模块时遇到管道通信。
2. `消息队列`（Message Queue）:
   - 进程可以`向队列写入消息`，`其他进程`可以`读取`。
   - Web 应用中的消息队列概念（如 Service Worker 的消息传递）与此类似，但实现方式不同。
3. `共享内存`（Shared Memory）:
   - `多个进程`可以`访问同一块内存区域`。
   - 在 Web 中，SharedArrayBuffer API 提供了类似的功能，允许在主线程和 Web Worker 之间共享二进制数据。
4. `信号`（Signal）:
   - 用于`通知接收进程`某个`事件已经发生`。
   - 在浏览器环境中没有直接对应，但可以类比为事件系统。
5. 套接字（Socket）:
   - 可用于同一机器上的进程通信，也可用于网络通信。
   - Web Sockets 在概念上类似，允许浏览器与服务器之间进行全双工通信。
6. 远程过程调用（RPC）:
   - 允许一个进程调用另一个进程的子程序。
   - 在 Web 开发中，可以类比为 AJAX 请求或 gRPC-Web。

## 为什么TCP需要三次握手才能建立连接

TCP 三次握手的主要目的：

1. 确保双方的发送和接收能力都正常。
2. 同步双方的序列号和确认号。
3. 协商一些参数（如窗口大小）。

三次握手的过程：

1. 第一次握手（SYN）：
   - 客户端发送一个 SYN（同步）包到服务器。
   - 这个包包含客户端的初始序列号（ISN）。
2. 第二次握手（SYN + ACK）：
   - 服务器收到 SYN 包后，回复一个 SYN-ACK 包。
   - 这个包确认了客户端的 SYN，并包含服务器自己的 SYN（初始序列号）。
3. 第三次握手（ACK）：
   - 客户端收到 SYN-ACK 后，回复一个 ACK 包。
   - 这个包确认了服务器的 SYN。

为什么需要三次握手：

1. 防止旧的重复连接初始化造成混乱：
   - 如果网络中存在延迟的重复 SYN 包，三次握手可以防止旧的无效连接请求被接受。
2. 同步双方的初始序列号：
   - 双方都需要告知对方自己的初始序列号，并确认收到对方的序列号。
3. 防止资源浪费：
   - 如果只有两次握手，服务器在发送 SYN-ACK 后就认为连接建立，而客户端可能并未收到。这会导致服务器浪费资源等待不会到来的连接。
4. 确保双向通信：
   - `三次握手保证了双方都有发送和接收的能力`。

## OSI 七层模型每一层是什么,分别做了什么事情

OSI 七层模型从底层到顶层分别是：

1. 物理层 (Physical Layer)
   - 主要功能：传输比特流（0和1）。
   - 设备：网线、光纤、中继器等。
   - 作用：定义物理设备如何传输数据。
2. 数据链路层 (Data Link Layer)
   - 主要功能：将比特流分组为帧，进行错误检测和纠正。
   - 协议：以太网协议、PPP等。
   - 作用：确保相邻设备之间的可靠传输。
3. 网络层 (Network Layer)
   - 主要功能：负责数据包的路由和转发。
   - 协议：IP、ICMP等。
   - 作用：确定数据从源到目的地的路径。
4. 传输层 (Transport Layer)
   - 主要功能：提供端到端的可靠数据传输。
   - 协议：TCP、UDP。
   - 作用：确保数据的可靠性和完整性。
5. 会话层 (Session Layer)
   - 主要功能：建立、管理和终止会话。
   - 作用：控制会话的建立、维护和结束。
6. 表示层 (Presentation Layer)
   - 主要功能：数据的表示、加密和压缩。
   - 作用：确保不同系统的数据可以相互理解。
7. 应用层 (Application Layer)
   - 主要功能：为应用程序提供网络服务。
   - 协议：HTTP、FTP、SMTP等。
   - 作用：直接与用户交互的接口。

## http报文都有哪些东西

HTTP 报文分为`请求报文`和`响应报文`，它们的`结构有所不同`，但`也有共同的部分`

#### HTTP `请求报文`的结构：

1. `请求行`（Request Line）

   - `HTTP 方法`（`GET`、`POST`、`PUT`、`DELETE `等）
   - `请求 URL`
   - `HTTP 版本`

   例如：`GET /index.html HTTP/1.1`

2. `请求头`（Request Headers）

   - `Host`：指定请求的服务器域名
   - `User-Agen`t：客户端信息
   - `Accept`：客户端可接受的内容类型
   - `Cookie`：客户端存储的 Cookie 信息
   - `Content-Type`：请求体的 MIME 类型（用于 POST 请求）
   - `Authorization`：身份认证信息

3. `空行`

   - 用于`分隔请求头和请求体`

4. `请求体`（`Request Body`，可选）

   - 用于 `POST`、`PUT `等方法，`包含发送的数据`

#### HTTP 响应报文的结构：

1. `状态行`（Status Line）

   - `HTTP 版本`
   - `状态码`（如 200、404、500 等）
   - 状态消息

   例如：`HTTP/1.1 200 OK`

2. `响应头`（Response Headers）

   - `Content-Type`：返回内容的 MIME 类型
   - `Content-Length`：响应体的长度
   - Set-Cookie：设置客户端 Cookie
   - Cache-Control：缓存控制
   - `Access-Control-Allow-Origin`：`CORS `相关

3. `空行`

   - 用于`分隔响应头和响应体`

4. `响应体`（Response Body）

   - `返回的实际内容`，如 HTML、JSON 等

## get请求会被浏览器缓存吗

`GET 请求通常会被浏览器缓存`，但这取决于多个因素：

1. 默认行为：
   - 浏览器`默认会缓存 GET 请求的响应`，`除非有特定的 HTTP 头指示不要缓存`。
2. 缓存控制：
   - 服务器可以通过设置特定的 HTTP 响应头来控制缓存行为。
   - 关键的响应头包括：Cache-Control, Expires, ETag, 和 Last-Modified。
3. Cache-Control 头：
   - 'no-store'：`完全禁止缓存`。
   - 'no-cache'：`每次都需要向服务器验证`缓存是否有效。
   - 'max-age'：`指定缓存的最大有效期`。
4. Expires 头：
   - 指定一个明确的过期日期。
5. ETag 和 If-None-Match：
   - 用于验证缓存是否仍然有效。
6. Last-Modified 和 If-Modified-Since：
   - 基于最后修改时间来验证缓存。

在前端开发中的应用：

1. 性能优化：
   - 合理利用缓存可以显著提高网页加载速度。
   - 对于不经常变化的资源（如图片、CSS、JS文件），我们可以设置较长的缓存时间。
2. 实时数据：
   - 对于需要实时更新的数据，我们可能需要禁用缓存或使用其他策略（如添加时间戳到URL）。
3. 版本控制：
   - 当更新静态资源时，我们可以通过改变文件名或URL来强制客户端重新请求新版本。
4. 调试：
   - 在开发过程中，缓存可能会导致看不到最新的更改，这时我们可能需要禁用缓存或强制刷新。
5. Single Page Applications (SPA)：
   - 在 SPA 中，我们需要特别注意 API 请求的缓存策略，以确保数据的实时性。
6. 离线应用：
   - 利用缓存，我们可以实现 Progressive Web Apps (PWA)，使应用在离线状态下仍然可用。

需要注意的是：

- POST 请求通常不会被缓存，因为它们可能会修改服务器状态。
- 即使是 GET 请求，如果包含认证信息（如 Authorization 头），也可能不会被缓存。

## url有长度限制吗

`URL 确实有长度限制`，但这个限制并不是由 HTTP 协议本身定义的。实际上，URL 的长度限制主要取决于以下几个因素：

1. 浏览器限制：
   - `不同的浏览器对 URL 长度有不同的限制`。
   - 例如，`Chrome 允许最长 2MB 的 URL`，而 `Internet Explore`r 的限制大约是` 2083 个字符`。
2. 服务器限制：
   - `Web 服务器如 Apache 或 Nginx 可能会对 URL 长度设置限制`。
   - 这些限制可以通过服务器配置来调整。
3. 客户端操作系统：
   - 某些操作系统可能对 URL 长度有额外的限制。
4. 防火墙和代理：
   - 网络设备可能会对超长 URL 进行截断或阻止。

在实际开发中的考虑：

1. GET 请求的限制：
   - `GET 请求的参数是附加在 URL `上的，因此特别容易受到 URL 长度限制的影响。
   - 当需要`传输大量数据`时，应考虑`使用 POST `请求。
2. RESTful API 设计：
   - 在设计 API 时，应该避免使用过长的 URL。
   - 考虑使用查询参数或请求体来传递复杂数据。
3. 前端表单提交：
   - 对于包含大量字段的表单，应该优先使用 POST 方法而不是 GET。
4. 安全性考虑：
   - 过长的 URL 可能会在日志文件、浏览器历史等地方泄露敏感信息。
5. `SEO 影响`：
   - `搜索引擎可能会忽略或降低过长 URL 的权重`。
6. 用户体验：
   - 过长的 URL 不利于分享和手动输入。
7. 缓存问题：
   - 非常长的 URL 可能会影响缓存效率，因为每个唯一的 URL 都被视为不同的资源。

## 为什么当需要传输大量数据时，应考虑使用 POST 请求

当需要传输大量数据时，我们推荐使用 POST 请求而不是 GET 请求，主要有以下几个原因：

1. 数据大小限制：
   - `GET 请求的参数是附加在 URL 上`的，而 `URL 长度是有限制`的。
   - `POST 请求将数据放在请求体中，理论上没有大小限制`（实际上可能受服务器配置限制）。
2. 安全性：
   - `GET 请求的参数会显示在 URL` 中，可能被`记录在浏览器历史、服务器日志`等处。
   - `POST 请求的数据在请求体中`，`相对更安全`，不易被无意中泄露。
3. 数据类型：
   - `GET 主要用于传输简单的文本数据`。
   - `POST 可以传输复杂的数据结构，包括文件上传`。
4. 缓存：
   - GET 请求更容易被缓存，这对于频繁变化的大量数据可能不适合。
   - POST 请求通常不被缓存，更适合动态数据。
5. 编码类型：
   - `GET 请求只能使用 URL 编码`。
   - `POST 可以使用多种编码`类型，如 application/x-www-form-urlencoded, `multipart/form-data` 等。
6. 数据完整性：
   - 大量数据通过 GET 请求时，可能因为 URL 长度限制被截断，导致数据不完整。
   - POST 请求不会有这个问题。
7. 浏览器对比：
   - 不同浏览器对 GET 请求 URL 长度的限制不同，使用 POST 可以避免兼容性问题。
8. RESTful API 设计：
   - 在 RESTful 设计中，POST 通常用于创建新资源或提交数据，更符合大量数据传输的语义。
9. 性能考虑：
   - 对于非常大的数据集，POST 请求可以分块发送，这在处理大文件上传时特别有用。
10. 服务器处理：
    - 服务器通常对 POST 请求有更好的处理机制，特别是对于大量数据。

## 解释一下死锁

#### 死锁的定义： 

死锁是指`两个或多个进程（或线程）`==互相等待对方释放资源==，`导致都无法继续执行的状态`。

在前端开发中，虽然我们通常不直接处理操作系统级别的死锁，但类似的情况可能在以下场景中出现：

1. `JavaScript 的事件循环`： 虽然 JavaScript 是单线程的，但`不当的异步操作可能导致类似死锁`的情况。例如，`两个 Promise 互相等待对方解决`。

   ```javascript
   let a, b;
   a = new Promise((resolve) => {
     setTimeout(() => {
       resolve(b);
     }, 1000);
   });
   b = new Promise((resolve) => {
     resolve(a);
   });
   // a 和 b 互相等待，永远不会解决
   ```

2. Web Workers： 在使用 Web Workers 时，如果`主线程和 worker 线程互相等待对方的消息`，可能会出现死锁类似的情况。

3. 前端框架中的数据流： 在复杂的状态管理系统（如 Redux）中，如果状态更新的逻辑设计不当，可能会导致组件互相等待对方的状态变化。

4. 资源加载： 如果`两个脚本互相依赖，但都被设置为异步加载，可能会导致它们都无法正确执行`。

#### 死锁的四个必要条件（Coffman 条件）：

1. 互斥：`资源不能被多个进程同时使用`。
2. `持有并等待`：进程持有一些资源，同时等待其他资源。
3. `不可抢占`：资源只能由持有它的进程自愿释放。
4. `循环等待`：存在一个进程等待链，形成一个循环。

#### 如何避免死锁（前端视角）：

1. `合理设计异步操作`，避免循环依赖。
2. 在复杂的状态管理中，清晰定义数据流向，避免循环更新。
3. `使用 Promise.all() `或 `async/await `来`更好地管理多个异步操作`。
4. 在使用 Web Workers 时，实现清晰的通信协议。
5. `合理安排资源加载顺序`，使用模块化和依赖管理工具。

## 如何解决死锁

#### 传统的死锁解决方法（简要提及）：

1. `预防`：破坏死锁的四个必要条件之一。
2. `避免`：`事先判断资源分配是否安全`。
3. `检测和恢复`：`允许死锁发生`，但`通过检测机制发现并解决`。
4. 忽略：假装死锁不会发生（不推荐）。

#### 在前端开发中解决类似死锁的情况：

1. 异步操作管理：

   - `使用 Promise 链或 async/await 来有序管理异步操作`。
   - `避免创建互相依赖的 Promise`。

   示例：

   ```javascript
   // 不好的做法
   let a, b;
   a = new Promise(resolve => setTimeout(() => resolve(b), 1000));
   b = new Promise(resolve => resolve(a));
   
   // 好的做法
   async function getData() {
     const a = await fetchDataA();
     const b = await fetchDataB(a);
     return { a, b };
   }
   ```

2. 状态管理：

   - 在使用 Redux 或类似状态管理库时，确保状态更新的单向流动。
   - `避免组件之间的循环依赖`。

   示例：

   ```javascript
   // 不好的做法
   const componentA = ({ updateB }) => {
     useEffect(() => {
       updateB(someData);
     }, []);
     // ...
   }
   
   const componentB = ({ updateA }) => {
     useEffect(() => {
       updateA(someOtherData);
     }, []);
     // ...
   }
   
   // 好的做法
   const componentA = ({ data }) => {
     // 仅根据 props 渲染，不主动更新其他组件
   }
   
   const componentB = ({ data }) => {
     // 仅根据 props 渲染，不主动更新其他组件
   }
   
   // 在父组件中管理状态更新
   ```

3. Web Workers 通信：

   - 实现清晰的消息传递协议。
   - 使用`超时机制避免无限等待`。

   示例：

   ```javascript
   const worker = new Worker('worker.js');
   const messagePromise = new Promise((resolve, reject) => {
     const timeout = setTimeout(() => reject(new Error('Worker timeout')), 5000);
     worker.onmessage = (event) => {
       clearTimeout(timeout);
       resolve(event.data);
     };
   });
   
   worker.postMessage('Start work');
   messagePromise.then(handleResult).catch(handleError);
   ```

4. 资源加载优化：

   - 使用模块打包工具（如 Webpack）管理依赖。
   - 采用按需加载或代码分割策略。

   示例：

   ```javascript
   // 使用动态 import 按需加载
   const DataVisualization = React.lazy(() => import('./DataVisualization'));
   
   function MyComponent() {
     return (
       <React.Suspense fallback={<div>Loading...</div>}>
         <DataVisualization />
       </React.Suspense>
     );
   }
   ```

5.事件循环和任务队列管理：

- 理解 JavaScript 的事件循环机制。
- `合理使用 `setTimeout, setImmediate (Node.js), 和 requestAnimationFrame。
- `避免长时间阻塞主线程`。

示例：

```javascript
// 不好的做法：可能阻塞主线程
function heavyComputation() {
  for (let i = 0; i < 1000000000; i++) {
    // 耗时操作
  }
}
heavyComputation();

// 好的做法：将大量计算分解成小任务
function heavyComputationChunked(i = 0) {
  const chunk = 1000000;
  for (let j = 0; j < chunk; j++, i++) {
    if (i >= 1000000000) return;
    // 耗时操作
  }
  setTimeout(() => heavyComputationChunked(i), 0);
}
heavyComputationChunked();
```

6.使用 Linter 和静态代码分析工具：

- 配置 ESLint 规则来检测潜在的循环依赖。
- 使用静态代码分析工具来识别复杂的依赖关系。

## 手写Promise.all

Promise.all 接收一个可迭代对象（通常是一个数组），其中包含多个 Promise。它会等待所有 Promise 都完成（或第一个失败），然后返回一个新的 Promise，这个 Promise 的结果是所有输入 Promise 的结果数组。

让我们一步步来实现：

```javascript
function myPromiseAll(promises) {
  // 首先，确保输入的是可迭代对象
  if (!promises[Symbol.iterator]) {
    throw new TypeError('Argument must be iterable');
  }

  // 将可迭代对象转换为数组
  const promiseArray = Array.from(promises);

  // 返回一个新的 Promise
  return new Promise((resolve, reject) => {
    // 用于存储结果的数组
    const results = [];
    // 计数器，用于跟踪已完成的 Promise 数量
    let completed = 0;

    // 如果输入的数组为空，立即解决并返回空数组
    if (promiseArray.length === 0) {
      resolve(results);
      return;
    }

    // 遍历所有输入的 Promise
    promiseArray.forEach((promise, index) => {
      // 使用 Promise.resolve 来处理非 Promise 值
      Promise.resolve(promise)
        .then(value => {
          // 将结果存储在对应的索引位置
          results[index] = value;
          completed++;

          // 如果所有 Promise 都已完成，解决返回的 Promise
          if (completed === promiseArray.length) {
            resolve(results);
          }
        })
        .catch(error => {
          // 如果有任何一个 Promise 失败，立即拒绝返回的 Promise
          reject(error);
        });
    });
  });
}
```

现在让我解释一下这个实现的关键点：

1. 我们首先检查输入是否为可迭代对象，如果不是，抛出类型错误。
2. 我们使用 Array.from() 将可迭代对象转换为数组，以便于处理。
3. 函数返回一个新的 Promise，这个 Promise 封装了所有输入 Promise 的处理逻辑。
4. 我们创建一个 results 数组来存储所有 Promise 的结果，并使用 completed 变量来跟踪已完成的 Promise 数量。
5. 如果输入数组为空，我们立即解决返回的 Promise。
6. 我们遍历所有输入的 Promise，对每个 Promise 使用 Promise.resolve() 来确保它是一个 Promise 对象（这也允许处理非 Promise 值）。
7. 当一个 Promise 成功时，我们将其结果存储在 results 数组中对应的位置，并增加 completed 计数。
8. 如果所有 Promise 都已完成，我们解决返回的 Promise，并传入结果数组。
9. 如果任何一个 Promise 失败，我们立即拒绝返回的 Promise，并传递错误信息。

这个实现涵盖了 Promise.all 的主要特性：并行处理多个 Promise，按顺序返回结果，以及在任何一个 Promise 失败时立即返回错误。

为了测试我们的实现，我们可以编写一些简单的测试用例：

```javascript
// 测试成功情况
const promises1 = [
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
];

myPromiseAll(promises1)
  .then(results => console.log('Test 1:', results))
  .catch(error => console.error('Test 1 Error:', error));

// 测试包含非 Promise 值
const promises2 = [
  Promise.resolve(1),
  2,
  Promise.resolve(3)
];

myPromiseAll(promises2)
  .then(results => console.log('Test 2:', results))
  .catch(error => console.error('Test 2 Error:', error));

// 测试失败情况
const promises3 = [
  Promise.resolve(1),
  Promise.reject('Error'),
  Promise.resolve(3)
];

myPromiseAll(promises3)
  .then(results => console.log('Test 3:', results))
  .catch(error => console.error('Test 3 Error:', error));

// 测试空数组
myPromiseAll([])
  .then(results => console.log('Test 4:', results))
  .catch(error => console.error('Test 4 Error:', error));
```

这些测试用例覆盖了不同的情况，包括全部成功、包含非 Promise 值、有失败的 Promise，以及空数组输入。

最后，我想补充一点，在实际的生产环境中，我们通常会使用内置的 Promise.all 方法，因为它经过了优化并且更可靠。这个手写实现主要是为了展示 Promise.all 的工作原理，并且在面试中展示我对 Promise 的理解。

在实际开发中，我们还需要考虑更多的边界情况和错误处理，比如处理 Promise 在解析过程中抛出的同步错误。此外，还可以考虑添加超时机制或取消功能，这些在某些场景下可能会很有用。

这个实现虽然基本涵盖了 Promise.all 的核心功能，但在性能和完整性方面可能还有提升空间。不过，对于展示对 Promise 的理解和基本的异步编程能力来说，这个实现应该是足够的。"