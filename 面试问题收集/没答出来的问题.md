## base64

Base64是一种用于`将二进制数据编码成ASCII字符串`格式的编码方式。

### [编码后大小增加](https://developer.mozilla.org/zh-CN/docs/Glossary/Base64#编码后大小增加)

每个 Base64 位代表 6 位数据。因此，输入字符串/二进制文件的`三个 8 位字节`（3×8 位 = 24 位）可以`用四个 6 位 Base64 位（4×6 = 24 位）表示`。

这意味着字符串或文件的 Base64 版本通常`比其原来的内容大大约`==三分之一==（确切的大小增加取决于各种因素，如字符串的绝对长度、它除以 3 的长度余数，以及是否使用填充字符）。

3. 解码过程：

​	解码是编码的逆过程，将Base64字符串转换回原始的二进制数据。

4. 特点：

- 可以`将任何二进制数据转换为可打印的ASCII字符`。
- `编码后的数据量会增加`约==33%==（因为`每3字节变成4字节`）。
- 不需要额外的字符来分隔编码的字符串。

5. 应用场景：

- `电子邮件附件编码`
- 编码二进制数据以便包含在 [`data:` URL](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) 中
- 存储复杂数据到HTML或CSS文件
- `传输小型图片文件`（如网页图标）
- JSON数据中包含二进制数据

6. 变体：

- Base64 URL Safe：将+和/分别替换为-和_，以便在URL中安全使用。
- Base32：使用32个字符表示数据，主要用于需要人工输入的场景。
- Base16（十六进制编码）：使用16个字符（0-9和A-F）表示数据。

7. 优缺点：

优点：
- 可以安全地`传输二进制数据`
- 跨平台兼容性好
- 简单易用

缺点：
- `增加了数据量`
- `编码和解码需要额外的处理时间`

9. 安全性：

​	Base64`不是加密算法`，`不能用于数据保护`。它只是一种编码方式，可以`很容易地被解码`。

10. 编程支持：

大多数编程语言都内置了Base64编码和解码的支持，如Python、Java、JavaScript等。

总之，Base64是一种简单而有效的编码方式，在需要以文本格式处理二进制数据的场景中非常有用。但使用时需要注意其对数据大小的影响，以及它并不提供任何安全性。

## Blob

Blob 是一个`不可变的原始数据对象`。它可以包含文本、图像、音频、视频等各种类型的数据。

#### 特点：

- `不可变`性：一旦创建，Blob 的内容就不能被直接修改。
- `大小可变`：Blob 可以存储几乎任意大小的数据。
- `类型灵活`：可以存储各种类型的二进制数据。
- `异步处理`：通常通过异步操作来读取或处理 Blob 数据。

#### 创建方法

```javascript
const blob = new Blob(["Hello, world!"], { type: "text/plain" });
```

- 使用 Blob 构造函数
- 从其他 Blob 对象切片
- 使用 canvas 的 toBlob() 方法
- Blob 可以转换为 Base64 编码，反之亦然

#### 属性

- `size`：Blob 的大小（字节）
- `type`：MIME 类型，如 "image/png" 或 "text/plain"

#### 使用场景

- 文件上传：处理用户选择的文件
- 文件下载：生成供用户下载的文件
- 图像处理：在 canvas 中操作图像数据
- 音频/视频处理：处理多媒体数据
- 大数据存储：在内存中临时存储大量数据

## 基于原型的继承

`__proto__` **是** `[[Prototype]]` **的因历史原因而留下来的 getter/setter**

使用 `obj.__proto__` 设置或读取原型被认为已经过时且不推荐使用（deprecated）了（已经被移至 JavaScript 规范的附录 B，意味着仅适用于浏览器）。

现代的获取/设置原型的方法有：

- [Object.getPrototypeOf(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) —— 返回对象 `obj` 的 `[[Prototype]]`。
- [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) —— 将对象 `obj` 的 `[[Prototype]]` 设置为 `proto`。

```javascript
Object.prototype.a = 1
Function.prototype.b = 2
function test(){

}
var t = new test()
console.log(t.a);
console.log(t.b);
```

1. 关于 `t.a`:
   - 当我们访问一个对象的属性时，JavaScript 会沿着原型链查找。
   - 查找顺序是：
     1. 先查看对象自身是否有这个属性
     2. 如果没有，查看对象的原型（即 `test.prototype`）
     3. 如果还没有，继续查看原型的原型

函数的 `prototype` 属性是用来给实例继承的，而 `Function.prototype` 的属性是给函数对象本身使用的，不会被实例继承。



1. 函数的双重角色： 在 JavaScript 中，函数有双重角色：

   - 它们是可以被调用的对象（函数对象）
   - 它们可以被用作构造函数来创建新对象

2. 构造函数和实例的关系：

   - 当函数被用作构造函数（使用 `new` 关键字）时，它创建的实例对象的原型是该函数的 `prototype` 属性
   - 这个 `prototype` 属性是一个普通对象，默认继承自 `Object.prototype`

3. 为什么 `test` 实例不继承 `Function.prototype`：

   - `test` 函数本身继承自 `Function.prototype`
   - 但 `test.prototype`（用于创建实例的原型对象）是一个普通对象，它继承自 `Object.prototype`，而不是 `Function.prototype`
   - 当我们创建 `test` 的实例时，这个实例继承自 `test.prototype`，而不是 `Function.prototype`

4. 原型链示意：

   ```
   test (函数对象) ---> Function.prototype ---> Object.prototype ---> null
   test.prototype ---> Object.prototype ---> null
   t (test的实例) ---> test.prototype ---> Object.prototype ---> null
   ```

5. 关键点：

   - `Function.prototype` 是函数对象的原型
   - `test.prototype` 是 `test` 实例的原型
   - 这两者是不同的对象，处于不同的原型链上

所以，`test` 的实例（如 `t`）不会继承 `Function.prototype` 的属性，因为 `Function.prototype` 不在 `t` 的原型链上。`t` 的原型链是从 `test.prototype` 开始的，而 `test.prototype` 是一个普通对象，继承自 `Object.prototype`。



1. 函数的两面性： 想象一下，每个函数在 JavaScript 中都有两个"面"：

   - 一面是它作为函数的身份（这一面连接到 Function.prototype）
   - 另一面是它作为对象制造机的身份（这一面通过它的 prototype 属性来体现）

2. 创建对象时发生了什么： 当我们使用 `new` 关键字创建对象时，JavaScript 实际上是看函数的 "制造机" 这一面，而不是它的 "函数" 这一面。

3. 具体到 `test` 函数：

   ```javascript
   function test() {}
   var t = new test();
   ```

   - `test` 作为函数，它自己继承自 Function.prototype
   - 但 `test` 还有一个 `prototype` 属性，这是它的 "制造机" 面
   - 当我们用 `new test()` 创建对象时，新对象 `t` 会链接到 `test.prototype`，而不是 Function.prototype

4. 视觉化理解：

   ```
   test (作为函数) -----> Function.prototype
                |
                |
   test.prototype (制造机面) -----> Object.prototype
                |
                |
   t (新创建的对象) -----> test.prototype
   ```

5. 关键点：

   - `t` 不会继承 Function.prototype 的属性，因为它不是通过 "函数面" 创建的
   - `t` 继承自 test.prototype，而 test.prototype 是一个普通对象，继承自 Object.prototype

6. 简单类比： 想象 `test` 是一个工厂。这个工厂（函数）本身是由 "函数制造公司"（Function.prototype）制造的。但是这个工厂生产的产品（`t`）遵循的是工厂自己的蓝图（test.prototype），而不是制造这个工厂的公司的规则。