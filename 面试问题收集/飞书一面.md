## 1个很大的数组,删除其中某几个索引的元素,怎么样性能最好

### 方法 1：使用 `filter` 方法

如果你有一个大数组，并且知道需要删除的索引，可以使用 `filter` 方法来创建一个新的数组，包含所有不需要删除的元素。这个方法相对简单且性能良好。

```js
javascript复制代码let largeArray = [...]; // 假设这是一个很大的数组
let indicesToRemove = new Set([2000, 5000, 10000]);

let filteredArray = largeArray.filter((_, index) => !indicesToRemove.has(index));
```

### 方法 2：直接修改数组

如果你希望直接修改原数组，可以从高索引到低索引进行删除，这样可以避免数组重排多次带来的性能问题。

```js
javascript复制代码let largeArray = [...]; // 假设这是一个很大的数组
let indicesToRemove = [2000, 5000, 10000];

// 从高索引到低索引删除元素
indicesToRemove.sort((a, b) => b - a).forEach(index => {
  largeArray.splice(index, 1);
});
```

### 方法 3：使用 `reduce` 方法

通过 `reduce` 方法可以创建一个新的数组，跳过需要删除的索引。

```js
javascript复制代码let largeArray = [...]; // 假设这是一个很大的数组
let indicesToRemove = new Set([2000, 5000, 10000]);

let newArray = largeArray.reduce((acc, current, index) => {
  if (!indicesToRemove.has(index)) {
    acc.push(current);
  }
  return acc;
}, []);
```

### 方法 4：标记删除（懒惰删除）

如果你的操作不需要立刻删除元素，可以先标记删除，然后在最后一次性进行过滤。这在某些情况下可以提高性能。

```js
javascript复制代码let largeArray = [...]; // 假设这是一个很大的数组
let indicesToRemove = new Set([2000, 5000, 10000]);

// 标记删除
indicesToRemove.forEach(index => {
  largeArray[index] = undefined;
});

// 过滤 undefined
largeArray = largeArray.filter(element => element !== undefined);
```

### 总结

对于大数组，性能最好的方法通常是创建一个新数组，而不是在原数组上进行多次操作。方法 1 使用 `filter` 和方法 3 使用 `reduce` 是最推荐的，因为它们简单且高效。直接修改数组的方法（方法 2）在某些情况下也可以有效，特别是当删除的索引数量较少时。

## this输出

## var声名变量和let区别

## promise.all

```javascript
function myPromiseAll(promises){
    //首先确保是可迭代对象
    if(!promises[Symbol.iterator]){
        throw new TypeError('Argument must be iterable')
    }

    //将可迭代对象转换为数组
    const promsieArray = Array.from(promises)
    //返回一个新的promise
    return new Promise((resolve, reject) => {
        const result = []//存储结果的数组
        let computed = 0//跟踪已经resolve的数量
        //数组为空,直接resolve并返回result
        if(promsieArray.length === 0) {
            resolve(result)
            return
        }
        //遍历所有的promise
        promsieArray.forEach((promise, index) => {
            //使用promise.resolve来处理非promise的值
            Promise.resolve(promise)
                .then(value => {
                    //结果存储在对应索引位置
                    result[index] = value
                    computed++
                    //所有promise都完成,解决返回的 Promise
                    if(computed === promsieArray.length){
                        resolve(result)
                    }
                })
                .catch(error => {
                    // 如果有任何一个 Promise 失败，立即拒绝返回的 Promise
                    reject(error)
                })
        })
    })
}
const promises1 = [
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3)
  ];
  
  myPromiseAll(promises1)
    .then(results => console.log('Test 1:', results))
    .catch(error => console.error('Test 1 Error:', error));
```

1. **遍历并处理 Promise**：
   - 使用 `Promise.resolve` 确保每个元素都是一个 Promise。`即使元素不是 Promise`，也会被 `Promise.resolve` 包装为一个已解决的 Promise。
   - 使用 `then` 方法处理已解决的 Promise，将结果存储在 `result` 数组对应的索引位置。
   - 使用一个计数器 `resolvedCount` 跟踪已解决的 Promise 数量。如果所有 Promise 都已解决，调用 `resolve` 返回结果数组。
   - 使用 `catch` 方法处理 Promise 拒绝的情况，立即调用 `reject`。

这种方式确保了即使输入包含非 Promise 值，也能正确处理，避免了冗余代码，同时保持了逻辑的清晰性和简洁性。

## 点击一个按钮,出现一个浮层,点击浮层内部没有反应,点击浮层外关闭浮层,怎么用浏览器的事件实现

### HTML

首先，定义一个按钮和一个浮层：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floating Layer Example</title>
  <style>
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
    }

    .overlay.active {
      display: flex;
    }

    .modal {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <button id="showButton">Show Overlay</button>
  <div id="overlay" class="overlay">
    <div class="modal">
      <p>This is the floating layer content.</p>
    </div>
  </div>

  <script src="script.js"></script>
</body>
</html>
```

### JavaScript

在 JavaScript 中，实现按钮点击显示浮层，点击浮层内部不关闭浮层，点击浮层外部关闭浮层的逻辑。

```js
document.addEventListener('DOMContentLoaded', () => {
  const showButton = document.getElementById('showButton');
  const overlay = document.getElementById('overlay');
  const modal = document.querySelector('.modal');

  // 点击按钮显示浮层
  showButton.addEventListener('click', () => {
    overlay.classList.add('active');
  });

  // 点击浮层外部关闭浮层
  overlay.addEventListener('click', (event) => {
    // 检查点击的目标是否是浮层自身（而不是浮层内的内容）
    if (event.target === overlay) {
      overlay.classList.remove('active');
    }
  });

  // 防止点击浮层内部关闭浮层
  modal.addEventListener('click', (event) => {
    event.stopPropagation();
  });
});
```

### 解释

1. **HTML 结构**：
   - 定义一个按钮和一个浮层（overlay）。
   - 浮层内部包含一个模态框（modal）。
2. **CSS 样式**：
   - `.overlay` 定义浮层的样式，初始状态为 `display: none`。
   - `.overlay.active` 当浮层被激活时，使用 `display: flex` 显示浮层，并让它居中对齐。
   - `.modal` 定义浮层内部内容的样式。
3. **JavaScript 逻辑**：
   - **点击按钮显示浮层**：点击按钮时，添加 `active` 类到浮层上，显示浮层。
   - **点击浮层外部关闭浮层**：给浮层添加点击事件监听器，检查点击的目标是否是浮层自身，如果是则移除 `active` 类关闭浮层。
   - **防止点击浮层内部关闭浮层**：给浮层内部内容添加点击事件监听器，使用 `event.stopPropagation()` 阻止事件冒泡，从而防止关闭浮层。

通过这种方式，可以实现点击按钮显示浮层，点击浮层内部不关闭浮层，点击浮层外部关闭浮层的效果。

## css隐藏元素的方式

### . `display: none;`

- **效果**：完全隐藏元素，元素不占据任何空间。
- **使用场景**：需要完全隐藏元素，并且不希望它占据空间。

```
css复制代码.hidden {
  display: none;
}
```

### 2. `visibility: hidden;`

- **效果**：隐藏元素，但元素仍然占据空间。
- **使用场景**：需要隐藏元素，但保留其占据的空间，例如在动画或过渡中。

```
css复制代码.hidden {
  visibility: hidden;
}
```

### 3. `opacity: 0;`

- **效果**：元素变得完全透明，但仍然占据空间并且可以响应点击事件。
- **使用场景**：需要元素不可见但仍然响应交互，例如悬停效果或动画。

```
css复制代码.hidden {
  opacity: 0;
}
```

### 4. `position: absolute; left: -9999px;`

- **效果**：将元素移出视口，使其不可见，但元素仍然在文档流中。
- **使用场景**：用于隐藏元素但保留其在文档流中的位置，例如屏幕阅读器的无障碍支持。

```
css复制代码.hidden {
  position: absolute;
  left: -9999px;
}
```

### 5. `clip-path: inset(100%);` 或 `clip: rect(0, 0, 0, 0);`

- **效果**：裁剪元素，使其不可见，但仍然占据空间并且可以响应点击事件。
- **使用场景**：隐藏元素但保留其在文档流中的位置和交互性。

```
css复制代码.hidden {
  clip: rect(0, 0, 0, 0);
  position: absolute;
}
```

### 6. `height: 0; overflow: hidden;`

- **效果**：设置元素高度为 0 并隐藏溢出内容，使其不可见但仍然占据水平空间。
- **使用场景**：需要隐藏元素的内容但保留其水平空间，例如折叠内容区域。

```
css复制代码.hidden {
  height: 0;
  overflow: hidden;
}
```

### 7. `transform: scale(0);`

- **效果**：缩放元素至不可见，但元素仍然占据空间。
- **使用场景**：需要通过缩放动画隐藏元素。

```
css复制代码.hidden {
  transform: scale(0);
}
```

### 8. `z-index: -1;`

- **效果**：将元素置于其他内容的下面，使其不可见，但仍然占据空间并且可以响应点击事件。
- **使用场景**：需要通过调整层叠顺序隐藏元素。

```
css复制代码.hidden {
  position: relative;
  z-index: -1;
}
```

### 总结

选择哪种方式取决于具体的需求：

- **完全隐藏**且不占据空间：使用 `display: none;`。
- **隐藏**但保留空间：使用 `visibility: hidden;`。
- **隐藏**但保留交互性和空间：使用 `opacity: 0;`。
- **隐藏**但保留文档流位置：使用 `position: absolute; left: -9999px;` 或 `clip-path: inset(100%);`。
- **隐藏**内容但保留水平空间：使用 `height: 0; overflow: hidden;`。
- **通过动画隐藏**：使用 `transform: scale(0);`。

