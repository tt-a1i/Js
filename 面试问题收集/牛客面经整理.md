## 左侧固定宽度100px,右侧宽度占满空间,可以通过什么方式实现

#### Flexbox 布局

```javascript
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  display: flex;
}
.left {
  width: 100px;
  flex-shrink: 0;
}
.right {
  flex-grow: 1;
}
```

#### Grid 布局

**grid-template-columns:**

- 这个属性是用来定义网格容器中列的结构的。
- 它接受一个列表作为值，列表中的每个项代表一列。

**100px:**

- 表示第一列的宽度固定为 100 像素。

**1fr:**

- `fr` 是一个单位，表示“分数单位”（fractional unit）。
- `1fr` 表示这一列会占据剩余空间的 1份。
- 如果有多个 `fr` 单位，它们会按照比例分配剩余空间。

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  display: grid;
  grid-template-columns: 100px 1fr;
}
```

#### Float 布局

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  overflow: hidden;
}
.left {
  float: left;
  width: 100px;
}
.right {
  margin-left: 100px;
}
```

#### 绝对定位

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  position: relative;
}
.left {
  position: absolute;
  width: 100px;
}
.right {
  margin-left: 100px;
}
```

#### Table 布局

```html
<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
.container {
  display: table;
  width: 100%;
}
.left, .right {
  display: table-cell;
}
.left {
  width: 100px;
}
```

## flex属性

1. flex-grow

- 定义：决定 flex 项目相对于容器中其他 flex 项目如何增长。
- 取值：非负数字，默认为 0。
- 作用：当容器有多余空间时，flex-grow 值越大的项目会获得更多的剩余空间。

例如：

```css
.item1 { flex-grow: 1; }
.item2 { flex-grow: 2; }
```

在这个例子中，如果有多余空间，item2 会比 item1 获得两倍的额外空间。

1. flex-shrink

- 定义：决定 flex 项目相对于容器中其他 flex 项目如何收缩。
- 取值：非负数字，默认为 1。
- 作用：当容器空间不足时，flex-shrink 值越大的项目会收缩得更多。

例如：

```css
.item1 { flex-shrink: 1; }
.item2 { flex-shrink: 2; }
```

在这个例子中，如果空间不足，item2 会比 item1 收缩得更多。

1. flex-basis

- 定义：指定 flex 项目在主轴方向上的初始大小。
- 取值：长度值（如 px、em）、百分比或 auto（默认）。
- 作用：设置 flex 项目的基准尺寸，然后再应用 flex-grow 或 flex-shrink。

例如：

```css
.item { flex-basis: 200px; }
```

这会给项目一个 200px 的初始宽度（如果主轴是水平方向）。

flex 简写：

flex 属性是这三个属性的简写，顺序为 flex-grow、flex-shrink、flex-basis。

例如：

```css
.item { flex: 1 1 auto; }
```

常用的简写值：

- `flex: 1;` 等同于 `flex: 1 1 0%;`，允许项目增长和收缩。
- `flex: auto;` 等同于 `flex: 1 1 auto;`，类似于上面，但考虑项目的内容尺寸。
- `flex: none;` 等同于 `flex: 0 0 auto;`，创建不可伸缩的项目。
- `flex: 0 auto;` 或 `flex: initial;` 等同于 `flex: 0 1 auto;`，是默认值。

## 怎么算选择器权重

选择器权重的计算方法：

1. 内联样式：1000 分
2. ID 选择器：100 分
3. 类选择器、属性选择器、伪类：10 分
4. 元素选择器、伪元素：1 分
5. 通配符(*)、组合器（如 >、+、~）：0 分

计算步骤：

1. 统计选择器中每种类型的数量
2. 按照上述分值计算总分
3. 比较不同选择器的总分

例子：

1. `#nav .list li a:hover`
   - 1 个 ID 选择器：100
   - 1 个类选择器：10
   - 2 个元素选择器：2
   - 1 个伪类：10 总分：100 + 10 + 2 + 10 = 122
2. `body #content .data img:hover`
   - 1 个 ID 选择器：100
   - 1 个类选择器：10
   - 2 个元素选择器：2
   - 1 个伪类：10 总分：100 + 10 + 2 + 10 = 122
3. `div p .class`
   - 1 个类选择器：10
   - 2 个元素选择器：2 总分：10 + 2 = 12

注意事项：

1. `!important `声明会覆盖所有其他声明，应谨慎使用。
2. 如果`权重相同`，`后面`的规则会`覆盖前面`的规则。
3. `继承`的样式`没有权重`。
4. `通用选择器`（*）、`组合器`（+、>、~、空格）和`否定伪类`（:not()）`对优先级没有影响`。

## 怎么判断变量是否为数组

1. `Array.isArray()` 方法

这是最推荐的方法，因为它是专门用来检测数组的。

```javascript
Array.isArray([1, 2, 3]);  // 返回 true
Array.isArray({});         // 返回 false
```

1. `instanceof `操作符

```javascript
let arr = [1, 2, 3];
arr instanceof Array;  // 返回 true
```

注意：这种方法在跨窗口或跨框架的情况下可能会失效。

1. `Object.prototype.toString.call()`

这是一种更通用的方法，可以检测多种类型。

```javascript
Object.prototype.toString.call([1, 2, 3]) === '[object Array]';  // 返回 true
```

1. 检查 `constructor` 属性

```javascript
let arr = [1, 2, 3];
arr.constructor === Array;  // 返回 true
```

1. 检查 length 属性和数字索引（不太可靠）

```javascript
function isArray(obj) {
    return obj && 
           typeof obj === 'object' && 
           typeof obj.length === 'number' && 
           !(obj.propertyIsEnumerable('length'));
}
```

这种方法不太可靠，因为类数组对象也可能通过这个测试。

1. ES6+ 的扩展运算符

```javascript
const isArray = obj => !!obj && obj.constructor === Array;
```

## Object.prototype.toString.call()判断使用是什么原理

`Object.prototype.toString.call()` 来判断一个值是否为数组（或其他类型）的原理涉及到 JavaScript 的内部机制。让我解释一下这个方法的工作原理：

1. `toString` 方法的特殊性：
   - 每个对象都从 `Object.prototype` 继承了 `toString` 方法。
   - 大多数内置对象都重写了这个方法，以返回更有意义的字符串表示。
2. `call` 方法的作用：
   - `call` 允许我们在特定的上下文中调用一个函数。
   - 它改变了 `this` 的指向，使得 `Object.prototype.toString` 方法在被检查的对象上执行。
3. 内部 `[[Class]]` 属性：
   - JavaScript 引擎为每个对象维护一个内部的 `[[Class]]` 属性。
   - 这个属性不能直接访问，但 `Object.prototype.toString` 方法可以读取它。
4. 返回值格式：
   - 当 `Object.prototype.toString` 被调用时，它会返回一个形如 `"[object Type]"` 的字符串。
   - 这里的 `Type` 就是对象的内部 `[[Class]]` 值。
5. 对于数组：
   - 数组的内部 `[[Class]]` 值是 `"Array"`。
   - 因此，对数组调用这个方法会返回 `"[object Array]"`。

## 304

HTTP 304 状态码代表`"Not Modified"（未修改）`，这是一个非常重要的优化相关的状态码。它主要`用于缓存验证`，其含义和用途如下： 

1. 含义： 304 状态码表示`客户端 `发送了一个`条件性GET请求`，服务器判断`请求的资源未被修改`，可以直接使用客户端`已缓存的版本`。
2. 工作原理：
   - 客户端在`请求头中包含条件验证信息`（如` If-Modified-Since `或 If-None-Match）。
   - `服务器检查`资源`是否被修改`。
   - 如果资源`未被修改`，服务器`返回 304` 状态码，`不返回资源`内容。
   - 客户端`收到 304 `响应后，`使用本地缓存`的版本。
3. 主要用途：
   - 减少网络传输：避免重复传输未修改的资源。
   - 提高加载速度：使用本地缓存比重新下载更快。
   - 节省带宽：减少不必要的数据传输。
4. 相关的`请求头`：
   - `If-Modified-Since`：`基于时间的验证`。
   - If-None-Match：基于 ETag 的验证。
5. 相关的`响应头`：
   - `Last-Modified`：`资源的最后修改时间`。
   - `ETag`：`资源的唯一标识符`。
6. `流程`：
   - 浏览器`首次请求一个页面`。
   - 服务器`返回页面内容`，并`包含 Last-Modified` 或 `ETag 头`。
   - 浏览器`缓存这个页面`。
   - `下次请求同一页面时`，`浏览器发送`包含 `If-Modified-Since 或 If-None-Match` 的请求。
   - 如果`页面未修改`，服务器`返回 304 状态码`。
   - 浏览器`使用缓存的版本`。
7. 优点：
   - 提高网站性能和响应速度。
   - 减少服务器负载。
   - 节省带宽和流量费用。
8. 注意事项：
   - 304 响应通常不包含响应体。
   - 即使返回 304，也可能更新缓存相关的头信息。
9. 实现：
   - 服务器端需要正确实现条件请求的处理逻辑。
   - 客户端（如浏览器）需要正确处理 304 响应。

总之，HTTP 304 状态码是一种重要的性能优化机制，通过有效利用客户端缓存来减少不必要的数据传输，从而提高 Web 应用的整体性能和用户体验。

## TCP和UDP的区别

TCP和UDP的主要区别：

1. 连接：
   - TCP: `面向连接`，需要`先建立连接`再`传输数据`
   - UDP: `无连接`，只知道对端的IP和端口号就可以发送，不需要实现建立连接
2. 可靠性：
   - TCP: `可靠`传输，保证`数据完整性`和`顺序`
   - UDP:` 不保证可靠`传输，可能`丢包`、`乱序`,没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息,不能够灵活的控制读写数据的次数和数量,存在接收缓冲区，但不存在发送缓冲区
3. 传输速度：
   - TCP: 相对`较慢`，因为有`各种控制机制`
   - UDP: `较快`，没有额外的控制开销
4. 数据边界：
   - TCP: 面向`字节流`，不保留数据边界
   - UDP: 面向`报文`，保留数据边界
5. 流量控制：
   - TCP: 有流量控制机制
   - UDP: 无流量控制
6. 拥塞控制：
   - TCP: 有拥塞控制机制
   - UDP: 无拥塞控制
7. 错误检测：
   - TCP: 有错误检测和纠正机制
   - UDP: 仅有简单的错误检测，不进行纠正
8. 应用场景：
   - TCP: `适用于`要求`可靠传输`的应用，如网页浏览、`文件传输`、`电子邮件`等
   - UDP: 适用于`实时性`要求高、`允许少量丢包`的应用，如`视频流`、`在线游戏`、VoIP等
9. 首部开销：
   - TCP: `首部至少20字节`
   - UDP: 首部仅`8字节`，开销小
10. 数据传输方式：
    - TCP: `全双工`，`双向传输`
    - UDP: 支持`一对一`、`一对多`、`多对一`和`多对多`交互通信
11. 状态维护：
    - TCP: 需要在端系统中维护连接状态
    - UDP: 无状态

## 事件循环例题

```javascript
async function async1(){
    console.log('async1 start');
    await async2()
    console.log('async1 end');
}

async function async2(){
    console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1()

new Promise(function (resolve){
    console.log('promise1');
    resolve()
}).then(function(){
    console.log('promise2');
})

console.log('script end');
```

这段代码涉及到 JavaScript 的事件循环、宏任务、微任务以及 async/await 的执行机制。让我们逐步分析输出顺序：

首先执行同步代码：

打印 "script start"

遇到 setTimeout，将其回调函数放入宏任务队列

调用 async1 函数：

打印 "async1 start"

遇到 await async2()，执行 async2 函数

打印 "async2"

async2 函数结束，返回一个 Promise

await 使 async1 函数剩余部分被放入微任务队列

遇到 new Promise，执行其中的同步代码：

打印 "promise1"

调用 resolve()，将 then 中的回调放入微任务队列

执行最后一行同步代码：

打印 "script end"

同步代码执行完毕，开始执行微任务队列：

执行 async1 函数剩余部分，打印 "async1 end"

执行 Promise 的 then 回调，打印 "promise2"

微任务队列清空，执行宏任务队列：

执行 setTimeout 的回调，打印 "setTimeout"

因此，最终的输出顺序是：

script start

async1 start

async2

promise1

script end

async1 end

promise2

setTimeout

这个顺序反映了 JavaScript 的事件循环机制：先执行同步代码，然后执行微任务，最后执行宏任务。

async/await 本质上是 Promise 的语法糖，await 后面的代码相当于放在 Promise.then 中执行，因此也是作为微任务处理的。 

## Vue3的响应式是如何实现的

Vue3的响应式系统是基于`ES6`的`Proxy`实现的，这是一个重大改进，相比`Vue2`使用的`Object.defineProperty()`方法有很多`优势`

#### Proxy 代理：

Vue3 使用 `Proxy` 来`创建响应式对象`。Proxy 可以`拦截对象的基本操作`，如`属性读取`、`赋值`、`删除`等。

Vue3使用`Proxy`来`创建`一个`对原始对象的代理`。这个`代理可以拦截`并`处理各种操作`，如`属性读取`、`设置`、`删除`等。

1. 基本原理

- 当你`访问或修改响应式对象的属性`时，`Proxy的get和set`陷阱会`被触发`。
- `在get陷阱中`，Vue会`追踪依赖`（即记录`哪些效果或计算属性依赖于这个属性`）。
- 在`set陷阱中`，Vue会`触发更新`，`通知所有依赖于这个属性的效果重新运行`。

1. 嵌套对象的处理

Vue3`能够自动地、递归地将嵌套对象转换为响应式`，这是通过在get陷阱中按需转换实现的。

1. `集合类型的支持`

Vue3还为Map、Set、WeakMap和WeakSet提供了完全的响应式支持。

#### 相比Vue2，Vue3的响应式系统有以下优势：

- 可以`检测到属性的添加和删除`
- 可以`检测数组索引和长度`的变化
- 可以`支持Map、Set`等数据结构
- `性能更好`，尤其是对于大型对象
- 消除了Vue2中的一些边缘情况和限制

#### 为什么性能更好

1. Proxy `可以直接监听整个对象`，而不需要递归遍历每个属性
2. `惰性观察`策略,一个`嵌套对象被访问时`，它`才会被转换为响应式`
3. `依赖跟踪更精确`，可以精确到 `property 级别`,`数据变化时`，`只有直接相关的组件会更新`，而`不是整个组件树`
4. `更好`的 `Tree-shaking` 支持
5. 更好的`类型推断`
6. `编译优化`,Vue3 的`模板编译器`能生成`更优化的渲染函数`。

## 盒子模型

描述了 HTML `元素`在`文档布局中`所`占空间`的`计算方式`。`每个 HTML 元素都可以被视为一个盒子`，由以下部分组成：

1. `内容`区域（Content）：包含元素的实际内容，如文本、图像等。
2. `内边距`（Padding）：内容区域与边框之间的空间。
3. `边框`（Border）：围绕在内边距和内容区域外的边界。
4. `外边距`（Margin）：盒子与其他元素之间的空间。

盒子模型有两种主要类型：

1. `标准盒子模型`（Standard Box Model）：
   - 元素的宽度和高度只包括内容区域。
   - 总宽度 = `width `+ `padding `+ `border `+ `margin`
   - 总高度 = height + padding + border + margin
2. IE 盒子模型（IE Box Model）或`怪异盒子模型`：
   - 元素的宽度和高度包括内容、内边距和边框。
   - 总宽度 = `width `(包含 padding 和 border) + `margin`
   - 总高度 = height (包含 padding 和 border) + margin

即`IE盒模型`的`width`为`content `+ `padding `+ `border`

在 CSS3 中，可以使用 `box-sizing` 属性来控制盒子模型的类型：

- box-sizing: ` content-box;` （默认值）使用`标准`盒子模型
- box-sizing: `border-box;` 使用` IE `盒子模型

## 浏览器的事件循环

浏览器的`事件循环`（`Event Loop`）是 JavaScript `运行时环境`中`处理异步操作`的`机制`。它确保了 JavaScript 的`单线程`执行模型能够高效地`处理异步任务`，而`不`会`阻塞主线程`。以下是事件循环的主要组成部分和工作原理：

1. 调用栈（Call Stack）：
   - 用于存储正在执行的函数调用。
   - 遵循后进先出（LIFO）的原则。
2. 堆（Heap）：
   - 用于存储对象，是内存分配发生的地方。
3. 任务队列（Task Queue）：
   - 也称为`宏任务队列`（Macrotask Queue）。
   - 存储待执行的任务（如 `setTimeout`、`setInterval `的回调、`DOM 事件`等）。
4. `微任务队列`（Microtask Queue）：
   - 存储优先级更高的任务（如 `Promise `的回调、`MutationObserver `等）。

事件循环的工作`流程`：

1. `执行调用栈`中的`同步代码`。
2. `调用栈为空`时，`检查微任务队列`：
   - 如果`微任务队列不为空`，`依次执行`所有`微任务`。
   - 执行`过程中`新`产生的微任务`也会被`添加到队列末尾`并`执行`。
3. `微任务队列清空后`，从任务队列中取出一个宏任务执行。
4. 重复步骤 2-3，直到both3. 微任务队列清空后，从任务队列中取出一个任务执行。
5. 重复步骤 2-3，直到所有队列都为空。

重要概念：

1. `宏任务`（Macrotasks）：
   - `setTimeout`, `setInterval`, `setImmediate`
   - `I/O 操作`
   - `UI 渲染`
   - `requestAnimationFrame`
2. `微任务`（Microtasks）：
   - `Promise`.then(), Promise.catch(), Promise.finally()
   - `MutationObserver`
   - queueMicrotask()
   - `process.nextTick` (Node.js)
3. 任务`优先级`： `微任务`==总是在==`下一个宏任务之前`==执行==。
4. `渲染时机`： `浏览器`通常会在`执行完一个宏任务`和`所有可用的微任务`后`进行页面渲染`。
5. 事件循环与异步编程： `事件循环`==使得 JavaScript 能够执行`非阻塞`的异步操作==。
6. 单线程模型： 尽管 JavaScript 是单线程的，但==通过事件循环可以模拟并发==。

示例：

```javascript
console.log('1'); // 同步代码

setTimeout(() => {
    console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() => {
    console.log('3'); // 微任务
});

console.log('4'); // 同步代码

// 输出顺序：1, 4, 3, 2
```

理解事件循环对于编写高效的异步代码和理解 JavaScript 的执行顺序至关重要。它帮助开发者避免阻塞主线程，提高应用的响应性和性能。

## 浏览器输入url之后发生了什么

1. - `URL 解析`

   - 浏览器`解析` URL 的`各个部分`：`协议`、`域名`、`端口号`。
   - 检查 HSTS（HTTP严格传输安全）列表。

   1. `DNS 解析`

   - 浏览器`检查本地 DNS 缓存`。
   - `如果`缓存中`没有`，`向 DNS 服务器`发起`请求`，`获取 IP 地址`。

   1. `TCP 连接`

   - 与`目标 IP 地址`建立 `TCP 连接`（三次握手）。
   - 如果是` HTTPS`，还需要进行 `TLS 握手`。

   1. `发送 HTTP 请求`

   - `浏览器构造 HTTP 请求报文`。
   - `添加请求头`，如 User-Agent、`Cookie `等。

   1. `服务器处理请求并返回 HTTP 响应`

   - 服务器处理请求，可能涉及数据库查询、业务逻辑处理等。
   - 服务器`返回 HTTP 响应`，包含`状态码`、`响应头`和`响应体`。

   1. `浏览器处理响应`

   - `根据响应头`中的 `Content-Type `解析`响应体`。
   - 如果是重定向（3xx），则重新发起新的请求。

   1. `解析 HTML`

   - `构建 DOM`（文档对象模型）`树`。
   - `遇到外部资源`（如 `CSS`、`JavaScript`、`图片`）时，`发起新的请求`。

   1. `解析 CSS`

   - `构建 CSSOM`（CSS 对象模型）`树`。
   - `结合 DOM 树和 CSSOM 树`，`生成渲染树`（Render Tree）。

   1. `布局`（Layout）

   - `计算`每个`可见元素`的`精确位置`和`大小`。

   1. `绘制`（Paint）

   - 将`渲染树`中的`各个节点`绘制到`屏幕上`。

   1. 合成（Compositing）

   - 将`不同`的`绘制层合成到一起`。

   1. JavaScript 执行

   - `解析并执行 JavaScript 代码`。
   - `可能会修改 DOM 和 CSSOM`，`触发`重新布局、`绘制或合成`。

   1. 加载完成

   - 触发 window.onload 事件。

## 浏览器是如何渲染网页的

浏览器渲染网页是一个复杂的过程，主要包括以下几个关键步骤：

1. `解析 HTM`L（Parsing HTML）
   - 浏览器从服务器接收到HTML文档后，开始解析HTML。
   - `构建DOM`（Document Object Model）`树`，表示文档的结构。
2. `解析 CSS`（Parsing CSS）
   - 解析外部CSS文件和<style>标签中的样式。
   - `构建CSSOM`（CSS Object Model）`树`。
3. `构建渲染树`（Render Tree Construction）
   - 将D`OM和CSSOM结合`，`创建渲染树`。
   - 渲染树只包含需要显示的节点及其样式信息。
4. 布局（Layout）
   - `计算`每个`可见元素`的`精确位置`和`大小`。
   - 这个过程也称为"`回流`"（Reflow）。
5. 绘制（Painting）
   - 将`渲染树中的各个节点`绘制到`屏幕`上。
   - 这个过程涉及填充像素的过程。
6. 合成（Compositing）
   - 将`页面的不同部分分层`，`分别进行绘制`，然后在`屏幕上进行合成`。

## 垃圾回收机制

#### 标记清理

1. `从根对象`（如程序的全局变量、当前执行栈中的变量等）开始，通过`递归`的方式`遍历并标记`所有`可达对象`。可达对象是指从根对象出发，`通过引用关系可以访问到的对象`。
2. **清理阶段（Sweep Phase）**：对堆内存进行线性扫描，`未被标记的对象即为垃圾对象`，将这些垃圾对象所占用的内存`空间回收`。
3. `可以处理循环引用`的情况

#### 引用计数

1. 为每个对象`维护一个引用计数器`，当`有新的引用指向该对象`时，引用`计数器加 1`；当某个引用`不再指向`该对象时，引用计`数器减 1`。当对象的引用计数器变`为 0 时`，该对象就被`认定为垃圾对象`，其占用的内存可以被回收。
2. 可以`实时进行`，不需要暂停整个应用程序的执行
3. `无法处理循环引用`问题

## 宏任务与微任务



## 进程和线程的区别和联系

`进程`：是计算机中的程序关于某数据集合上的一次运行活动，是`系统进行资源分配和调度`的`基本单位`。

`线程`：是进程的一个`执行流`，是`CPU调度和分派的基本单位`。一个`进程`可以`包含多个线程`。

#### 主要区别：

##### 资源占用：

- 进程是`资源分配`的`最小单位`，每个`进程`都有`自己`的`独立内存空间`。
- 线程是`CPU调度`的`最小单位`，`同一进程中`的`多个线程共享`该`进程的内存空间`。

##### 开销：

- `进程`的`创建`、`切换`和`销毁`的`开销较大`。
- `线程`的`创建`、`切换`和`销毁`的`开销较小`。

##### 通信：

- 进程间`通信相对复杂`，需要使用IPC（进程间通信）机制。
- `同一进程内`的`线程通信更简单`，可以`直接读写进程数据`。

#### 安全性：

- `进程间相互独立`，`一个进程崩溃不会影响其他进程`。
- `线程间`共`享进程资源`，`一个线程崩溃`可能`导致整个进程崩溃`。

#### 在前端开发中的应用：

##### 浏览器架构：

- 现代浏览器通常采用多进程架构。主要包括`浏览器进程`、`渲染进程`、`插件进程`等。
- 在`渲染进程`中，包含`多个线程`，如`JS引擎线程`、`渲染线程`、`事件触发线程`等。

##### JavaScript的单线程：

- `JavaScript是单线程执行的`，这意味着在`同一时间`只能`执行一个任务`。
- 虽然JavaScript是单线程的，但`浏览器是多线程`的，这使得`异步操作成为可能`。

##### Web Workers：

- `Web Workers 允许`在`浏览器中创建后台线程`，`执行耗时的计算`而`不影响用户界面`。

  

#### 联系：

- `线程是进程内的执行单元`，`每个进程至少包含一个线程`。
- `进程和线程`都是`操作系统进行任务调度`的`基本单位`，只是`粒度不同`。

## 进程之间的通信有哪些

1. 管道（Pipe）和命名管道（Named Pipe）:
   - `管道`是最简单的 IPC 方式，通常用于`父子进程间通信`。
   - 在前端开发中，我们可能在使用 Node.js 的 child_process 模块时遇到管道通信。
2. `消息队列`（Message Queue）:
   - 进程可以`向队列写入消息`，`其他进程`可以`读取`。
   - Web 应用中的消息队列概念（如 Service Worker 的消息传递）与此类似，但实现方式不同。
3. `共享内存`（Shared Memory）:
   - `多个进程`可以`访问同一块内存区域`。
   - 在 Web 中，SharedArrayBuffer API 提供了类似的功能，允许在主线程和 Web Worker 之间共享二进制数据。
4. `信号`（Signal）:
   - 用于`通知接收进程`某个`事件已经发生`。
   - 在浏览器环境中没有直接对应，但可以类比为事件系统。
5. 套接字（Socket）:
   - 可用于同一机器上的进程通信，也可用于网络通信。
   - Web Sockets 在概念上类似，允许浏览器与服务器之间进行全双工通信。
6. 远程过程调用（RPC）:
   - 允许一个进程调用另一个进程的子程序。
   - 在 Web 开发中，可以类比为 AJAX 请求或 gRPC-Web。

## 为什么TCP需要三次握手才能建立连接

#### TCP 三次握手的主要目的：

1. `确保双方的发送和接收能力都正常`。
2. 同步双方的序列号和确认号。
3. 协商一些参数（如窗口大小）。

#### 三次握手的过程：

1. 第一次握手（SYN）：
   - 客户端发送一个 SYN（同步）包到服务器。
   - 这个包包含客户端的初始序列号（ISN）。
2. 第二次握手（SYN + ACK）：
   - 服务器收到 SYN 包后，回复一个 SYN-ACK 包。
   - 这个包确认了客户端的 SYN，并包含服务器自己的 SYN（初始序列号）。
3. 第三次握手（ACK）：
   - 客户端收到 SYN-ACK 后，回复一个 ACK 包。
   - 这个包确认了服务器的 SYN。

#### 为什么需要三次握手：

`第一次握手`:`客户端向服务器`发送,`客户端`可以`确认`自己`发送能力正常`,`服务端`能`确认`自己`接受能力正常`

`第二次握手`:`服务端`向`客户端`发送,到此次发送后,`客户端`能确认自己`接受正常`,`发送正常`,`服务端`确认自己`接受能力正常`,但是`还不知道客户端有没有接收到,``不能确认`自己`发送能力正常`

`第三次握手`:`客户端`发送,`服务器收到后`能`确认`自己`发送能力也正常`,此时`双方都能确认发送和接受正常`

1. 防止旧的重复连接初始化造成混乱：
   - 如果`网络中存在延迟的重复 SYN 包`，`三次握手可以防止旧的无效连接请求被接受`。
2. 同步双方的初始序列号：
   - `双方都需要告知对方自己的初始序列号`，`并确认收到对方的序列号`。
3. 防止资源浪费：
   - 如果只有两次握手，服务器在发送 SYN-ACK 后就认为连接建立，而客户端可能并未收到。这会导致服务器浪费资源等待不会到来的连接。
4. 确保双向通信：
   - `三次握手保证了双方都有发送和接收的能力`。

## 为什么TCP需要四次挥手

1. **第一次挥手**：`客户端`向`服务器`发送一个`结束信号`（FIN），`表示客户端没有数据发送了`，但`仍能接收`数据。
2. **第二次挥手**：`服务端`接收到`客户端`的FIN之后，发送一个`确认信号`（ACK）。不过，此时`服务端可能仍有数据需要发送给客户端`，所以`连接仍需保持开放状态直至服务端数据全部发送`完成。
3. **第三次挥手**：`服务端`数据`发送完毕后`，向`客户端`发送一个`结束信号`（FIN），表示`服务器端也没有数据要发送`了，`准备关闭连接`。
4. **第四次挥手**：`客户端`收到`服务端`的FIN后，发送一个`确认信号`（ACK），`结束`整个通信过程。

四次挥手确保了在TCP连接中，`双方能够独立地关闭自己的发送和接收通道`。由于TCP连接是`全双工`的，意味着双方的发送和接收操作是独立的。因此，每一方在结束它们的发送操作后，必须独立地接收对方的确认，这就是为何断开连接需要四次挥手的原因。这个过程`保证了数据传输的完整性`和`正确关闭连接的确认动作`。

## 什么是全双工

全双工（Full Duplex）是指通信网络中的一种数据传输方式，其中`通信双方可以同时发送和接收信息`，而`不会互相干扰`。在全双工模式下，数据可以在两个方向上同时流动，`类似于两条独立的单向通道`。

### 全双工的主要特点：

1. **双向同时通信**：全双工允许在两个方向上同时进行数据发送和接收，因此，通信设备`一边发送数据`，`同时也能够接收对方的数据`。
2. **高效的数据流动**：由于允许同时双向通信，全双工通常提供较高的通信效率和速度，尤其适用于需要高速双向数据交换的应用。
3. **独立的传输通道**：全双工系统通常有两个独立的信道，一个用于发送，另一个用于接收，或者通过技术手段在同一信道上同时处理发送和接收的数据。

### 应用案例

- **`电话通话`**：在电话通话中，两个用户可以同时说话和听话，而不需要等对方停止说话之后才能开始说话。
- **网络交换器（Switch）和`路由器`**：这些网络设备通常支持全双工，可以提高网络的数据传输效率和速度。

### 与半双工和单工的比较

- **`单工`（Simplex）**：数据`只能在一个方向上流动`，如传统的`广播电视`，`只有发送端到接收端`的单向传输。
- **`半双工`（Half Duplex）**：数据`能在两个方向上传输`，`但在任何给定时刻只能在一个方向上进行`。通信设备使用同一个信道交替进行发送和接收。例如，`对讲机`就是典型的半双工通信设备。

全双工模式因其能有效提升通信效率而广泛应用于现代通信系统中，特别是在那些对时延和速度要求较高的场合。



## OSI 七层模型每一层是什么,分别做了什么事情

OSI 七层模型从`底层到顶层`分别是：

1. `物理`层 (Physical Layer)
   - 主要功能：`传输比特流`（0和1）。
   - 设备：`网线`、`光纤`、中继器等。
   - 作用：`定义物理设备如何传输数据`。
2. `数据链路`层 (Data Link Layer)
   - 主要功能：`将比特流分组为帧`，进行`错误检测和纠正`。
   - 协议：`以太网协议`、PPP等。
   - 作用：确保`相邻设备之间的可靠传输`。
3. `网络`层 (Network Layer)
   - 主要功能：负责`数据包的路由和转发`。
   - 协议：`IP`、`ICMP`等。
   - 作用：`确定数据从源到目的地的路径`。
4. `传输`层 (Transport Layer)
   - 主要功能：`提供端到端的可靠数据传输`。
   - 协议：`TCP`、`UDP`。
   - 作用：`确保数据的可靠性和完整性`。
5. `会话`层 (Session Layer)
   - 主要功能：`建立`、`管理和终止会话`。
   - 作用：`控制会话的建立`、`维护和结束`。
6. `表示`层 (Presentation Layer)
   - 主要功能：`数据的表示`、`加密和压缩`。
   - 作用：确保`不同系统的数据可以相互理解`。
7. `应用`层 (Application Layer)
   - 主要功能：`为应用程序提供网络服务`。
   - 协议：`HTTP`、`FTP`、SMTP等。
   - 作用：`直接与用户交互的接口`。

## http报文都有哪些东西

HTTP 报文分为`请求报文`和`响应报文`，它们的`结构有所不同`，但`也有共同的部分`

#### HTTP `请求报文`的结构：

1. `请求行`（Request Line）

   - `HTTP 方法`（`GET`、`POST`、`PUT`、`DELETE `等）
   - `请求 URL`
   - `HTTP 版本`

   例如：`GET /index.html HTTP/1.1`

2. `请求头`（Request Headers）

   - `Host`：指定请求的`服务器域名`
   - `User-Agen`t：`客户端信息`
   - `Accept`：客户端`可接受`的`内容类型`
   - `Cookie`：客户端存储的 Cookie 信息
   - `Content-Type`：请求体的 `MIME `类型（用于 POST 请求）
   - `Authorization`：身份认证信息

3. `空行`

   - 用于`分隔请求头和请求体`

4. `请求体`（`Request Body`，可选）

   - 用于 `POST`、`PUT `等方法，`包含发送的数据`

MIME类型（Multipurpose Internet Mail Extensions）是`一种标准`，`用于表示文档`、`文件或字节流`的`性质和格式`

MIME类型的格式通常是`type/subtype`，其中`type`表示数据的`总体类别`，`subtype`表示`具体的格式`。例如：

- `text/plain`：`纯文本`
- `text/html`：`HTML文档`
- `image/jpeg`：`JPEG图像`
- `application/json`：`JSON数据`
- `application/pdf`：`PDF文档`

#### HTTP 响应报文的结构：

1. `状态行`（Status Line）

   - `HTTP 版本`
   - `状态码`（如 200、404、500 等）
   - 状态消息

   例如：`HTTP/1.1 200 OK`

2. `响应头`（Response Headers）

   - `Content-Type`：返回内容的 MIME 类型
   - `Content-Length`：响应体的长度
   - Set-Cookie：设置客户端 Cookie
   - `Cache-Control`：`缓存控制`
   - `Access-Control-Allow-Origin`：`CORS `相关

3. `空行`

   - 用于`分隔响应头和响应体`

4. `响应体`（Response Body）

   - `返回的实际内容`，如 HTML、JSON 等

## get请求会被浏览器缓存吗

`GET 请求通常会被浏览器缓存`，但这取决于多个因素：

1. 默认行为：
   - 浏览器`默认会缓存 GET 请求的响应`，`除非有特定的 HTTP 头指示不要缓存`。
2. 缓存控制：
   - `服务器可以通过设置特定的 HTTP 响应头`来`控制缓存行为`。
   - 关键的响应头包括：`Cache-Control`, `Expires`, ETag, 和` Last-Modified`。
3. `Cache-Control 头`：
   - '`no-store`'：`完全禁止缓存`。
   - '`no-cache`'：`每次都需要向服务器验证`缓存是否有效。
   - '`max-age`'：`指定缓存的最大有效期`。
4. `Expires `头：
   - 指定一个明确的`过期日期`。
5. `ETag `和 `If-None-Match`：
   - 用于`验证缓存是否仍然有效`。
6. `Last-Modified` 和 `If-Modified-Since`：
   - `基于最后修改时间来验证缓存`。

在前端开发中的应用：

1. 性能优化：
   - 合理利用缓存可以显著提高网页加载速度。
   - 对于不经常变化的资源（如图片、CSS、JS文件），我们可以设置较长的缓存时间。
2. 实时数据：
   - 对于需要实时更新的数据，我们可能需要禁用缓存或使用其他策略（如添加时间戳到URL）。
3. 版本控制：
   - 当更新静态资源时，我们可以通过改变文件名或URL来强制客户端重新请求新版本。
4. 调试：
   - 在开发过程中，缓存可能会导致看不到最新的更改，这时我们可能需要禁用缓存或强制刷新。
5. Single Page Applications (SPA)：
   - 在 SPA 中，我们需要特别注意 API 请求的缓存策略，以确保数据的实时性。
6. 离线应用：
   - 利用缓存，我们可以实现 Progressive Web Apps (PWA)，使应用在离线状态下仍然可用。

需要注意的是：

- `POST 请求通常不会被缓存`，`因为`它们`可能会修改服务器状态`。
- 即使是` GET 请求`，如果`包含认证信息（如 Authorization 头）`，也`可能不会被缓存`。

## url有长度限制吗

`URL 确实有长度限制`，但这个限制并不是由 HTTP 协议本身定义的。实际上，URL 的长度限制主要取决于以下几个因素：

1. 浏览器限制：
   - `不同的浏览器对 URL 长度有不同的限制`。
   - 例如，`Chrome 允许最长 2MB 的 URL`，而 `Internet Explore`r 的限制大约是` 2083 个字符`。
2. 服务器限制：
   - `Web 服务器如 Apache 或 Nginx 可能会对 URL 长度设置限制`。
   - 这些限制可以通过服务器配置来调整。
3. 客户端操作系统：
   - 某些`操作系统`可能对 URL 长度有额外的限制。
4. 防火墙和代理：
   - `网络设备`可能会对超长 URL 进行截断或阻止。

在实际开发中的考虑：

1. GET 请求的限制：
   - `GET 请求的参数是附加在 URL `上的，因此特别`容易受到 URL 长度限制的影响`。
   - 当需要`传输大量数据`时，应考虑`使用 POST `请求。
2. RESTful API 设计：
   - 在设计 API 时，应该避免使用过长的 URL。
   - 考虑使用查询参数或请求体来传递复杂数据。
3. 前端表单提交：
   - 对于包含大量字段的`表单`，应该`优先使用 POST `方法而不是 GET。
4. `安全性`考虑：
   - `过长的 URL` 可能`会在日志文件`、`浏览器历史`等地方`泄露敏感信息`。
5. `SEO 影响`：
   - `搜索引擎可能会忽略或降低过长 URL 的权重`。
6. `用户体验`：
   - `过长的 URL 不利于分享和手动输入`。
7. 缓存问题：
   - 非常长的 URL 可能会影响缓存效率，因为每个唯一的 URL 都被视为不同的资源。

## 为什么当需要传输大量数据时，应考虑使用 POST 请求

当需要传输大量数据时，我们推荐使用 POST 请求而不是 GET 请求，主要有以下几个原因：

1. 数据大小限制：
   - `GET 请求的参数是附加在 URL 上`的，而 `URL 长度是有限制`的。
   - `POST 请求将数据放在请求体中，理论上没有大小限制`（实际上可能受服务器配置限制）。
2. 安全性：
   - `GET 请求的参数会显示在 URL` 中，可能被`记录在浏览器历史、服务器日志`等处。
   - `POST 请求的数据在请求体中`，`相对更安全`，不易被无意中泄露。
3. 数据类型：
   - `GET 主要用于传输简单的文本数据`。
   - `POST 可以传输复杂的数据结构，包括文件上传`。
4. 缓存：
   - GET 请求更容易被缓存，这对于频繁变化的大量数据可能不适合。
   - POST 请求通常不被缓存，更适合动态数据。
5. 编码类型：
   - `GET 请求只能使用 URL 编码`。
   - `POST 可以使用多种编码`类型，如 `application/x-www-form`-urlencoded, `multipart/form-data` 等。

`简单的表单数据`通常使用`application/x-www-form-urlencoded`，而涉及到`文件上传和需要传输较大数据`的情况，则使用`multipart/form-data`

1. 数据完整性：
   - 大量数据通过 GET 请求时，可能因为 URL 长度限制被截断，导致数据不完整。
   - POST 请求不会有这个问题。
2. 浏览器对比：
   - `不同浏览器对 GET 请求 URL 长度的限制不同`，使用` POST 可以避免`兼容性问题。
3. RESTful API 设计：
   - 在 RESTful 设计中，POST 通常用于创建新资源或提交数据，`更符合大量数据传输的语义`。
4. 性能考虑：
   - 对于非常大的数据集，`POST 请求可以分块发送`，这在处理大文件上传时特别有用。
5. 服务器处理：
   - 服务器通常对 POST 请求有更好的处理机制，特别是对于大量数据。
   - 服务器接收到`POST`请求时，它会从HTTP请求体中提取数据。不同的`Content-Type`要求服务器采用不同的解析方式

## 解释一下死锁

#### 死锁的定义： 

死锁是指`两个或多个进程（或线程）`==互相等待对方释放资源==，`导致都无法继续执行的状态`。

在前端开发中，虽然我们通常不直接处理操作系统级别的死锁，但类似的情况可能在以下场景中出现：

1. `JavaScript 的事件循环`： 虽然 JavaScript 是单线程的，但`不当的异步操作可能导致类似死锁`的情况。例如，`两个 Promise 互相等待对方解决`。

   ```javascript
   let a, b;
   a = new Promise((resolve) => {
     setTimeout(() => {
       resolve(b);
     }, 1000);
   });
   b = new Promise((resolve) => {
     resolve(a);
   });
   // a 和 b 互相等待，永远不会解决
   ```

2. Web Workers： 在使用 `Web Workers` 时，如果`主线程和 worker 线程互相等待对方的消息`，可能会出现死锁类似的情况。

3. 前端框架中的数据流： 在复杂的状态管理系统（如 Redux）中，如果状态更新的逻辑设计不当，可能会导致组件互相等待对方的状态变化。

4. 资源加载： 如果`两个脚本互相依赖，但都被设置为异步加载，可能会导致它们都无法正确执行`。

#### 死锁的四个必要条件（Coffman 条件）：

1. 互斥：`资源不能被多个进程同时使用`。
2. `持有并等待`：进程持有一些资源，同时等待其他资源。
3. `不可抢占`：资源只能由持有它的进程自愿释放。
4. `循环等待`：存在一个进程等待链，形成一个循环。

#### 如何避免死锁（前端视角）：

1. `合理设计异步操作`，`避免循环依赖`。
2. 在复杂的状态管理中，清晰定义数据流向，避免循环更新。
3. `使用 Promise.all() `或 `async/await `来`更好地管理多个异步操作`。
4. 在使用 Web Workers 时，实现清晰的通信协议。
5. `合理安排资源加载顺序`，使用模块化和依赖管理工具。

## 如何解决死锁

#### 传统的死锁解决方法（简要提及）：

1. `预防`：破坏死锁的四个必要条件之一。
2. `避免`：`事先判断资源分配是否安全`。
3. `检测和恢复`：`允许死锁发生`，但`通过检测机制发现并解决`。
4. 忽略：假装死锁不会发生（不推荐）。

#### 在前端开发中解决类似死锁的情况：

1. 异步操作管理：

   - `使用 Promise 链或 async/await 来有序管理异步操作`。
   - `避免创建互相依赖的 Promise`。

   示例：

   ```javascript
   // 不好的做法
   let a, b;
   a = new Promise(resolve => setTimeout(() => resolve(b), 1000));
   b = new Promise(resolve => resolve(a));
   
   // 好的做法
   async function getData() {
     const a = await fetchDataA();
     const b = await fetchDataB(a);
     return { a, b };
   }
   ```

2. 状态管理：

   - 在使用 Redux 或类似状态管理库时，确保状态更新的单向流动。
   - `避免组件之间的循环依赖`。

   示例：

   ```javascript
   // 不好的做法
   const componentA = ({ updateB }) => {
     useEffect(() => {
       updateB(someData);
     }, []);
     // ...
   }
   
   const componentB = ({ updateA }) => {
     useEffect(() => {
       updateA(someOtherData);
     }, []);
     // ...
   }
   
   // 好的做法
   const componentA = ({ data }) => {
     // 仅根据 props 渲染，不主动更新其他组件
   }
   
   const componentB = ({ data }) => {
     // 仅根据 props 渲染，不主动更新其他组件
   }
   
   // 在父组件中管理状态更新
   ```

3. Web Workers 通信：

   - 实现清晰的消息传递协议。
   - 使用`超时机制避免无限等待`。

   示例：

   ```javascript
   const worker = new Worker('worker.js');
   const messagePromise = new Promise((resolve, reject) => {
     const timeout = setTimeout(() => reject(new Error('Worker timeout')), 5000);
     worker.onmessage = (event) => {
       clearTimeout(timeout);
       resolve(event.data);
     };
   });
   
   worker.postMessage('Start work');
   messagePromise.then(handleResult).catch(handleError);
   ```

4. 资源加载优化：

   - 使用模块打包工具（如 Webpack）管理依赖。
   - 采用按需加载或代码分割策略。

   示例：

   ```javascript
   // 使用动态 import 按需加载
   const DataVisualization = React.lazy(() => import('./DataVisualization'));
   
   function MyComponent() {
     return (
       <React.Suspense fallback={<div>Loading...</div>}>
         <DataVisualization />
       </React.Suspense>
     );
   }
   ```

5.事件循环和任务队列管理：

- 理解 JavaScript 的事件循环机制。
- `合理使用 `setTimeout, setImmediate (Node.js), 和 requestAnimationFrame。
- `避免长时间阻塞主线程`。

示例：

```javascript
// 不好的做法：可能阻塞主线程
function heavyComputation() {
  for (let i = 0; i < 1000000000; i++) {
    // 耗时操作
  }
}
heavyComputation();

// 好的做法：将大量计算分解成小任务
function heavyComputationChunked(i = 0) {
  const chunk = 1000000;
  for (let j = 0; j < chunk; j++, i++) {
    if (i >= 1000000000) return;
    // 耗时操作
  }
  setTimeout(() => heavyComputationChunked(i), 0);
}
heavyComputationChunked();
```

6.使用 Linter 和静态代码分析工具：

- 配置 ESLint 规则来检测潜在的循环依赖。
- 使用静态代码分析工具来识别复杂的依赖关系。

## 手写Promise.all

Promise.all 接收一个可迭代对象（通常是一个数组），其中包含多个 Promise。它会等待所有 Promise 都完成（或第一个失败），然后返回一个新的 Promise，这个 Promise 的结果是所有输入 Promise 的结果数组。

让我们一步步来实现：

对于`forEach`遍历操作来说，确实是按照顺序同步进行遍历的。然而，在`处理包括异步操作`（如 `Promise`）的场景中，`遍历本身是同步的`，但是`每个被遍历调用的异步操作则是独立并行执行的`。

`forEach`用于`启动Promise并不阻塞其他Promise的启动`，`导致所有Promise变为并行执行`，而不是一个接一个的串行执行。

举一个具体的例子，当你使用`forEach`来遍历一个包含Promise的数组时，`forEach`会`为数组中的每个元素同步调用一次回调函数`。但是，在这些回调函数中，`如果你启动了一个异步操作`（如通过`Promise.resolve()`），这些`异步操作并不会等待前一个完成后才开始，而是几乎同时开始执行的`。

每个Promise的执行仍然是独立的。也就是说，当你在`forEach`中触发所有的Promise时，它们会同时进入到异步队列，在各自当负载和时机成熟时独立解决。解决的时序取决于各自的处理时间和系统资源情况，这就是并行性的表现。

```javascript
function myPromiseAll(promises){
    //首先确保是可迭代对象
    if(!promises[Symbol.iterator]){
        throw new TypeError('Argument must be iterable')
    }

    //将可迭代对象转换为数组
    const promsieArray = Array.from(promises)
    //返回一个新的promise
    return new Promise((resolve, reject) => {
        const result = []//存储结果的数组
        let computed = 0//跟踪已经resolve的数量
        //数组为空,直接resolve并返回result
        if(promsieArray.length === 0) {
            resolve(result)
            return
        }
        //遍历所有的promise
        promsieArray.forEach((promise, index) => {
            //使用promise.resolve来处理非promise的值
            //如果不需要处理非promise的值,直接promise.then,可以直接用[1,2,3]这种数组来测试
            //可以安全地处理promise和非promise值，无需担心调用非promise值上不存在的.then()方法，从而避免引发错误
            Promise.resolve(promise)
                .then(value => {
                    //结果存储在对应索引位置
                    result[index] = value
                    computed++
                    //所有promise都完成,解决返回的 Promise
                    if(computed === promsieArray.length){
                        resolve(result)
                    }
                })
                .catch(error => {
                    // 如果有任何一个 Promise 失败，立即拒绝返回的 Promise
                    reject(error)
                })
        })
    })
}
const promises1 = [
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.reject(3)
  ];
  
  myPromiseAll(promises1)
    .then(results => console.log('Test 1:', results))
    .catch(error => console.log('Test 1 Error:', error));
```

现在让我解释一下这个实现的关键点：

1. 我们首先检查输入`是否为可迭代对象`，如果`不是`，`抛出类型错误`。
2. 我们使用 `Array.from() 将可迭代对象转换为数组`，以便于处理。
3. 函数`返回一个新的 Promise`，这个 Promise 封装了所有输入 Promise 的处理逻辑。
4. 我们创建一个 `results 数组来存储所有 Promise 的结果`，并使用 completed 变量来跟踪已完成的 Promise 数量。
5. 如果`输入数组为空`，我们`立即解决返回的 Promise`。
6. 我们==遍历所有输入的 Promise==，==对每个 Promise 使用 Promise.resolve()== 来==确保它是一个 Promise 对象==（==这也允许处理非 Promise 值==）。
7. 当一个 Promise 成功时，我们将其结果存储在 results 数组中对应的位置，并增加 completed 计数。
8. 如果所有 Promise 都已完成，我们解决返回的 Promise，并传入结果数组。
9. 如果任何一个 Promise 失败，我们立即拒绝返回的 Promise，并传递错误信息。

这个实现涵盖了 Promise.all 的主要特性：`并行处理多个 Promise`，`按顺序返回结果`，以及在任何一个 Promise 失败时立即返回错误。

为了测试我们的实现，我们可以编写一些简单的测试用例：

```javascript
// 测试成功情况
const promises1 = [
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
];

myPromiseAll(promises1)
  .then(results => console.log('Test 1:', results))
  .catch(error => console.error('Test 1 Error:', error));

// 测试包含非 Promise 值
const promises2 = [
  Promise.resolve(1),
  2,
  Promise.resolve(3)
];

myPromiseAll(promises2)
  .then(results => console.log('Test 2:', results))
  .catch(error => console.error('Test 2 Error:', error));

// 测试失败情况
const promises3 = [
  Promise.resolve(1),
  Promise.reject('Error'),
  Promise.resolve(3)
];

myPromiseAll(promises3)
  .then(results => console.log('Test 3:', results))
  .catch(error => console.error('Test 3 Error:', error));

// 测试空数组
myPromiseAll([])
  .then(results => console.log('Test 4:', results))
  .catch(error => console.error('Test 4 Error:', error));
```

这些测试用例覆盖了不同的情况，包括全部成功、包含非 Promise 值、有失败的 Promise，以及空数组输入。

最后，我想补充一点，在实际的生产环境中，我们通常会使用内置的 Promise.all 方法，因为它经过了优化并且更可靠。这个手写实现主要是为了展示 Promise.all 的工作原理，并且在面试中展示我对 Promise 的理解。

## 强缓存和协商缓存

### 强缓存 (Strong Caching)

强缓存意味着`如果缓存有效`，则`不需要向服务器发送请求`。浏览器`直接使用缓存中的副本`。控制强缓存的`HTTP头主`要有两个：

1. `Cache-Control`
2. `Expires`

#### Cache-Control

`Cache-Control` 是最常用的方式来控制缓存，其具体字段如下：

- `max-age=<seconds>`：资源在本地缓存保存的最大时间（秒），超过这个时间后缓存将被认为是过期的。
- `no-cache`：禁止使用强缓存，每次请求都会去服务器验证。
- `no-store`：彻底禁止缓存，每次请求都会下载完整的资源。
- `public`：响应可以被任何缓存区缓存（即使是代理服务器等中间节点）。
- `private`：响应只适合私有缓存（如浏览器缓存），不允许任何中间缓存（如CDN）缓存。
- `s-maxage=<seconds>`：覆盖`max-age`或者`Expires`头，但只在共享缓存（比如各种代理）中有效。

#### Expires

`Expires` 用来指定资源到期的日期和时间，是HTTP/1.0的遗留字段，如果同时设置有`Cache-Control: max-age`，则`Expires` 会被忽略。

### 协商缓存 (Negotiated Caching)

当`强缓存失效后`，`浏览器`将`在请求头中带上缓存标识向服务器询问`，这就是协商缓存。`如果资源未修改`，服务器将`返回304状态码`，`告诉浏览器直接使用本地缓存`。控制协商缓存的HTTP头主要包括：

1. `Last-Modified` / `If-Modified-Since`
2. `ETag` / `If-None-Match`

#### Last-Modified / If-Modified-Since

- `Last-Modified`：这个`响应头标识了资源最后修改的时间`。
- `If-Modified-Since`：在随后的请求中，浏览器会将`Last-Modified`的值放入`If-Modified-Since`请求头中发送给服务器。如果服务器上的内容自该日期以来未被修改，则返回304状态码。

#### ETag / If-None-Match

- `ETag`：`资源的特定版本的标识符`，通常是一个`哈希值`或者其他指纹。
- `If-None-Match`：类似于`If-Modified-Since`，但是这是使用`ETag`值进行对比。如果`ETag`值匹配（即资源未改变），服务器返回304。

### 使用策略

- 对于频繁变动的资源，可以使用`Cache-Control: no-cache`来确保总是获得最新的版本。
- 对于不常更改的资源，如JS、CSS库，使用`Cache-Control: max-age`或`Expires`设置一个较长的过期时间可以提高页面加载速度。
- 对于核心网页文件本身（如HTML），通常使用协商缓存来确保用户总是有最新的页面版本，同时又能在未修改时利用缓存。

## script标签如何加载

在默认情冀外，当浏览器遇到 `<script>` 标签，会`停止解析`HTML文档，`直到脚本执行完成`。这是因为脚本可能会修改DOM结构，因此浏览器需要等待脚本执行完成以确保DOM的准确性。这种行为可通过以下属性进行控制：

1. **async**

   - 当使用 `async` 属性时，脚本会`异步加载`。即浏览器继续解析文档，不必等待脚本下载完成。脚本下载完成后将尽快执行，但具体执行时间取决于脚本下载速度和文档解析状态。
   - `async` 属性通常用于那些`不依赖于其他脚本的独立模块`。

   ```html
   <script async src="path/to/script.js"></script>
   ```

2. **defer**

   - 当使用 `defer` 属性时，脚本会被`延迟到整个文档解析完毕后再运行`，但在DOMContentLoaded事件之前执行。
   - 这适用于那些`依赖于DOM`，但不影响DOMContentLoaded事件触发时机的脚本。


```html
<script defer src="path/to/script.js"></script>
```

`DOMContentLoaded` 是一个非常重要的`浏览器事件`，它在 `HTML 文档被完全加载和解析完成后`立即触发，但`不等待样式表`、`图像`和子框架的加载完成。这使得它非常适合初始化 DOM 结构已经完全呈现的情况下的脚本执行。

##### 主要特点

- **快速执行**：相比于 `load` 事件，`DOMContentLoaded` 事件会更早触发，因为它不需要等待所有外部资源如图像或样式表加载完成。
- **`用处`广泛**：这个事件非常适合用来`初始化页面`，例如`添加事件处理器`、`操作DOM`等，因为此时所有的 HTML 元素都已经存在，但没有外部资源的加载延迟。

### 常见用例

- **无依赖脚本:** 使用 `async`，当脚本之间不相互依赖时使用。
- **依赖DOM的脚本:** 使用 `defer`，保证在DOM完全解析之后执行。
- **按顺序执行的多个脚本:** 当脚本需要按照特定顺序执行时，可以使用多个带`defer`属性的脚本，它们将按照在文档中出现的顺序执行。

### 注意点

- 当使用外部脚本时（即指定了 `src` 属性），脚本标签内部的JavaScript代码将被忽略。
- 脚本的加载和执行可能会影响到页面的加载时间，合理使用 `async` 和 `defer` 属性能够显著改善页面加载性能

## 重排和重绘

### 1. 重排（Reflow）

重排，`又称`作`回流`，是`浏览器重新计算页面布局的过程`。当`DOM的变化影响到元素的几何信息`（如宽度、高度、位置等），`浏览器将需要重新计算元素的位置和大小`。重排的`成本较高`，因为它`可能导致整个页面的部分或全部元素的布局更新`。

触发重排的情况包括：

- `添加或删除`可见的DOM元素
- 元素`位置的改变`
- 元素`尺寸的改变（`例如：边距、填充、边框的宽度、宽度和高度等）
- `内容的改变`（例如：文本改变或图片大小调整后）
- `页面渲染初始化`（首次加载）
- `浏览器窗口大小的改变`

### 2. 重绘（Repaint）

重绘是当元素的一些`样式被改变`，但`没有影响到其几何布局`的时，浏览器将重新绘制元素。重绘的`成本比重排要低`，因为不`涉及布局的计算`。

触发重绘的情况包括：

- 改变元素的外观而不影响其布局的样式，如 color, background-color, visibility。

### 3. 优化策略：减少重排和重绘

由于重排通常会引起重绘，但重绘不一定会引起重排，优化策略通常是尽量减少发生这两者的次数和范围：

#### a. 批量修改DOM

避免逐条更改样式，这样每改一次就可能触发一次重排/重绘。可以使用CSS类或者`DocumentFragment`进行一次性修改。

#### b. 离线操作DOM

操作离线DOM（即那些不在文档流中的DOM节点）。例如，可以先将元素隐藏（例如设为`display: none`），进行多项修改，然后再显示。

#### c. 使用CSS3动画

对于动画效果，使用CSS3的`transform` 和 `opacity` 属性，这些动画可以由`GPU加速`，而非CPU处理。

#### d. 避免触发同步布局事件

避免使用那些在`执行时`需要`立即计算布局的属性或方法`，如`offsetWidth` `scrollHeight`等。

#### e. 减少对复杂选择器或通配符的使用

CSS选择器解析通常从右向左进行。避免过度使用复杂选择器，特别是在关键的性能时刻。

## **异步编程（Promises, Async/Await）：**

- 这不是新开线程，但是处理异步操作（如网络请求，文件读写等）时，JavaScript的执行模型（事件循环和消息队列）让`代码可以异步执行`，而`不阻塞主线程`。

## web worker有哪些限制,与主线程怎么通信

Web Workers 是 HTML5 引入的一项重要特性，它`允许网页在后台运行脚本`，而`不会影响页面的性能`。以下是关于 Web Workers 的详细解释：

1. 定义： Web Workers 是`在后台运行的 JavaScript 脚本`，`独立于网页的主线程`。
2. 主要目的：
   - 执行耗时的计算任务而不阻塞用户界面。
   - 提高 Web 应用的响应性和性能。

Web Workers 提供了在`后台线程中执行脚本的能力`，但他们的运行环境与主线程有显著不同，因此存在以下限制：

1. **`无法访问DOM`**： Web Workers无法直接操作DOM。任何涉及到更新界面的操作都需要主线程来执行。
2. **有限的全局对象**： Workers 运行在一个`独立的全局上下文中`，不是标准的`window`对象，而是一个类型为`DedicatedWorkerGlobalScope`的对象。这意味着，一些常用的`window`方法和属性在Workers中不可用。
3. **`文件限制`**： Workers 中`无法访问本地文件系统`，因为这会造成安全问题。
4. worker文件不能是本地文件，必须是网络上的同源文件
5. **有限的API支持**： 不是所有 Web API 都在 Workers 中可用。虽然能使用例如 `fetch` 这样的网络请求API，但很多与用户界面交互密切的API，如 `window.alert` 或 `document.getElementById` 等，都不能在 Worker 中使用。
6. **内存使用**： 每个 `Worker 都占用额外的内存资源`。因此，虽然可以创建多个 Workers 并行处理任务，但这可能会`影响总体应用性能`。
7. **通信成本**： Worker 与主线程之间的`通信是通过传递消息实现`的，这些消息在传递过程中会被序列化和反序列化，如果消息内容很大，这一过程可能会`导致不小的性能开销`。

### 与主线程的通信方式

Web Workers 与主线程之间的通信是通过消息传递机制实现的。主线程和 Worker 都使用 `postMessage()` 方法来发送数据，使用 `onmessage` 事件处理器来接收数据。

## 什么是同源策略,怎么解决跨域,cors有哪些配置

### 同源策略（Same-origin policy）

同源策略是一种重要的安全策略，用于限制一个origin（源）的文档或脚本如何与另一个源的资源进行交互。它帮助`防止恶意文档`，`降低可能攻击`。如果两个URL的`协议`、`端口`（如果有指定）和`主机`都相同，则两个URL是同源的。

#### 同源策略限制内容包括：

- **`Cookie`、`LocalStorage` 和 `IndexDB` 的`访问权限`**
- **`DOM 的访问权限`**
- **`通过AJAX发起跨源HTTP请求`**

### 解决跨域问题

跨域资源共享（CORS，Cross-Origin Resource Sharing）是一种机制，它`使用额外的HTTP头`部`让浏览器获得访问跨源服务器资源的权限`，从而克服AJAX直接对跨源服务器进行访问的限制。

#### 实现 CORS 主要有以下几种方法：

1. **CORS 响应头部配置**：` 服务端`可以在返回的响应中`添加CORS相关的HTTP头部`，以允许特定的外部域访问资源。
2. **JSONP（只支持GET请求）**： 通过`<script>标签`的特性（`不受同源策略限制`）来绕过限制。服务器端需要支持JSONP调用方式，返回数据时，`将数据包裹在一个函数调用中`。
3. **代理服务器**： 在`服务器端`设置一个`代理服务`（Proxy），该服务请求外部资源并将资源转发给前端。这种方式不受同源策略限制，因为`实际上是在同源中请求`。

### CORS 的主要配置头部

1. **`Access-Control-Allow-Origin`**： 指定哪些网站可以访问资源，可以设置为一个具体的URI或者“*”表示允许所有域名。

   示例：`Access-Control-Allow-Origin: https://example.com`

2. **`Access-Control-Allow-Methods`**： 指明实际请求所允许使用的HTTP方法（如GET, POST, PUT, DELETE, OPTIONS等）。

   示例：`Access-Control-Allow-Methods: GET, POST`

3. **`Access-Control-Allow-Headers`**： 用于预检请求中，服务端返回表示哪些HTTP头部可以被外部域的请求使用。

   示例：`Access-Control-Allow-Headers: X-Custom-Header, Upgrade-Insecure-Requests`

4. **`Access-Control-Allow-Credentials`**： 标志着实际的请求中是否可以携带凭证（cookies）。如果服务端表明“true”，则表示外部域的请求可以附带cookies等凭证信息。

   示例：`Access-Control-Allow-Credentials: true`

5. **`Access-Control-Max-Age`**： 表明了preflight请求的结果（即Access-Control-Allow-Methods和Access-Control-Allow-Headers提供的信息）可以被缓存多久。

   示例：`Access-Control-Max-Age: 86400`

## js数据类型,栈和堆的区别

### JavaScript 数据类型

在 JavaScript 中，数据类型分为两大类：**原始类型**和**引用类型**。

#### 原始类型（Primitive types）

这些类型的数据直接存储在栈（stack）中，它们的值直接存储在变量访问的位置。这些类型包括：

1. **Number**: 包括整数和浮点数。
2. **String**: 文本数据，用单引号、双引号或反引号表示。
3. **Boolean**: 布尔值，`true` 或 `false`。
4. **undefined**: 表示变量声明了但未初始化。
5. **null**: 表示变量已声明，且赋值为“空”（无值）。
6. **Symbol**: 一种实例是唯一且不可更改的数据类型，用于创建对象的私有成员。
7. **BigInt**: 用来表示非常大的整数，超过 `Number` 类型能表示的范围。

#### 引用类型（Reference types）

`引用类型`的数据被存储在`堆`（heap）中。`变量存储在栈中的值`是一个`指向堆内存中实际数据的指针`。

- Object

  : 包括如下几种具体对象：

  - **Array**: 数组对象。
  - **Function**: 函数。
  - **Date**: 日期。
  - **RegExp**: 正则表达式。
  - 各种构造函数创建的对象，如 `new Number()`、`new String()` 等。

### 栈（Stack）与堆（Heap）的区别

栈和堆都是在计算机内存中用于`存储数据的结构`，但它们的管理方式和目的有所不同。

#### 栈

- **存储结构**：栈用于`存储局部变量和函数调用`。
- **内存管理**：栈有`自动管理`机制，即`自动分配内存`并在不需要时`自动释放`。
- **存储方式**：`先进后出`（FILO）的方式。
- **大小和效率**：栈的运行`效率很高`但可用`空间`通常`较小`，且`大小固定`。
- **数据访问**：由于栈对`数据的操作仅限于栈顶`，对数据的`操作速度非常快`。
- **适用场景**：适用于`存储执行环境`（如函数的`局部变量`）等`较小`的、`临时`的数据。

#### 堆

- **存储结构**：堆用来`存储实例化的对象`和`数组`等。
- **内存管理**：堆内存由开发者`手动分配和释放`，管理不当`容易产生内存泄漏`。
- **存储方式**：在`内存中动态分配`，无固定顺序。
- **大小和效率**：`堆的大小不固定`，`扩展灵活`，但`管理和访问速度相比栈要慢`。
- **数据访问**：可以随机访问，但`速度比栈慢`。
- **适用场景**：适用于`存储较大的`、`生命周期长的数据`，或者是在需要全局访问的数据。

总结而言，`栈` `内存` `由系统自动分配释放`，拥有`快速的存取速度`，但`空间有限`；而`堆内存空间大`、`灵活`、由程序员控制，`但速度慢且容易出现内存泄露的风`险。在 JavaScript 中，`简单的数据类型（如数字、布尔值和字符串）通常存储在栈中`，而`对象和数组等复杂类型则存储在堆中`。

## js的堆栈，引用类型基本类型分别在什么内存，有没有大小限制

JavaScript 的内存管理涉及堆（Heap）和栈（Stack）两种主要的内存空间。基本类型和引用类型的存储方式不同，它们在内存中的位置和管理方式也有所区别。让我们详细探讨这个问题：

1. 栈内存（Stack）：

   - 用途：存储基本类型数据和指向引用类型数据的指针。
   - 特点：
     - 空间较小，但访问速度快。
     - 按值存储，按值访问。
     - 遵循后进先出（LIFO）的原则。
   - 存储内容：
     - 基本类型：number, string, boolean, null, undefined, symbol, bigint
     - 引用类型的指针

2. 堆内存（Heap）：

   - 用途：存储引用类型数据的实际内容。
   - 特点：
     - 空间较大，但访问速度相对较慢。
     - 存储复杂对象，如数组、对象等。
   - 存储内容：
     - 引用类型：Object, Array, Function, Date等

3. 基本类型和引用类型的存储：

   - 基本类型：直接存储在栈中。
   - 引用类型：
     - 实际数据存储在堆中。
     - 栈中存储指向堆中数据的指针。

4. 内存大小限制：

   - 栈内存：
     - 通常有固定大小限制，具体取决于JavaScript引擎实现。
     - 例如，在V8引擎中，默认栈大小约为984KB。
   - 堆内存：
     - 理论上可以动态增长，但实际上受到系统可用内存的限制。
     - 在浏览器环境中，通常限制在1.4GB左右（32位系统）或约2GB（64位系统）。
     - 在Node.js中，默认限制约为1.4GB，但可以通过启动参数调整。

5. 具体限制因素：

   - 操作系统：不同操作系统对进程的内存分配有不同限制。
   - 硬件：物理内存大小影响可用内存。
   - JavaScript引擎：不同引擎可能有不同的内存管理策略。
   - 运行环境：浏览器和Node.js等环境可能有不同的内存限制。

6. 内存管理：

   - 基本类型：当超出作用域时，会自动从栈中移除。
   - 引用类型：通过垃圾回收机制管理，当没有引用指向堆中的对象时，该对象会被回收。

7. 注意事项：

   - 大量小的基本类型数据也可能导致栈溢出。
   - 复杂的递归函数可能导致栈溢出。
   - 创建过多或过大的对象可能导致堆内存不足。

8. 性能考虑：

   - 访问栈内存通常比访问堆内存更快。
   - 频繁创建和销毁大量小对象可能影响性能，因为涉及堆内存分配和垃圾回收。

## 垃圾回收机制

### 垃圾回收的关键概念

#### 1. 标记-清除（Mark-and-Sweep）

这是 JavaScript 最常用的垃圾回收机制。其核心原则包括：

- **标记阶段**：垃圾回收器遍历所有从根（通常是全局对象和当前执行栈的活动对象）开始`可到达`的对象，并`标记`它们。
- **清除阶段**：所有`未被标记`的对象将被视为不再需要，因此将被垃圾回收器`清除`。这些空间随后被释放出来，以供未来使用。

#### 2. 引用计数

这是一个较为`早期`的垃圾回收策略，它跟踪`每个值被引用的次数`。当一个对象的引用次数变为零时，表示该对象不再需要，因此可以被清理。然而，此方法的一个主要问题是循环引用，它可能导致内存泄露。

### 现代浏览器的优化策略

现代浏览器的 JavaScript 引擎，如 V8（Chrome 和 Node.js）、SpiderMonkey（Firefox）和 Chakra（Microsoft Edge 旧版）等，都实现了更先进的垃圾回收技术。

#### 分代回收

现代垃圾回收器通常将`内存分成几个不同的“代”或区域`，通常至少分为“`新生代`”和“`老生代`”：

- **新生代**：存储`生命周期较短`的对象。这些对象通常很快被创建和销毁。`回收器经常检查`这个区域，使用算法（如复制垃圾回收器）快速回收。
- **老生代**：存储`生命周期长或持续存活的对象`。这些区域的回收频率较低，使用算法（如标记-清除或标记-整理）。

#### 增量收集

为了避免在垃圾回收时发生长时间的停顿，一些现代垃圾回收机制采用了增量收集技术，即将垃圾回收工作分成多个小部分进行，分散回收的负担。

#### 并发和并行垃圾回收

并发垃圾回收允许垃圾回收器在执行 JavaScript 程序的同时运行，减少对程序执行的干承，而并行垃圾回收则是利用多核处理器同时进行垃圾回收的处理，以提高效率。

## 浏览器和node环境的事件循环

### 浏览器的事件循环

在浏览器中，事件循环的职责是`协调用户交互`、`脚本`、`UI 渲染`和`网络等活动`。浏览器的事件循环机制大致可以描述如下：

1. **任务队列**：浏览器`有多种任务队列`，这些`队列是存储异步事件回调函数的地方`，例如从 `setTimeout`、`setInterval`、用户互动（如点击、滚动等）、`Promise 的解决或拒绝`等。
2. **微任务队列**：JavaScript 还有一种特殊的任务队列，叫作微任务（microtask）队列，用于处理如 `Promise 回调`和 `MutationObserver` 回调等。

`MutationObserver`是一个强大的` Web API`，用于`监测DOM`（Document Object Model）`树中的变化`

1. **执行流程**：
   - `执行栈中的同步代码首先执行`。
   - `执行完同步代码后`，`执行微任务队列中的任务`。
   - `必要时进行渲染更新`（`通常按照浏览器的刷新率`定时进行，例如 60Hz 的频率）。
   - 从`宏任务`（macro task）`队列中取出一个`任务执行。
   - `执行完一个宏任务后`，再次`执行所有可用的微任务`。
   - 重复上述流程。
2. **渲染和任务的优先级**：浏览器需要在执行 JavaScript 和渲染页面之间保持平衡，因此``通常会在宏任务执行完毕后``，以及`执行微任务之后`，`检查是否需要重新渲染页面`。

### Node.js 的事件循环

Node.js 的事件循环由其底层的 libuv 库提供支持。Node.js 的事件循环与浏览器略有不同，主要是针对服务器环境优化的。其事件循环包括以下几个主要阶段：

1. **定时器**：处理 setTimeout 和 setInterval 所调度的回调。
2. **I/O 回调**：处理几乎所有的 I/O 回调，如网络通信、文件操作等（除了由其他阶段处理的特定活动）。
3. **空闲和预备**：仅内部使用。
4. **轮询**：检索新的 I/O 事件；执行与 I/O 相关的回调（几乎除了关闭的回调，所有回调都在这里被执行），轮询队列如果为空，可能会导致事件循环阻塞等待新的回调。
5. **检查**：`setImmediate()` 回调在这里执行。
6. **关闭的回调函数**：一些关闭的回调函数，如 `socket.on('close', ...)`。

在每个阶段之间，Node.js 也会处理微任务队列。与浏览器不同，Node.js 可能会在任何阶段结束后处理所有可用微任务。

## 任务队列，setTimeout底层如何实现的？nextTick是宏任务还是微任务，使用场景是什么，你知道的微任务都有什么

JavaScript 是单线程运行的，依赖于事件循环（Event Loop）来处理异步任务。任务队列、定时器（如 `setTimeout`）、和微任务（如 `process.nextTick`、`Promise` 等）都是事件循环的一部分。让我们逐一探讨这些概念。

### 任务队列

任务队列（或称任务调度机制）是 JavaScript 运行环境（如浏览器或 Node.js）用来管理异步任务的集合。任务被分为两类：

1. **宏任务（macro task）**：一般指的是通过事件循环调度的任务，如 I/O 操作、定时器等。
2. **微任务（micro task）**：更细粒度的任务，通常在当前事件循环结束之前立即执行，如 `Promise` 回调。



### `setTimeout` 底层实现

`setTimeout` 是浏览器和 Node.js 中用于设置定时器的 API，底层实现依赖于系统计时器。

1. **定时器注册**：当调用 `setTimeout` 时，定时器会被注册到浏览器或 Node.js 的计时器系统中。
   
    ```javascript
    setTimeout(() => { console.log('Executed after 1 second'); }, 1000);
    ```

2. **事件循环检查**：事件循环会定期检查所有注册的定时器，查看是否有定时器到期。
3. **宏任务队列**：一旦定时器到期，回调会被放入宏任务队列中，等待事件循环处理。
4. **执行回调**：当事件循环执行完当前任务并检查微任务队列后，从宏任务队列中取出定时器回调并执行。

### `nextTick` 是宏任务还是微任务？

`process.nextTick`（仅在 Node.js 中可用）将任务添加到当前事件循环的下一次迭代之前，即在所有其他微任务之前执行。严格来说，它是一个“微任务”。

**使用场景**：
`process.nextTick` 适用于在当前执行栈结束后立即执行某些操作，而不等待下一个事件循环。

### 常见的微任务

微任务通常用于需要快速在当前执行栈之后执行、且优先级较高的操作。以下是一些常见的微任务：

1. **`Promise` 回调**：当一个 `Promise` 被解决（resolved）或者被拒绝（rejected）时，它的回调会被放入微任务队列中。

    ```javascript
    Promise.resolve().then(() => {
      console.log('Promise resolved');
    });
    ```

2. **`MutationObserver`**：DOM 变化观察者，用于监听 DOM 变化。

    ```javascript
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log('DOM changed');
      });
    });

    observer.observe(targetNode, { attributes: true });
    ```

3. **`queueMicrotask`**：直接将函数添加到微任务队列中。在现代浏览器和 Node.js 中均可用。

    ```javascript
    queueMicrotask(() => {
      console.log('Microtask executed');
    });
    ```

4. **Node.js 中的 `process.nextTick`**：

    ```javascript
    process.nextTick(() => {
      console.log('Next tick callback');
    });
    ```

### 微任务使用场景

- **快速响应**：因为微任务会在当前事件循环结束之前执行，所以它们适用于需要快速响应和更新状态的操作。
- **保证顺序**：当你需要确保一些操作在事件循环的特定点之后立即执行，且在其他任何新的宏任务之前执行时，使用微任务（如 `Promise`、`process.nextTick`）。
- **改善性能**：由于微任务是在当前事件循环末尾执行，所以它们帮助减轻不必要的事件循环等待，改善性能。

总结来说，理解微任务和宏任务的区别，以及如何合理使用它们优化性能和用户体验，是高级 JavaScript 开发的关键技巧。

## flat拍平数组，循环依赖怎么办

在 JavaScript 中, `Array.prototype.flat()` 方法用于将多维数组转换为低维数组。例如，`[[1, 2], [3, [4, 5]]].flat()` 将返回 `[1, 2, 3, 4, 5]`。

### 循环依赖与`flat`方法

首先，我们需要明确一点，通常所说的“循环依赖”是指在模块、对象或函数之间的引用问题，通常不直接涉及到数组操作。然而，如果你的问题指的是在使用 `flat` 方法的时候数组中存在相互引用（例如，数组A包含数组B，数组B中又包含数组A），这种情况极为少见，且 `flat` 方法本身不支持处理包含循环引用的数组。这是因为 `flat` 方法设计来平铺数组，不是解决引用或内存管理问题。

尝试对包含循环引用的数组使用 `flat()` 方法会导致问题，因为`flat()`在尝试访问无限递归的结构时会导致堆栈溢出错误。

### 示例模拟循环引用数组

假设你不小心创建了一个包含循环引用的数组结构：

```javascript
let a = [];
let b = [a];
a.push(b);

// 尝试 flatten 会怎样？
// a.flat(); // 这将抛出 RangeError: Maximum call stack size exceeded
```

### 如何处理或防止循环引用

由于 JavaScript 中通常不推荐在数组中创建循环依赖（这是不良的设计），如果你确实遇到了这种需求，需要反思为何会设计出这种结构，并考虑进行重构。

1. **重构数据结构**：最好的方法是避免在数组中创建循环引用。通常，循环引用是设计不当的标志。尝试重构数据模型以去除这种依赖。
2. **自定义 flatten 函数**：如果出于某种特殊原因必须处理循环引用数组，你可以编写一个自定义的 flatten 函数，这个函数在工作前先检测数组中的循环引用。

### 实现一个简单的检测循环依赖的 flatten 函数

以下是一个自定义的 `flatten` 方法实现，可以检查循环引用并抛出错误：

```javascript
function safeFlatten(array, parentArrays = []) {
    let result = [];
    for (const item of array) {
        if (Array.isArray(item)) {
            if (parentArrays.includes(item)) {
                throw new Error("Detected a cycle in the array");
            }
            parentArrays.push(item);
            result = result.concat(safeFlatten(item, parentArrays));
            parentArrays.pop();
        } else {
            result.push(item);
        }
    }
    return result;
}

let a = [];
let b = [a];
a.push(b);

try {
    console.log(safeFlatten(a)); // This will throw an error
} catch (e) {
    console.error(e); // Detected a cycle in the array
}
```

在这个例子中，`safeFlatten` 功能检查 `item` 是否已经在 `parentArrays` 中，这可以帮助检浔循环引用并避免无限递归。

## BFC

BFC（Block Formatting Context，`块级格式化上下文`）是Web页面的可视化CSS渲染的一部分，它是页面上的一个隔离的渲染区域，`容器里面的元素不会在布局上影响到外面的元素`。简单地说，它是一个独立的布局环境。

### BFC的工作原理

BFC规定了内部的Block Box如何布置，并且与这个区域外部毫无关系。

### 如何形成BFC

一个HTML容器会变成BFC当它符合以下条件之一：

1. `float` 的值不为 `none`。
2. `position` 的值不为 `static` 或 `relative`。
3. `display` 的值为 `inline-block`, `table-cell`, `table-caption`, `flex`, `grid` 等。
4. `overflow` 的值不为 `visible`。

### BFC的主要用途

BFC 提供了几个重要的功能，或者可以用来解决常见的问题：

1. **`防止外边距合并`**（Margin Collapsing）： 在同一个BFC中的两个相邻块级元素的垂直间距会合并成一个间距，这通常不是我们想要的。通过`将其中一个元素放入不同的BFC中可以避免这种情况`。
2. **包含浮动元素**（Clearing Floats）：` 浮动元素不影响其父容器的高度`，`因为浮动元素不在流中`。通常，这会`导致父容器的高度塌陷`。`如果父容器创建了自己的BFC`，那么`就会包含它的浮动子元素`，父容器的`高度就能正常计算了`。
3. **创建独立的渲染区域**： 在`BFC中的布局不会影响外面的元素`，反之亦然。这对于布局非常有用，特别是在复村的网页设计中。
4. **防止文本环绕**： 当你`不希望文本环绕另一元素时`，可以使用BFC来避免。

### 实例应用

这是一个防止外边距合并的例子：

```html
<!-- 没有防止外边距合并的情况 -->
<div style="background-color: lightblue; margin-bottom: 20px;">Box 1</div>
<div style="background-color: lightcoral;">Box 2</div>
<!-- Box 1和Box 2的间隔看起来会是20px，实际上他们各有20px的margin, 但是合并了 -->

<!-- 使用BFC阻止外边距合并 -->
<div style="background-color: lightblue; overflow: hidden; margin-bottom: 20px;">Box 1</div>
<div style="background=""color:: lightcoral;">Box 2</div>
<!-- Box 1 和 Box 2 的间隔为40px -->
```

在这个例子中，第一种情况没有启用BFC，所以两个盒子的外边距合并导致看起来只有20px的间隔。在第二种情况中，通过`overflow: hidden`给`Box 1`创建了BFC，从而阻止了外边距合并，使两个盒子之间的间隔正确地显示为40px。

## 函数式编程思想

### 核心思想：

1.   `函数是一等公民`：`函数可以像其他数据类型一样被创建`，`传递`，`返回`和`存储`
2.   `不可变性`：`函数及其输入输出数据应当是不可变的`，一旦被创建就不可改变
3.   `纯函数`：`函数应当只依赖于其输入的数据`，并且`不修改外部状态`（`没有副作用`）
4.   `递归`
5.   `高阶函数`：高阶函数可以接收其他函数作为参数或者返回参数作为结果，使得函数可以像数据一样被操作

函数式编程（Functional Programming, FP）是一种编程范式，它把计算视为函数的评估，并尽可能避免使用状态和可变数据。在函数式编程中，函数本身可以像任何其他数据类型一样被传递和操作，这使得这种编程范式与传统的命令式和过程式编程有很大的不同。

### 函数式编程的关键思想和特性包括：

1. **不可变性 (Immutability)**： 函数式编程强调数据不可变性。一旦数据被创建，就不能改变。如果需要修改数据，你就创建一个新的数据副本并应用更改，而不是更改原始数据。
2. **纯函数 (Pure Functions)**： 纯函数对于相同的输入总是产生相同的输出，并且它们不会产生任何可观察的副作用（如修改全局变量、改变输入参数的状态等）。这使得程序更容易理解和预测。
3. **函数是"一级公民" (First-class Functions)**： 函数被视为一级公民，这意味着它们可以存储在数据结构中，可以作为参数传递给其他函数，还可以作为其他函数的返回值。
4. **高阶函数 (Higher-order Functions)**： 这是接收其他函数作为参数或将其他函数作为输出返回的函数。高阶函数是建立在把函数当做一级公民的概念之上的，是函数式编程中非常重要的一个概念。
5. **引用透明性 (Referential Transparency)**： 任何函数调用都可以被其输出值替换，而不会改变程序的行为。这是纯函数的一个直接结果，使得程序更易于推理。
6. **递归 (Recursion)**： 在函数式编程中，循环操作通常会通过递归来实现。这是因为递归调用自身的函数不需要改变状态，而是通过返回值来处理数据，这与函数式编程的纯净性和不可变性相符合。
7. **延迟计算 (Lazy Evaluation)**： 函数式编程语言经常支持延迟计算，意味着计算延迟到绝对需要结果的那一刻。这种特性可以提升性能，允许无限数据结构，如无限列表。

### 函数式编程的优势：

- **可测试性和可维护性**：由于使用纯函数，组件和系统更易于测试和维护。
- **并行处理**：不可变性简化了并行代码的开发，因为没有状态变化，所以不需要担心线程安全问题。
- **模块化和可复用性**：纯函数的自包含性和一致性使得复用更加简单。

## ES6新特性

### 1. `let` 和 `const`

ES6引入了两个新的声明变量的关键字：`let`和`const`，它们提供块级作用域（block-scoping），而传统的`var`声明只提供函数级作用域。`let` 用于声明变量，而 `const` 用于声明常量。

```javascript
if (true) {
    let a = 40;
    const b = 50; // b cannot be re-assigned
}
// a 和 b 在此处均不可访问
```

### 2. 箭头函数

箭头函数提供了另一种定义函数的方式，使用 `=>` 符号。它不仅语法简洁，还自动绑定当前的上下文(`this`关键字)。

```javascript
const add = (a, b) => a + b;
```

### 3. 模板字符串

ES6允许字符串嵌入变量和表达式，使用反引号（``\`）标示，变量和表达式放在`${}`中。

```javascript
let name = "world";
console.log(`Hello, ${name}!`); // 输出：Hello, world!
```

### 4. 默认参数

函数参数现在可以有默认值。

```javascript
function log(message = "Default message") {
    console.log(message);
}
log(); // 输出：Default message
```

### 5. 解构赋值

解构赋值允许从数组或对象中提取值，并赋值给通过模式匹配定义的变量。

```javascript
let [a, b] = [1, 2];
let {name, age} = {name: "Alice", age: 25};
```

### 6. 模块

ES6原生支持模块（module），使用`import`和`export`语句加载和导出模块。

```javascript
// file1.js
export const pi = 3.14159;

// file2.js
import { pi } from './file1';
console.log(pi); // 输出：3.14159
```

### 7. 类

ES6引入了基于类的面向对象编程，支持类的声明以及继承。

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}
```

### 8. Promises

Promises是异步编程的一种解决方案，用于处理异步操作，避免回调地狱。

```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, 'Some Value');
});
promise.then(value => console.log(value));
```

### 9. 新的集合类型

引入了`Map`, `Set`, `WeakMap`,和`WeakSet`等新数据结构。

### 10. 迭代器和for...of循环

ES6引入了迭代器(iterator)和可迭代协议，以及新的`for...of`循环，用来有效遍历数据集。

```javascript
let arr = [10, 20, 30];
for (let value of arr) {
  console.log(value); // 输出：10, 20, 30
}
```

### 11. Symbol

引入了一种新的原始数据类型`Symbol`，它是唯一不变的。

## axios的请求拦截和响应拦截底层实现原理

`axios` 的拦截器执行流程是通过一个基于 Promise 的链式结构实现的。具体步骤如下：

1. 创建拦截器链

   axios 内部为每个请求创建一个拦截器链。链的结构如下：

   - [请求拦截器1, 请求拦截器2, ..., 实际请求发送函数, 响应拦截器2, 响应拦截器1]

2. **执行链式调用**：`axios` 通过` Promise 链式调用执行上述拦截器链`。首先`按顺序执行所有请求拦截器，`然`后发送实际请求`，最后按逆序执行所有响应拦截器。

## 请求接口错误，即状态码非200的请求错误怎么捕获

在前端开发中，有多种方法可以捕获非 200 状态码的请求错误。以下是几种常见的方法：

1. 使用 fetch API：

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => {
    console.error('There was a problem with the fetch operation:', error);
  });
```

2. 使用 axios：

```javascript
axios.get('https://api.example.com/data')
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    if (error.response) {
      // 请求已发出，但服务器响应的状态码不在 2xx 范围内
      console.error('Error status:', error.response.status);
      console.error('Error data:', error.response.data);
    } else if (error.request) {
      // 请求已发出，但没有收到响应
      console.error('No response received:', error.request);
    } else {
      // 设置请求时发生了一些错误
      console.error('Error message:', error.message);
    }
  });
```

3. 使用 async/await 和 try/catch：

```javascript
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('There was a problem with the fetch operation:', error);
  }
}

fetchData();
```

4. 使用 XMLHttpRequest：

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);

xhr.onload = function() {
  if (xhr.status >= 200 && xhr.status < 300) {
    console.log(JSON.parse(xhr.responseText));
  } else {
    console.error('The request failed with status:', xhr.status);
  }
};

xhr.onerror = function() {
  console.error('There was a network error.');
};

xhr.send();
```



这些方法都能帮助你捕获非 200 状态码的请求错误。选择哪种方法取决于你的项目需求和使用的技术栈。

## 强制缓存和协商缓存使用场景是什么

### 强制缓存

`强制缓存`（也称为绝对缓存）`指的是客户端在设定的缓存时间内`，`不再向服务器发送请求`，而是`直接使用本地缓存的数据`。这种方式依赖于 HTTP 响应头中的 `Cache-Control` 和 `Expires` 字段。

#### 使用场景

1. **静态资源**：如图片、CSS、JavaScript 文件等，尤其是那些很少更改的资源。
2. **版本控制**：如果资源更新频繁但可以通过版本号来区分，强制缓存是非常适合的。例如，通过给文件名添加哈希值（如 `style.abcdef.css`），确保每次发布新版本时都会生成新的文件名。
3. **提升性能**：在`用户访问频繁的页面中使用强制缓存`，可以`减少重复请求`，提升加载速度。

#### 配置示例

```http
Cache-Control: max-age=31536000  // 设置缓存时间为一年
Expires: Thu, 01 Dec 2022 16:00:00 GMT  // 设置具体的过期时间
```

### 协商缓存

协商缓存指的是客户端`每次请求资源时`，都会`向服务器发送一个验证请求`，以`确定缓存的数据是否过期`。如果`未过期`，`服务器会返回304`状态码，`表示可以使用本地缓存`，`否则返回新的资源`。协商缓存依赖于 HTTP 响应头中的 `Last-Modified` 和 `ETag` 字段。

#### 使用场景

1. **动态内容**：如`新闻页面`、用户数据等，内容可能会不定期更新。
2. **大文件**：如视频、文档等，频繁重新下载成本较高，但又需要保证内容是最新的。
3. **频繁更新资源**：资源更新频率高，且需要确保用户始终获得最新的版本。

#### 配置示例

```http
Last-Modified: Tue, 15 Nov 2022 12:45:26 GMT  // 资源的最后修改时间
ETag: "abc123"  // 资源的唯一标识符
```

### 工作流程

1. **首次请求**：服务器返回资源并包含 `Last-Modified` 或 `ETag` 头。
2. **后续请求**：客户端发送带有 `If-Modified-Since` 或 `If-None-Match` 头的请求。
3. **验证**：服务器根据头信息验证资源是否修改，未修改返回 304 状态码，否则返回新的资源和新的 `Last-Modified` 或 `ETag`。

### 总结

- **强制缓存** 适用于`更新频率低`、可以`通过版本控制的静态资源`，能够显著减少请求数量，提高性能。
- **协商缓存** 适用于`内容更新频率较高`、需要`确保用户获取最新数据的场`景，通过与服务器协商，减少不必要的资源传输。

选择适当的缓存策略可以在提升性能的同时，确保数据的准确性和及时性。

## 打包工具打包后的文件名上的hash值根据不同场景应该怎么设置，有什么说法

这个概念可能有些误解。让我澄清一下：

1. Hash 值的作用：
   - 这里的 hash 值不是发送给服务器的，而是`用于浏览器缓存控制`。
   - 它是`打包工具（如 Webpack）在构建过程中生成`的，作为文件名的一部分。

2. 工作原理：
   - 当你的`代码或资源发生变化`时，`打包工具会生成新的 hash 值`。
   - 这会`导致生成的文件名变化`（例如从 main.123abc.js 变为 main.456def.js）。
   - `浏览器会将这个新文件名视为全新的资源`，从而`请求新文件`。

3. 缓存控制：
   - 如果文件内容没有变化，hash 值保持不变，浏览器可以使用缓存的版本。
   - 当内容变化时，新的 hash 值会强制浏览器下载新版本。

4. 服务器交互：
   - 服务器不需要特别处理这些 hash 值。
   - 它只是简单地提供带有 hash 的文件名的静态文件。

5. 实际应用：
   - 在 HTML 中，你会看到类似 `<script src="main.123abc.js"></script>` 的引用。
   - 这个文件名是在构建过程中生成的，包含了 hash 值。

总之，这些 hash 值是用于前端资源的版本控制和缓存管理，而不是发送给服务器的数据。它们帮助浏览器确定是否需要下载新版本的资源，从而优化加载性能和缓存策略。

###  静态资源（JavaScript、CSS、图片等）

#### 场景

这些资源通常会在用户的浏览器中缓存，若文件内容发生变化，希望用户获取到最新的文件，而不变的文件继续使用缓存。

#### 设置

- **内容哈希值（Content Hash）**：`根据文件内容生成哈希值`，当文件内容改变时，哈希值才会变化。
- **文件名格式**：`[name].[contenthash].[ext]` 或 `[name].[hash].[ext]`

### 动态加载的模块（Code Splitting）

#### 场景

通过代码拆分实现按需加载，不同的代码块可能会频繁更新，因此需要确保每个代码块的缓存管理。

#### 设置

- **内容哈希值（Content Hash）**：适用于动态加载的代码块，确保`每个块在内容变化时对应的哈希值变化。`
- **文件名格式**：`[name].[contenthash].js`

### 库文件（第三方库）

#### 场景

第三方库文件`较为稳定`，`不会频繁更新`，`可以考虑较长时间的缓存`。

#### 设置

- **哈希值（Hash）**：可以使用`版本号或内容哈希`，保证在库文件更新时哈希值变化。
- **文件名格式**：`[name].[hash].js` 或 `[name].[version].js`

**内容哈希值（Content Hash）**：适用于`内容频繁变化的文件`，如 JavaScript、CSS、图片等。

**哈希值（Hash）**：适用于`版本管理`，文件内容相对稳定的场景。

**文件名格式**：`[name].[contenthash].[ext]` 或 `chunkFilename` 根据文件类型和使用场景选择适当的哈希策略。



## css选择器优先级

CSS选择器的优先级是决定哪个样式规则最终应用于元素的重要因素。理解选择器优先级可以帮助你更好地控制和预测样式的应用。以下是CSS选择器优先级的详细解释：

1. 优先级层级（从高到低）：

   a) `!important` b)` 内联样式` c)` ID`选择器 d) `类`选择器、`属性`选择器、`伪类` e) `元素`选择器、`伪元素 `f) `通用`选择器(*)

2. 优先级计算：

   - 内联样式：1000分
   - 每个ID选择器：100分
   - 每个类选择器、属性选择器或伪类：10分
   - 每个元素选择器或伪元素：1分

3. 具体规则：

   a) !important 声明总是最高优先级 b) 如果优先级相同，后面的规则会覆盖前面的规则 c) 继承的样式优先级最低

4. 示例：

   ```css
   #header .nav li:first-child {}  /* 优先级：100 + 10 + 1 + 10 = 121 */
   nav#navbar ul.menu li.active {} /* 优先级：100 + 1 + 10 + 1 + 10 = 122 */
   body .content .section h1 {}    /* 优先级：1 + 10 + 10 + 1 = 22 */
   ```

5. 特殊情况：

   - 通用选择器(*)、组合器（+, >, ~, ' '）和否定伪类(:not())对优先级没有影响
   - :not()的内容会影响优先级

6. 最佳实践：

   - 避免过度使用!important
   - 尽量使用类选择器，避免ID选择器
   - 保持选择器简洁，避免过长的选择器链

7. 优先级相等时：

   如果两个规则的优先级完全相同，那么在样式表中后声明的规则会覆盖先声明的规则。

8. 继承：

   继承的样式没有优先级，总是会被直接指定给元素的任何样式覆盖。

9. 媒体查询：

   媒体查询不会影响选择器的优先级，但可能会改变应用的样式集。

10. 浏览器前缀：

    带有浏览器前缀的属性和没有前缀的属性优先级相同。

## 伪类和伪元素区别

1. 语法差异：

   - 伪类使用单冒号(:)，例如 :hover, :active, :first-child
   - 伪元素在 CSS3 中使用双冒号(::)，例如 ::before, ::after, ::first-line (注：为了向后兼容，很多浏览器也支持伪元素使用单冒号)

2. 作用对象：

   - `伪类`作用于已有`元素的特定状态`
   - `伪元素`创建一个`不存在于文档树中的虚拟元素`

3. 功能：

   - 伪类用于定义元素的特殊状态
   - 伪元素用于创建额外的元素，而不用修改 HTML

4. 常见例子：

   伪类：

   - :hover - 鼠标悬停时的状态
   - :active - 元素被激活（如按下）时的状态
   - :focus - 元素获得焦点时的状态
   - :first-child - 第一个子元素
   - :nth-child(n) - 第 n 个子元素

   伪元素：

   - ::before - 在元素内容之前插入内容
   - ::after - 在元素内容之后插入内容
   - ::first-line - 选择元素的第一行
   - ::first-letter - 选择元素的第一个字母

5. 可用数量：

   - 一个元素可以应用多个伪类
   - 一个元素通常只能应用一个伪元素（::before 和 ::after 除外）

6. 内容生成：

   - 伪类不能用于生成内容
   - 伪元素可以使用 content 属性生成内容

7. CSS 版本：

   - 大多数伪类在 CSS1 和 CSS2 中就已经存在
   - 大多数伪元素是在 CSS3 中引入的

8. 用途：

   - `伪类`主要用于`根据特定状态或关系选择元素`
   - `伪元素`主要用于`添加样式化的内容`或`选择元素的特定部分`

## 关于伪元素是否是 DOM 元素以及能否通过 JS 获取

1. 伪元素不是真正的 DOM 元素：
   - 伪元素是 CSS 创建的虚拟元素，不存在于 DOM 树中。
   - 它们不能通过常规的 DOM 方法直接访问或操作。
2. 通过 JavaScript 获取伪元素：
   - 不能直接通过 DOM 方法（如 getElementById、querySelector 等）获取伪元素。
   - 但可以通过 getComputedStyle() 方法间接访问伪元素的样式。

示例：获取 ::before 伪元素的内容

```javascript
const element = document.querySelector('#myElement');
const style = window.getComputedStyle(element, '::before');
const content = style.getPropertyValue('content');
console.log(content);
```

1. 操作伪元素：

   - 虽然不能直接操作伪元素，但可以通过修改主元素的类或样式来间接影响伪元素。

   ```javascript
   element.style.setProperty('--before-content', '"New content"');
   ```

   CSS:

   ```css
   #myElement::before {
     content: var(--before-content, 'Default content');
   }
   ```

2. 限制：

   - 不能通过 JavaScript 动态创建或删除伪元素。
   - 不能为伪元素添加事件监听器。

总结： 伪元素不是真正的 DOM 元素，不能直接通过 JavaScript 的 DOM 方法获取或操作。但可以通过 getComputedStyle() 方法访问其样式，或通过修改主元素的样式来修改元素类名间接影响元素应用不同的伪元素。

## HTTP不同版本之间的区别

HTTP (超文本传输协议) 的不同版本之间存在一些重要的区别。以下是主要版本之间的主要差异：

1. `HTTP/0.9 (1991)`
   - 极其简单的协议
   - `只支持 GET` 方法
   - `只能传输 HTML `文件
   - `没有 HTTP 头`，`没有状态码`
   - `每`个`请求后关闭连接`
2. `HTTP/1.0 (1996)`
   - 引入了`版本号`概念
   - 增`加了 HEAD 和 POST 方法`
   - 增加了`响应状态码`
   - 引入了` HTTP 头`部概念
   - 支持`多种文件类型传输`
   - 仍然是`非持久`连接（每个请求/响应对都要建立一个新的连接）
3. `HTTP/1.1 `(1997)
   - `默认使用持久连接` (Keep-Alive)
   - 引入管道化技术，允许在同一个连接上发送多个请求
   - 增加了` OPTIONS, PUT, DELETE, TRACE, CONNECT 方法`
   - `引入了主机头 `(Host header)，支持虚拟主机
   - `支持断点续传`，通过 Range 头实现
   - 引入了缓存控制机制
   - 支持压缩传输（如 gzip）
4. `HTTP/2 (2015)`
   - `使用二进制格式传输数`据，而不是文本格式
   - `多路复用`：允许``同时通过单一的 TCP 连接发送多重请求`-响应消息
   - 头部`压缩`：`减少了传输数据的大小`
   - 服务器推送：服务器可以主动向客户端推送资源
   - 请求优先级：允许客户端设置请求的优先级
   - 流量控制
   - 默认使用加密（虽然不是强制的）
5. `HTTP/3 (2022)`
   - 基于 `QUIC 协议`，`而不是 TCP`
   - `改进的多路复用`
   - 连接迁移：网络切换时保持连接
   - 改进的拥塞控制
   - 0-RTT 连接建立：减少了连接建立时间
   - 更好的错误处理和恢复机制
   - `内置加密（TLS 1.3）`

主要改进趋势：

1. 性能提升：从简单的请求-响应模型到复杂的多路复用和服务器推送。
2. 安全性增强：逐渐加强了加密和安全机制。
3. 效率提高：通过头部压缩、持久连接等机制减少数据传输量和延迟。
4. 功能扩展：增加了更多的方法和头部，支持更复杂的web应用场景。
5. 灵活性：从严格的请求-响应模式到更灵活的通信模式。

每个新版本都致力于解决之前版本的限制和问题，以适应不断发展的 Web 技术和用户需求。

## Object和Map的区别

Object 和 Map 都是 JavaScript 中用于存储键值对的数据结构，但它们有一些重要的区别：

1. `键的类型`：
   - Object：`键必须是字符串或 Symbol`。
   - Map：`键可以是任何类型，包括对象、函数`等。
2. `键的顺序`：
   - Object：键的`顺序不保证`（虽然现代浏览器通常会保持插入顺序）。
   - Map：`保证按插入顺序迭代键值对`。
3. 大小：
   - Object：`没有直接获取大小的方法`，需要手动计算。
   - Map：有 `size 属性`，可以直接获取元素数量。
4. 迭代：
   - Object：`需要通过 Object.keys()、Object.values() 或 Object.entries()` 方法来迭代。
   - Map：可以`直接迭代，有 keys()、values() 和 entries()` 方法。
5. 性能：
   - Object：在`少量键值对时表现良好`。
   - Map：在`频繁增删键值对时性能更好`，尤其是处理大量数据时。
6. JSON：
   - Object：`可以直接用 JSON.stringify() 序列化`。
   - Map：`不能直接序列化，需要先转换为普通对象。`
7. 原型链：
   - Object：`有原型`，可能意外包含一些继承的属性。
   - Map：`没有原型，不存在键名冲突问题`。
8. 默认键：
   - Object：`可能包含一些默认的键（如 constructor）`。
   - Map：`只包含显式插入的键。`
9. 计算属性名：
   - Object：`支持在字面量中使用计算属性名`。
   - Map：不支持类似的语法，但可以使用任何值作为键。
10. 使用场景：
    - Object：`适用于简单的键值存储`，特别是当键是预先已知的字符串时。
    - Map：`适用于需要频繁添加/删除键值对`，或键不是字符串类型的场景。

## 原型链

原型链是 JavaScript 中`实现继承的一种机制`。它是`通过对象之间的链接（称为原型）来实现的`。以下是关于原型链的一些重要概念和特点：

1. 原型对象
   - `每个 JavaScript 对象都有一个原型对象`（prototype）。
   - `对象从其原型继承属性和方法`。
2. **proto** 属性
   - `每个对象都有一个内部属性 [[Prototype]]`，在大多数浏览器中可以通过 **proto** 访问。
   - **proto**` 指向该对象的原型对象`。
3. 原型链
   - 当`访问一个对象的属性时`，如果`对象本身没有这个属性`，`JavaScript 会沿着原型链向上查找`。
   - 这个`查找过程会一直持续到找到属性`或`到达原型链的顶端`（通常是 Object.prototype）。
4. Object.prototype
   - `所有普通对象的原型链最终都指向 Object.prototype`。
   - Object.prototype 的 **proto** 是 null，标志着原型链的终点。
5. 构造函数和 prototype
   - `每个函数都有一个 prototype 属性，指向一个对象`。
   - `当函数被用作构造函数时，新创建的对象的 **proto** 会指向构造函数的 prototype`。
6. 继承
   - `通过原型链，对象可以继承其原型对象的属性和方法`。
   - 这允许创建一个对象层次结构，实现代码重用和继承。
7. 属性查找
   - 当访问对象的属性时，JavaScript 首先查找对象自身。
   - 如果没找到，则沿着原型链向上查找，直到找到属性或到达链的末端。
8. 方法覆盖
   - `对象可以定义与其原型同名的属性或方法，从而覆盖原型的实现`。
9. 动态性
   - `原型链是动态的，可以在运行时修改`。
   - `修改原型对象会影响所有继承自该原型的对象`。

## 如何优化解决虚拟滚动中滚速过快情况下的白屏问题

虚拟滚动是一种优化大量数据渲染的技术，但在高速滚动时可能会出现白屏问题。以下是一些优化策略，可以帮助解决或减轻这个问题：

1. `增加缓冲区`（Buffer）
   - 在可`视区域`上下`额外渲染更多的项目`。
   - 这样可以为快速滚动提供缓冲，减少白屏出现的机会。
2. `预加载和预渲染`
   - 预先加载和渲染即将进入视图的数据。
   - 使用 requestIdleCallback 或 Web Workers 在后台处理这些操作。
3. 优化渲染性能
   - 使用 React.memo 或 Vue 的 v-once 指令来避免不必要的重渲染。
   - 考虑使用 CSS containment 来限制布局计算的范围。
4. 实现`平滑滚动`
   - 使用 CSS scroll-behavior: smooth 或 JavaScript 实现平滑滚动。
   - 这可以减缓滚动速度，给渲染留出更多时间。
5. `占位符策略`
   - 在数据加载完成前，使用占位符（如骨架屏）填充空白区域。
   - 这可以提供更好的视觉反馈，减少用户感知的白屏。
6. `滚动节流`
   - 使用节流（throttle）技术限制滚动事件的触发频率。
   - 这可以减少高频滚动时的计算压力。
7. 异步渲染
   - 将渲染过程分解为多个小任务，使用 requestAnimationFrame 进行调度。
   - 这可以防止长时间的渲染阻塞主线程。
8. 使用虚拟化库
   - 考虑使用成熟的虚拟滚动库，如 react-virtualized 或 vue-virtual-scroller。
   - 这些库通常已经实现了许多优化策略。
9. 动态调整渲染项数量
   - 根据滚动速度动态调整渲染的项目数量。
   - 在高速滚动时减少渲染项，滚动变慢时增加。
10. 优化数据结构
    - 使用高效的数据结构来存储和访问列表数据。
    - 考虑使用分段加载或懒加载策略。
11. GPU 加速
    - 利用 CSS 属性如 transform 和 opacity 来触发 GPU 加速。
    - 这可以提高滚动和渲染的性能。
12. 监控和优化
    - 使用性能监控工具来识别瓶颈。
    - 持续监测和优化滚动性能。
13. 考虑使用虚拟滚动和无限滚动的结合
    - 在滚动到底部时动态加载更多数据，而不是一次性加载所有数据。
14. 优化每个列表项的渲染
    - 确保每个列表项的渲染尽可能高效。
    - 避免在列表项中使用复杂的布局或大量的DOM元素。

## 怎么做到组件的按需引入

组件的按需引入是一种优化技术，可以显著减少最终打包文件的大小，提高应用的加载速度。以下是几种实现组件按需引入的方法：

1. ES6 动态导入

使用 `ES6 的动态 import()` 语法可以实现组件的按需加载：

```javascript
const MyComponent = () => import('./MyComponent.vue')

export default {
  components: {
    MyComponent
  }
}
```

1. 使用 Webpack 的 require.ensure

对于较老的项目，可以使用 Webpack 的 require.ensure：

```javascript
require.ensure([], () => {
  const MyComponent = require('./MyComponent.vue')
  // 使用 MyComponent
})
```

1. 使用 Vue 的异步组件

Vue 提供了一种简单的方式来定义异步组件：

```javascript
Vue.component('async-component', () => import('./MyComponent.vue'))
```

1. 使用 Babel 插件

对于一些 UI 库，如 Element UI，可以使用 Babel 插件实现按需引入：

```bash
npm install babel-plugin-component -D
```

然后在 .babelrc 中配置：

```json
{
  "plugins": [
    ["component", {
      "libraryName": "element-ui",
      "styleLibraryName": "theme-chalk"
    }]
  ]
}
```

使用时：

```javascript
import { Button, Select } from 'element-ui'
```

1. 使用 Tree Shaking

确保你的构建工具支持 Tree Shaking（如 Webpack 4+），并且你的代码使用 ES6 模块语法：

```javascript
import { Button } from 'my-ui-library'
```

1. 路由级别的代码分割

在 Vue Router 中使用动态导入来实现路由级别的代码分割：

```javascript
const UserDetails = () => import('./views/UserDetails.vue')

const router = new VueRouter({
  routes: [
    { path: '/user/:id', component: UserDetails }
  ]
})
```

1. 使用 Vite

如果使用 Vite 作为构建工具，它默认就支持按需导入：

```javascript
import { Button } from 'my-ui-library'
```

1. 自定义按需加载方案

对于自己开发的组件库，可以设计一个自定义的按需加载方案，例如：

```javascript
// 在入口文件中
export { default as Button } from './components/Button'
export { default as Input } from './components/Input'

// 使用时
import { Button, Input } from 'my-ui-library'
```

实现按需引入时需要注意：

- 确保你的构建工具和配置支持代码分割和动态导入。
- 考虑首屏加载时间和用户体验，避免过多的小文件请求。
- 对于频繁使用的组件，可能直接导入会更好，避免频繁的异步加载。
- 测试不同的按需加载策略，找到最适合你的应用的方案。

## http中options的作用

HTTP 中的 `OPTIONS 方法是一种预检请求`（preflight request），主要`用于跨域资源共享（CORS）场景`。它的主要作用包括：

1. `跨域请求预检`
   - 在`进行复杂跨域请求之前`，`浏览器会自动发送 OPTIONS 请求`，以`确定实际请求是否安全可发送`。

2. `获取服务器支持的 HTTP 方法`
   - 客户端可以使用 OPTIONS 请求来询问服务器支持哪些 HTTP 方法。

3. `检查服务器能力`
   - 允许客户端`查询服务器支持的功能或选项`。

4. CORS 预检请求
   - 对于非简单请求（如使用 PUT、DELETE 方法，或包含特定头部的请求），浏览器会先发送 OPTIONS 请求。

5. `获取 CORS 相关信息`
   - `服务器在响应 OPTIONS 请求时`，会返`回允许的方法、头部、来源等 CORS 相关信息`。

6. 减少实际请求的数量
   - 通过`预检`，可以`避免发送可能被服务器拒绝的请求`，从而`减少不必要的网络流量。`

7. 安全性检查
   - 服务器可以使用 OPTIONS 请求来执行额外的安全性检查。

8. 缓存预检结果
   - 浏览器可`以缓存预检请求的结果`，`减少后续相同请求的预检次数`。

9. 自定义头部检查
   - `检查服务器是否接受特定的自定义头部。`

10. 验证身份认证方案
    - 可用于询问服务器支持哪些身份认证方案。

OPTIONS 请求的典型响应头包括：

- Access-Control-Allow-Origin
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Max-Age

示例 OPTIONS 请求：

```
OPTIONS /resource HTTP/1.1
Host: api.example.com
Origin: https://www.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header
```

示例响应：

```
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://www.example.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Max-Age: 86400
```

通过正确处理 OPTIONS 请求，可以实现安全、高效的跨域资源访问，同时提供了一种机制来探测服务器的能力和限制。

## 跨域怎么下载

跨域下载文件确实可能会遇到一些挑战，因为浏览器的同源策略限制了直接访问跨域资源。以下是几种处理跨域下载的方法：

1. 服务器端设置 CORS（跨源资源共享）

服务器需要在响应头中添加适当的 CORS 头：

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
Access-Control-Expose-Headers: Content-Disposition
```

特别注意 `Access-Control-Expose-Headers`，它允许客户端访问 `Content-Disposition` 头，这对于文件下载很重要。

2. 使用 Blob 和 URL.createObjectURL()

```javascript
fetch('https://api.example.com/download', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/octet-stream',
  },
})
.then(response => response.blob())
.then(blob => {
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = 'filename.ext';
  document.body.appendChild(a);
  a.click();
  window.URL.revokeObjectURL(url);
});
```

3. 使用服务器端代理

在你的域名下创建一个代理接口，该接口在服务器端请求跨域资源，然后将其传送给客户端。

4. 使用 iframe 下载

创建一个隐藏的 iframe，将其 src 设置为下载 URL：

```javascript
function downloadFile(url) {
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.src = url;
  document.body.appendChild(iframe);
}
```

5. 使用 window.open()

```javascript
window.open('https://api.example.com/download', '_blank');
```

6. 使用 Data URL

对于小文件，可以将文件内容编码为 Data URL：

```javascript
fetch('https://api.example.com/download')
  .then(response => response.blob())
  .then(blob => {
    const reader = new FileReader();
    reader.onload = function() {
      const a = document.createElement('a');
      a.href = reader.result;
      a.download = 'filename.ext';
      a.click();
    }
    reader.readAsDataURL(blob);
  });
```

7. 使用 Web Workers

Web Workers 可以绕过某些 CORS 限制：

```javascript
const worker = new Worker('download-worker.js');
worker.postMessage({ url: 'https://api.example.com/download' });
worker.onmessage = function(e) {
  const blob = e.data;
  // 使用 blob 进行下载
};
```

8. 后端生成签名 URL

对于某些云存储服务（如 AWS S3），可以在后端生成带有临时访问权限的签名 URL，前端直接使用这个 URL 进行下载。

注意事项：
- 确保你有权限访问和分发要下载的文件。
- 对于大文件，考虑使用流式下载或分块下载。
- 某些方法可能不适用于所有浏览器，请进行兼容性测试。
- 安全性很重要，确保不会无意中暴露敏感数据。

选择最适合你的用例和安全要求的

## csp安全策略

`内容安全策略`（Content Security Policy，简称 CSP）是一种`额外的安全层`，用于`检测并减轻`某`些类型的攻击`，包括`跨站脚本（XSS）`和`数据注入攻击`。`CSP 的主要目标`是`减少和报告 XSS 攻击`。以下是关于 CSP 的主要内容：

1. 工作原理：
   - CSP 通过`指定有效域名来源`，`使服务器管理员`能够`减少或消除可能遭受 XSS 攻击的媒介`。
   - `CSP 兼容的浏览器`将`只执行从白名单域名加载的脚本`，`忽略所有其他脚本`（包括内联脚本和事件处理 HTML 属性）。

2. `实施方法`：
   
   - 通过` HTTP 头`部：设置` Content-Security-Policy` 头。
   - 通过 HTML 的 `meta `标签：<meta http-equiv="Content-Security-Policy" content="...">
   
3. 主要指令：
   - default-src：为其他 CSP 指令提供默认值
   - script-src：指定脚本的有效来源
   - style-src：指定样式表的有效来源
   - img-src：指定图像的有效来源
   - connect-src：限制通过脚本接口可以连接的地址
   - font-src：指定字体文件的有效来源
   - object-src：指定 <object>、<embed> 和 <applet> 的有效来源
   - media-src：指定音频和视频的有效来源
   - frame-src：指定 iframe 的有效来源

4. 示例：
   ```
   Content-Security-Policy: default-src 'self'; script-src 'self' https://apis.google.com
   ```
   这个策略允许来自同一来源的内容和来自 https://apis.google.com 的脚本。

5. 特殊关键字：
   - 'none'：不允许任何内容
   - 'self'：允许来自同一来源的内容
   - 'unsafe-inline'：允许使用内联资源
   - 'unsafe-eval'：允许使用 eval() 等函数

6. 报告模式：
   可以使用 Content-Security-Policy-Report-Only 头，此模式下不会阻止任何内容，但会报告违规。

7. 优点：
   - 减少 XSS 攻击风险
   - 减少点击劫持风险
   - 提供额外的安全层

8. 挑战：
   - 可能需要重构现有代码
   - 需要仔细规划以避免破坏功能
   - 可能与某些第三方脚本或库不兼容

9. 最佳实践：
   - 从严格策略开始，然后根据需要放宽
   - 使用报告模式来测试策略
   - 定期审查和更新策略
   - 结合其他安全措施使用

CSP 是一个强大的工具，可以显著提高 web 应用的安全性，但需要仔细规划和实施。

## 级联选择器

级联选择器是一种在前端开发中常用的组件，用于实现多层级的下拉选择功能。它通常用于处理具有层级关系的数据，如地址选择（省/市/区）、分类选择等。以下是关于级联选择器的主要内容：

1. 基本概念：
   - 级联选择器由多个相互关联的下拉列表组成。
   - 上一级的选择会影响下一级可选择的内容。

2. 主要特点：
   - 多层级：通常包含两个或更多层级的选择。
   - 数据依赖：下级选项依赖于上级的选择。
   - 动态加载：可以根据选择动态加载下一级的选项。

3. 实现方式：
   a. 前端实现：
      - 将`所有数据加载到前端，根据选择筛选显示`。
      - 适用于数据量较小的情况。

   b. 后端实现：
      - `每次选择后向后端请求下一级数据`。
      - 适用于大量数据或需要实时数据的情况。

4. 数据结构：
   通常使用树状结构或扁平化的数组结构来组织数据。
   ```javascript
   // 树状结构示例
   const data = [
     {
       value: 'fruit',
       label: '水果',
       children: [
         {
           value: 'apple',
           label: '苹果',
           children: [
             { value: 'red', label: '红苹果' },
             { value: 'green', label: '青苹果' }
           ]
         },
         // ...
       ]
     },
     // ...
   ];
   ```

5. 常见功能：
   - 多选：允许在每一级选择多个选项。
   - 搜索：在选项中搜索。
   - 默认值：可以设置默认选中的值。
   - 禁用选项：某些选项可以被禁用。
   - 动态加载：按需加载下级数据。

6. 实现步骤：
   a. 准备数据结构
   b. `创建多个select元素`或自定义下拉组件
   c. `绑定选择事件`
   d. `根据选择更新下一级选项`
   e. 处理选择结果

7. 示例代码（简化版）：
   ```javascript
   function updateOptions(parentSelect, childSelect, data) {
     const selectedValue = parentSelect.value;
     const childOptions = data.find(item => item.value === selectedValue)?.children || [];
     
     childSelect.innerHTML = childOptions.map(option => 
       `<option value="${option.value}">${option.label}</option>`
     ).join('');
   }
   
   // 使用
   const level1 = document.getElementById('level1');
   const level2 = document.getElementById('level2');
   level1.addEventListener('change', () => updateOptions(level1, level2, data));
   ```

8. 注意事项：
   - 性能考虑：大量数据时考虑分批加载或虚拟滚动。
   - 用户体验：提供清晰的视觉反馈和直观的操作方式。
   - 错误处理：处理无数据或加载失败的情况。
   - 响应式设计：确保在不同设备上都能良好展示。

9. 常见应用场景：
   - 地址选择

## 最长回文子串

寻找最长回文子串是一个经典的编程问题。以下是一个 JavaScript 实现，使用中心扩展法来解决这个问题：

```javascript
function longestPalindrome(s) {
    if (s.length < 2) return s;

    let start = 0;
    let maxLength = 1;

    function expandAroundCenter(left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            const currentLength = right - left + 1;
            if (currentLength > maxLength) {
                start = left;
                maxLength = currentLength;
            }
            left--;
            right++;
        }
    }

    for (let i = 0; i < s.length; i++) {
        expandAroundCenter(i, i);     // 奇数长度的回文
        expandAroundCenter(i, i + 1); // 偶数长度的回文
    }

    return s.substring(start, start + maxLength);
}
```

这个算法的工作原理如下：

1. 首先，我们处理边界情况：如果字符串长度小于 2，直接返回原字符串。

2. 我们定义两个变量：`start` 记录最长回文子串的起始位置，`maxLength` 记录最长回文子串的长度。

3. `expandAroundCenter` 函数用于从中心向两边扩展，检查回文：
   - 它接受两个参数 `left` 和 `right`，表示当前检查的左右边界。
   - 当左右字符相等时，继续向外扩展。
   - 如果找到更长的回文，更新 `start` 和 `maxLength`。

4. 主循环遍历字符串的每个字符：
   - 对于每个字符，我们检查两种情况：
     - 以当前字符为中心的奇数长度回文（例如 "aba"）
     - 以当前字符和下一个字符之间为中心的偶数长度回文（例如 "abba"）

5. 最后，我们返回找到的最长回文子串。

使用示例：

```javascript
console.log(longestPalindrome("babad")); // 输出 "bab" 或 "aba"
console.log(longestPalindrome("cbbd"));  // 输出 "bb"
console.log(longestPalindrome("a"));     // 输出 "a"
console.log(longestPalindrome("ac"));    // 输出 "a"
```

这个算法的时间复杂度是 O(n^2)，其中 n 是字符串的长度。对于每个中心位置（共 2n-1 个，包括字符间的位置），我们最多进行 n 次扩展。空间复杂度是 O(1)，因为我们只使用了常数级的额外空间。

虽然还有一些更高级的算法（如 Manacher's 算法）可以将时间复杂度降到 O(n)，但对于大多数实际应用来说，这个实现已经足够高效且易于理解。

## JWT和token有什么区别？

JWT和token有什么区别？，这是一道非常高频的前端面试题，但是很多同学在面试时候都回答不出来。老规矩，点赞收藏，点点关注支持一下，给我一分钟，理想哥教大家该怎么满分回答这个问题



如果我是求职者，我会这么回答：



`Token其实就是一个加密的字符串`，`通过MD5`等一些`不可逆加密算法实现`的，可以保证唯一性。



`JWT是json web token`缩写，是一种`特定类型的Token`，它采用了`JSON格式`来`存储有关用户身份`和`访问权限的信息`。`JWT会把用户信息加密到token里`，`服务器不保存任何用户信息`，服务器通过使用保存的`密钥`来`验证`JWT Token。



`JWT`由三部分`组成`，分别是`头部`（Header）、`载荷`（Payload）和`签名`（Signature），`头部`包含有关JWT的`元数据和算法信息`，`载荷`包含实际的`用户数据`，例如`用户ID`、`角色`等，`签名`用于`验证JWT的完整性`和真实性。



`JWT和token的区别`主要`体现在是否需要查询数据库`。对了`Token`来说，`服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息`，然后`验证 Token 是否有效`。而`JWT则不需要`，因为`用户的信息及加密信息、过期时间，都存储在JWT里`，服务端只需要`使用密钥解密进行校验`即可，不需要查询或者减少查询数据库。

## async,await输出题

非常好的问题！让我们分析一下这个修改后的代码：

```javascript
async function f1(){
    console.log(1);
}
async function f2(){
    console.log(2);
    await console.log(3);
    console.log(5);
}
function f3(){
    console.log(4);
}
f1()
f2()
f3()
```

输出顺序会是：1, 2, 3, 4, 5

让我详细解释原因：

1. `f1()` 被调用。虽然它是一个异步函数，但它不包含任何 await 语句，所以它会同步执行并立即打印 1。

2. `f2()` 被调用。它首先同步执行并打印 2。

3. 在 f2() 中，遇到 `await console.log(3)`。`console.log(3)` 会立即执行并打印 3，但 `await` 会`暂停 ` `f2()` 函数的剩余部分的执行，并`将控制权交回给调用栈`。

4. `f3()` 被调用，它是一个普通的同步函数，所以立即执行并打印 4。

5. 此时，主调用栈已经清空，但是 `f2()` 函数还有未完成的部分（await 之后的代码，即 `console.log(5)`）。`这部分代码会被放入微任务队列`（microtask queue）。

6. 事件循环`检查微任务队列`，发现 `f2()` 的剩余部分，执行它。这会打印 5。

关键点解析：

- 异步函数 `f1()` 和 `f2()` 的调用是同步开始的，但它们的行为可能是异步的。
- `await` 关键字会暂停异步函数的执行，让出控制权。
- `await` 之后的代码会被放入微任务队列，在当前同步代码执行完毕后立即执行。
- 事件循环会在主调用栈清空后检查并执行微任务队列中的任务。

这个例子很好地展示了 JavaScript 中同步代码、异步函数和事件循环之间的交互。理解这些概念对于准确预测 JavaScript 代码的执行顺序非常重要。

## 涉及对象属性和全局变量的this指向

这是一个很好的问题，涉及到 JavaScript 中的作用域、this 绑定和函数调用方式。让我们逐步分析这段代码：

```javascript
var bar = 'window'

function say(){
  var bar = '111'
  console.log(bar);
  console.log(this.bar);
}

const obj = {
  bar: '222',
  say(){
    console.log(bar);
    console.log(this.bar);
  }
}

say()
obj.say()
obj.say = say
obj.say()
```

让我们分别看每次函数调用的输出：

1. `say()`
   输出：
   ```
   111
   window
   ```
   解释：
   - 第一个 `console.log(bar)` 输出 '111'，因为它使用的是函数内部定义的局部变量 `bar`。
   - 第二个 `console.log(this.bar)` 输出 'window'，因为在非严格模式下，独立调用的函数中的 `this` 指向`全局对象`（浏览器中是 window）。

2. `obj.say()`
   输出：
   ```
   window
   222
   ```
   解释：
   - 第一个 `console.log(bar)` 输出 'window'，因为 obj.say 方法中没有定义局部变量 bar，所以它访问的是全局作用域中的 bar。
   - 第二个 `console.log(this.bar)` 输出 '222'，因为这里的 this 指向调用该方法的对象 obj。

3. `obj.say = say; obj.say()`
   输出：
   ```
   111
   222
   ```
   解释：
   - 这里我们将全局的 say 函数赋值给 obj.say。
   - 第一个 `console.log(bar)` 输出 '111'，因为现在使用的是全局 say 函数，它有自己的局部变量 bar。
   - 第二个 `console.log(this.bar)` 输出 '222'，因为尽管函数体来自全局 say 函数，但它是作为 obj 的方法被调用的，所以 this 仍然指向 obj。

关键点：

1. 变量查找顺序：首先在当前作用域查找，如果没有找到，则向上级作用域查找，直到全局作用域。

2. this 的绑定：
   - 对于普通函数调用，this 通常指向全局对象（非严格模式）或 undefined（严格模式）。
   - 对于方法调用，this 指向调用该方法的对象。

3. 函数赋值：当我们将一个函数赋值给对象的属性时，函数体不变，但 this 绑定会根据调用方式改变。

这个例子很好地展示了 JavaScript 中变量作用域和 this 绑定的复杂性，理解这些概念对于正确预测代码行为至关重要。

## obj中的console.log(bar);为什么没有输出对象的属性bar

您提出了一个非常好的问题。让我详细解释一下为什么 `obj` 中的 `console.log(bar)` 没有输出对象的属性 `bar`，而是输出了全局变量 `bar`。

这涉及到 JavaScript 的`词法作用域`（Lexical Scope）规则。让我们再看一下相关的代码：

```javascript
var bar = 'window'

const obj = {
  bar: '222',
  say(){
    console.log(bar);
    console.log(this.bar);
  }
}
```

关键点解析：

1. 词法作用域：
   JavaScript 使用`词法作用域`，这意味着`变量的作用域`是在`代码编写时`就`确定的`，而`不是在运行时确定`的。

2. `变量查找顺序`：
   当遇到一个变量时，JavaScript 引擎会按以下顺序查找：
   - `当前作用域`
   - `外部作用域`
   - `全局作用域`

3. `对象不创建新的作用域`：
   在 JavaScript 中，对象并不创建新的作用域。对象的方法中的变量查找遵循普通的词法作用域规则。

4. `this` 和变量查找的区别：
   `this.bar` 是在`对象上查找属性`，而直接使用 `bar` 是按照`词法作用域规则查找变量`。

在这个例子中：

- `console.log(bar)` 在 `say` 方法内部。由于 `say` 方法内部没有定义 `bar` 变量，JavaScript 会向外查找，直到找到全局作用域中的 `bar`。
- `console.log(this.bar)` 则是在当前对象（`this`）上查找 `bar` 属性，因此会找到对象的 `bar` 属性。

如果想要在 `say` 方法中访问对象的 `bar` 属性，可以这样修改：

```javascript
const obj = {
  bar: '222',
  say(){
    console.log(this.bar);  // 将输出 '222'
    console.log(this.bar);
  }
}
```

或者，如果你想创建一个闭包来捕获对象的 `bar` 属性：

```javascript
const obj = {
  bar: '222',
  say(){
    const bar = this.bar;
    console.log(bar);  // 将输出 '222'
    console.log(this.bar);
  }
}
```

理解这一点对于避免 JavaScript 中常见的作用域相关错误非常重要。这也展示了为什么在处理对象属性时，使用 `this` 关键字通常是一个好习惯。

## ☆this输出

这是一个非常好的问题，涉及到 JavaScript 中的箭头函数、this 绑定和闭包等概念。让我们逐步分析这段代码：

```javascript
var obj = {
    name: 'obj',
    foo1: () => {
        console.log(this.name);
    },
    foo2: function () {
        console.log(this.name)
        return () => {
            console.log(this.name);
        }
    }
}
var name = 'window'
obj.foo1()
obj.foo2()()
let fn = obj.foo2()
fn()
```

让我们分别看每次函数调用的输出：

1. `obj.foo1()`
   输出：`window`

   原因：
   - `foo1` 是一个箭头函数。箭头函数`不会创建自己的` `this` 上下文，而是`捕获其所在上下文`的 `this` 值。
   - 在这个例子中，`foo1` 定义在全局作用域内（即使它是对象的一个属性），所以它的 `this` 指向全局对象（在浏览器中是 window）。
   - 因此，`this.name` 实际上访问的是全局变量 `name`，即 'window'。

2. `obj.foo2()()`
   输出：
   ```
   obj
   obj
   ```

   原因：
   - `obj.foo2()` 是一个普通函数调用，`this` 指向 `obj`，所以第一个 `console.log(this.name)` 输出 'obj'。
   - `foo2` 返回一个箭头函数。这个箭头函数捕获了 `foo2` 的 `this` 上下文，也就是 `obj`。
   - 因此，返回的箭头函数中的 `this.name` 仍然是 'obj'。

3. `let fn = obj.foo2(); fn()`
   输出：
   ```
   obj
   obj
   ```

   原因：
   - `obj.foo2()` 执行时，`this` 指向 `obj`，所以第一个 `console.log(this.name)` 输出 'obj'。
   - `foo2` 返回的箭头函数被赋值给 `fn`。
   - 当 `fn()` 执行时，尽管它是在全局作用域下调用的，但由于它是一个箭头函数，它的 `this` 仍然是创建时的 `this`，即 `obj`。
   - 因此，`fn()` 中的 `console.log(this.name)` 输出 'obj'。

关键点：

1. 箭头函数的 `this`:
   - `箭头函数不创建自己的 `this` 上下文`，而是`继承外围作用域的 `this` 值`。
   - `一旦箭头函数被创建`，它的 `this` 值就不能被改变`。

2. 普通函数的 `this`:
   - 普通函数的 `this` 值取决于函数如何被调用。

3. 闭包：
   - 箭头函数创建了一个闭包，捕获了外部函数的 `this` 值。

4. 全局变量：
   - 在非严格模式下，全局作用域中声明的变量会成为全局对象（如 window）的属性。

## 单页面路由是如何实现不更新刷新页面的

单页面应用(SPA)的路由实现不刷新页面主要依赖于以下几种技术:

1. `HTML5 History API`

这是现代浏览器提供的 API,可以操作浏览器的历史记录,主要使用:

- history.pushState() - 添加新的状态到历史记录
- history.replaceState() - 修改当前的历史记录
- window.onpopstate 事件 - 监听浏览器前进/后退

使用这些方法可以在不刷新页面的情况下改变 URL。

2. Hash 模式

使用 URL 的 hash (#) 来模拟一个完整的 URL,当 URL 改变时,页面不会重新加载。

3. 前端路由库

像 React Router、Vue Router 等库,底层就是基于上面两种方式实现的。它们提供了更方便的 API。

4. AJAX

通过 AJAX 异步加载数据和组件,实现页面内容的更新。

5. `虚拟 DOM`

框架如 React、Vue 使用虚拟 DOM 进行高效的 DOM 更新,只更新变化的部分。

实现过程:

1. 监听 URL 变化(通过 history API 或 hashchange 事件)
2. 匹配路由规则
3. 渲染对应的组件
4. 通过 AJAX 加载数据
5. 更新虚拟 DOM 和实际 DOM

这样就可以在不刷新整个页面的情况下,实现 URL 和页面内容的更新。

## xss攻击与csrf攻击

前端常见的主要就是xss（跨站脚本攻击（Cross-Site Scripting, XSS）和csrf（跨站请求伪造（Cross-Site Request Forgery, CSRF））攻击，就是同源策略防止的，xss攻击简单的说就是通过在你的网站里植入一些其他地方脚本，因为没有同源策略限制的话，你的网站就会直接加载这个脚本，如果这个脚本里包含恶意代码，他就会发起攻击。csrf简单地说就是攻击者通过伪装一个网站来盗取用户的令牌，然后给原网站发起非法请求



`XSS（跨站脚本攻击`）和`CSRF（跨站请求伪造）`是两种常见的web安全攻击。让我们详细了解一下它们：

### XSS 攻击 (Cross-Site Scripting)

XSS 是一种`将恶意脚本注入到otherwise合法和受信任的网站中的攻击方式`。

防御措施：
- 对`用户输入进行验证和转义`。
- 使用内容安全策略 (CSP): 只允许从当前域加载资源

  - 通过设置Content-Security-Policy头部来限制资源的加载和脚本执行。

  ```html
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'">
  ```

- HttpOnly Cookie：防止客户端脚本访问这个 Cookie， 保护敏感信息，如会话标识符

  - 设置HttpOnly标志，防止JavaScript访问敏感Cookie。

  ```html
  Set-Cookie: session=123; HttpOnly
  ```

- 使用` HttpOnly 标志保护cookies`。
- 对输出进行编码。
- 使用安全的API：
  - 使用innerText而不是innerHTML来插入文本内容。
  - 使用document.createElement()、setAttribute()等DOM方法创建元素和属性。

### CSRF 攻击 (Cross-Site Request Forgery)

`CSRF 是一种强制用户在他们已认证的web应用程序上执行不必要操作的攻击`。

攻击过程：
1. `用户登录了目标网站A并获得了认证`。
2. `用户访问恶意网站B`。
3. `B网站向A网站发送请求`，`携带用户的认证信息`。
4. A网站认为这是一个合法请求并执行操作。

防御措施：
- 使用CSRF令牌。
  - 服务器为每个会话生成一个唯一的令牌
  - 将令牌嵌入到表单中或作为自定义HTTP头发送
  - 服务器验证每个请求中的令牌

- 检查Referer头。
  - 验证请求的来源（Referer头）是否是预期的域名。

- `使用SameSite Cookie属性`。
  - SameSite属性允许服务器指示浏览器，某个特定的Cookie不应在跨站请求中发送，从而增加安全性

- 对`敏感操作使用重认证`。
  - 在执行敏感操作前，要求用户重新输入密码或进行其他形式的身份验证


比较：

1. 目标：
   - XSS：`执行恶意脚本，通常用于窃取用户数据`。
   - CSRF：`强制用户执行未经授权的操作`。
2. 攻击载体：
   - XSS：`通过注入恶意脚本来执行`。
   - CSRF：`通过伪造请求来执行`。
3. 用户交互：
   - XSS：通常需要用户与包含恶意脚本的内容交互。
   - CSRF：不需要用户直接与恶意内容交互。
5. 影响：
   - `XSS：可能导致数据泄露、账户劫持等`。
   - `CSRF：可能导致未经授权的操作，如转账、更改密码等。`

## 层序遍历

层序打印二叉树是一种广度优先搜索（BFS）的应用。我们可以使用队列来实现这个功能。以下是用 JavaScript 实现层序打印二叉树的代码：

```javascript
// 定义二叉树节点
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

// 层序打印二叉树
function levelOrderPrint(root) {
    if (!root) return [];

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }

        result.push(currentLevel);
    }

    return result;
}

// 创建一个示例二叉树
//       1
//      / \
//     2   3
//    / \   \
//   4   5   6
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.right = new TreeNode(6);

// 打印结果
console.log(levelOrderPrint(root));
```

这段代码的工作原理如下：

1. 我们首先定义了一个 `TreeNode` 类来表示二叉树的节点。

2. `levelOrderPrint` 函数实现了层序遍历：
   - 如果树为空，返回空数组。
   - 创建一个队列，初始时包含根节点。
   - 当队列不为空时，执行以下步骤：
     - 获取当前层的节点数量。
     - 创建一个数组来存储当前层的节点值。
     - 对当前层的每个节点：
       - 从队列中取出节点。
       - 将节点的值添加到当前层数组中。
       - 如果节点有左子节点，将其加入队列。
       - 如果节点有右子节点，将其加入队列。
     - 将当前层的数组添加到结果中。

3. 最后，我们创建了一个示例二叉树并调用 `levelOrderPrint` 函数。

输出结果将是：
```
[ [1], [2, 3], [4, 5, 6] ]
```

这个结果表示树的每一层，其中：
- 第一层包含节点 1
- 第二层包含节点 2 和 3
- 第三层包含节点 4, 5 和 6

这种方法可以清晰地展示树的层级结构，每个子数组代表树的一层。

### == 和 ===的区别

JavaScript 中的 `==` 和 `===` 是两种不同的比较操作符，它们在比较值时有着重要的区别：

1. `==` (相等运算符)：
   - 进行比较前会先进行类型转换。
   - 如果两个值类型不同，会尝试将它们转换为相同类型再比较。
   - 可能导致一些意外的结果。

2. `===` (严格相等运算符)：
   - 不进行类型转换。
   - 只有在类型和值都相同的情况下才返回 true。
   - 通常被认为是更安全和可预测的比较方式。

主要区别：

1. 类型转换：
   - `==` 会进行类型转换
   - `===` 不会进行类型转换

2. 比较规则：
   - `==` 在比较之前会尝试将操作数转换为相同类型
   - `===` 直接比较操作数，不做任何转换

3. 性能：
   - `===` 通常比 `==` 快，因为不需要进行类型转换

4. 可预测性：
   - `===` 的行为更加可预测，不会有意外的类型转换

例子：

```javascript
console.log(5 == "5");    // true  (字符串 "5" 被转换为数字 5)
console.log(5 === "5");   // false (不同类型)

console.log(0 == false);  // true  (false 被转换为 0)
console.log(0 === false); // false (不同类型)

console.log(null == undefined);  // true
console.log(null === undefined); // false

console.log('' == 0);     // true  (空字符串被转换为 0)
console.log('' === 0);    // false (不同类型)
```

建议：
- 在大多数情况下，推荐使用 `===`，因为它更加严格和可预测。
- 只有在你明确知道需要类型转换，并且理解转换规则的情况下，才使用 `==`。
- 使用 `==` 可能会导致难以发现的 bug，特别是在处理 `null`、`undefined`、空字符串和数字 0 时。

总的来说，`===` 是更安全的选择，可以避免许多潜在的问题和意外行为。

## 大文件上传,秒传,断点续传

1. 大文件上传

原理：将大文件分割成小块，逐块上传。

步骤： a) 前端：

- 使用 `File API 或 Blob API 将文件分割成小块`。
- 使用 XMLHttpRequest 或 Fetch API 上传每个分块。

b) 后端：

- `接收每个分块并保存`。
- `所有分块上传完成后，合并分块成完整文件`。



1. 秒传

原理：通过`文件特征（如MD5）判断服务器是否已存在相同文件，如果存在则直接标记为上传成功`。

步骤： a) 前端：

- 计算文件的MD5或其他唯一标识。
- 将标识发送给服务器验证。

b) 后端：

- 检查是否存在相同标识的文件。
- 如果存在，直接返回上传成功；否则，继续常规上传流程。



1. 断点续传

原理：记录已上传的文件块，支持从断点处继续上传。

步骤： a) 前端：

- `存储已上传块的信息`（如localStorage）。
- `上传时检查已上传的块，只上传未完成的部分。`

b) 后端：

- 保存每个文件的上传进度。
- 提供接口查询已上传的块信息。

## 箭头函数和普通函数的this

你对普通函数和箭头函数的 this 指向的理解基本正确,但还需要一些补充说明:

1. 普通函数的 this:

- 谁调用就指向谁,这个说法大体正确,但不够精确。
- 更准确地说,普通函数的 this 指向是在函数被调用时确定的,取决于函数的调用方式。
- 有以下几种情况:
  a) 作为对象方法调用: this 指向该对象
  b) 作为普通函数调用: this 指向全局对象(非严格模式)或 undefined(严格模式)
  c) 使用 call, apply 或 bind: this 指向指定的对象
  d) 作为构造函数调用(使用 new): this 指向新创建的实例对象

2. 箭头函数的 this:

- 箭头函数的 this 是在声明时(词法作用域)确定的,这个说法是正确的。
- 它会捕获其所在上下文的 this 值,作为自己的 this 值。
- 箭头函数的 this 不会因调用方式而改变,也不能通过 call, apply 或 bind 方法来改变。

举例说明:

```javascript
const obj = {
  name: 'Object',
  regularFunc: function() {
    console.log(this.name);
  },
  arrowFunc: () => {
    console.log(this.name);
  }
};

obj.regularFunc(); // 输出: "Object"
obj.arrowFunc();   // 输出: undefined (或在浏览器中可能是 window.name)

const regularFunc = obj.regularFunc;
regularFunc(); // 输出: undefined (非严格模式下是 window.name)

const arrowFunc = obj.arrowFunc;
arrowFunc(); // 输出: undefined (或在浏览器中可能是 window.name)
```

在这个例子中:
- `regularFunc` 作为对象方法调用时, this 指向 obj。
- `arrowFunc` 的 this 在声明时就已确定,指向全局对象(在浏览器中是 window)。
- 当 `regularFunc` 作为普通函数调用时, this 指向全局对象或 undefined。
- `arrowFunc` 无论如何调用, this 始终指向它声明时的上下文。

理解这些区别对于正确使用和管理 JavaScript 中的 this 非常重要。

## 请求接口为什么不在beforeCreated

确实，`beforeCreate` 钩子是 Vue 组件生命周期中最早的钩子之一，但通常不建议在 `beforeCreate` 中进行数据请求。以下是几个主要原因：

1. 数据和方法尚未初始化：
   在 `beforeCreate` 阶段，组件实例被创建，但是数据观察（data observer）和事件/侦听器还没有设置。这意味着你无法在这个阶段访问 `data`、`computed`、`methods` 或 `watch` 中定义的任何内容。

2. 无法直接操作响应式数据：
   由于数据还未被观察，你无法直接设置响应式数据。即使你在这个阶段发起了请求，也无法将获取到的数据直接赋值给组件的数据属性。

3. 生命周期顺序：
   `beforeCreate` -> `created` -> `beforeMount` -> `mounted`
   通常，我们希望在组件完全初始化后再进行数据请求，以确保所有的属性和方法都可用。

4. 可能导致性能问题：
   在非常早的阶段就开始数据请求可能会影响应用的启动性能，特别是在同一个页面有多个组件的情况下。

5. 调试和维护难度：
   在 `beforeCreate` 中进行复杂操作可能会使代码更难理解和维护，因为这个阶段的组件状态还不完整。

相比之下，`created` 钩子提供了更多的优势：

- 所有的数据观察、计算属性、方法和侦听器都已经设置好了。
- 你可以访问和修改响应式数据。
- 组件实例已经完全创建，但还没有挂载到 DOM 上，这通常是进行数据初始化的理想时机。

总的来说，除非有特殊需求，否则 `created` 钩子通常是进行数据请求的更好选择。它提供了足够早的执行时机，同时又确保了组件的基本功能已经准备就绪。

![攻击方式](F:\Js\面试问题收集\assets\攻击方式.png)

![BFC](F:\Js\面试问题收集\assets\BFC.png)

## cookie的请求头

Set-Cookie 头部的常用属性：

1. Expires: 设置 Cookie 的`过期时间`。
2. Max-Age: 设置 Cookie 的`生存时间`（以秒为单位）。
3. Domain: 指定 Cookie `可以送达的域名`。
4. Path: 指定 Cookie 可以应用的路径。
5. Secure: 标记 Cookie `只能通过 HTTPS 发送`。
6. HttpOnly: 标记 Cookie `不能被客户端脚本访问`。
7. SameSite: 用来`防止 CSRF 攻击和用户追踪`。

## 闭包的实现原理

1. 词法作用域（Lexical Scoping）
   - `闭包`基于`词法作用域`，即`函数的作用域`在函数`定义时就已确定`。
   - `内部函数可以访问外部函数的变量和参数`。
2. `作用域链`（Scope Chain）
   - 每个函数都有一个与之关联的作用域链。
   - 作用域链是一系列对象的列表，`用于变量查找`。
3. 活动对象（Activation Object）
   - 当`函数执行时`，会`创建一个活动对象`。
   - `活动对象包含函数的参数`、`局部变量和函数声明`。
4. 变量对象（Variable Object）
   - 每个`执行上下文都有一个变量对象`。
   - 对于`全局上下文`，`变量对象就是全局对象`。
   - 对于`函数上下文`，变量`对象就是活动对象`。
5. 执行上下文（Execution Context）
   - 当`函数被调用时`，会`创建一个新的执行上下文`。
   - `执行上下文包含变量对象`、`作用域链`和` this 值`。
6. 内存管理
   - 通常，`函数执行完毕后`，其`执行上下文会被销毁`。
   - 但`闭包会保持对外部函数作用域的引用`，`阻止垃圾回收`。
7. 闭包的创建
   - 当`内部函数引用了外部函数的变量时`，就`创建了闭包`。
   - `内部函数的作用域链中包含外部函数的作用域`。
8. 闭包的持久化
   - 即使外部函数已经返回，闭包仍然可以访问外部函数的变量。
   - 这是因为`闭包维持了对外部函数作用域的引用`。

## js的作用域

JavaScript 的作用域是一个重要的概念，它定义了变量的可访问性和生命周期。以下是 JavaScript 作用域的主要特点和类型：

1. 全局作用域（Global Scope）
   - 在任何`函数外部声明的变量属于全局作用域`。
   - `全局变量可以在整个程序中的任何地方被访问`。
   - 在`浏览器中`，`全局作用域`通常是` window 对象`。

2. `函数作用域（`Function Scope）
   - 在`函数内部声明的变量只在该函数内部可见`。
   - 每次`函数调用都会创建一个新的作用域`。

3. 块级作用域（Block Scope）
   - ES6 引入了` let 和 const 关键字`，它们`创建块级作用域`。
   - `块级作用域限制在 {} 花括号内`。

4. 词法作用域（Lexical Scope）
   - `JavaScript 使用词法作用域`，`也称为静态作用域`。
   - `变量的作用域在代码编写时就已确定`，而`不是在运行时确定`。

5. 作用域链（Scope Chain）
   - 当`查找变量时`，`JavaScript 会从当前作用域开始`，`沿着作用域链向上查找`。
   - 如果在`当前作用域找不到变量`，就会`查找外部作用域`，`直到全局作用域`。

6. 闭包（Closure）
   - `闭包是函数及其词法环境的组合`。
   - 允许`内部函数访问外部函数的作用域`。

7. 变量提升（Hoisting）
   - 使用 `var 声明的变量会被提升到其所在作用域的顶部`。
   - `函数声明也会被提升`。

8. 暂时性死区（Temporal Dead Zone，TDZ）
   - 使用` let 和 const 声明的变量不会被提升`。
   - 在`声明之前访问这些变量会导致 ReferenceError`。

9. 模块作用域（Module Scope）
   - `ES6 模块系统引入了模块作用域`。
   - 模块中的`变量默认是私有的`，`除非被显式导出`。

10. 动态作用域 vs 词法作用域
    - JavaScript 使用词法作用域，而不是动态作用域。
    - this 关键字是个例外，它的值是动态确定的。

11. eval() 和 with
    - 这两个特性可以动态修改或创建作用域，但不推荐使用。

12. 严格模式（Strict Mode）
    - 严格模式下，未声明的变量赋值会抛出错误，而不是创建全局变量。

## js的箭头函数的this指向会发生改变吗

箭头函数的 `this` 指向与普通函数不同，它有以下特点：

1. 箭头函数不会创建自己的 `this` 上下文，而是捕获其所在（词法）上下文的 `this` 值。

2. 箭头函数的 `this` 指向在定义时就已经确定，而不是在运行时确定。

3. 箭头函数的 `this` 指向不会因为调用方式的改变而改变。

具体来说：

1. 不会改变：
   - 箭头函数的 `this` 无法通过 `call()`、`apply()` 或 `bind()` 方法来改变。
   - 箭头函数不能用作构造函数（不能使用 `new` 关键字）。

2. 继承上下文：
   - 箭头函数会继承外层函数调用的 `this` 绑定（无论 `this` 绑定到什么）。

示例：

```javascript
const obj = {
  name: 'Object',
  regularMethod: function() {
    console.log(this.name);
    
    const arrowFunc = () => {
      console.log(this.name);
    };
    
    arrowFunc();
  },
  arrowMethod: () => {
    console.log(this.name);
  }
};

obj.regularMethod(); // 输出: "Object" 两次
obj.arrowMethod();   // 输出: undefined (因为全局环境下 name 未定义)
```

在这个例子中：
- `regularMethod` 中的 `this` 指向 `obj`。
- `regularMethod` 内部的箭头函数继承了 `regularMethod` 的 `this`，所以也指向 `obj`。
- `arrowMethod` 的 `this` 指向定义时的上下文（在这里是全局环境或模块环境），而不是 `obj`。

总结：箭头函数的 `this` 在定义时就已确定，并且不会改变。它继承自外部作用域的 `this`。

## https为什么是安全的

1. 加密通信：所有`数据在传输过程中都被加密`，防止窃听。
2. 数据完整性：确保`数据在传输过程中不被篡改`。
3. 身份验证：通过`数字证书验证网站的身份`，防止钓鱼攻击。
4. 防止`中间人攻击`：`加密和身份验证共同作用`，大大降低了中间人攻击的风险。
5. 保护隐私：`加密不仅保护数据内容`，还保护如 URL 参数等敏感信息。

## 浏览器和node环境事件循环的区别

好的,我来为您简单总结一下浏览器和Node.js环境事件循环的主要区别:

1. 实现方式不同:`浏览器由内部实现`,Node.js基于`libuv库。`

2. 微任务执行时机不同:
   - `浏览器:每个宏任务后执行所有微任务`
   - Node.js:在`不同阶段之间执行(`版本11前)

3. 宏任务类型和优先级不同:
   - `浏览器:主要有setTimeout、setInterval、I/O等`
   - `Node.js:有timeout、I/O、poll、check等多个阶段`

4. API差异:
   - Node.js独有setImmediate和process.nextTick
   - 浏览器没有这些API

5. I/O处理范围不同:
   - `浏览器主要处理网络和有限的文件操作`
   - `Node.js处理更广泛的I/O操作`

6. `浏览器有渲染任务,Node.js没有`

这些差异主要源于两种环境的设计目的和应用场景的不同。

##  Vue 3 中 ref 和 reactive 的主要区别：

1. 实现原理：
   - `ref: 使用 Object.defineProperty 或 Proxy 包装单个值`
   - `reactive: 使用 Proxy 包装整个对象`

2. 适用类型：
   - ref: 主要用于基本类型，也可用于对象
   - reactive: 只用于对象类型

3. 访问方式：
   - ref: 通过 .value 访问
   - reactive: 直接访问对象属性

4. 使用场景：
   - `ref: 单个值的响应式`
   - ``reactive: 复杂对象的响应式`

5. 性能：
   - `ref: 基本类型可能更优`
   - `reactive: 大型对象可能更优`

6. 模板中使用：
   - ref: 自动解包，不需要 .value
   - reactive: 直接使用

这些差异决定了在不同场景下如何选择使用 ref 或 reactive，以实现最佳的响应式数据管理。

## CSS 中的定位（positioning）主要有五种类型

每种类型都有其特定的作用和用途。以下是对这五种定位方式的简单介绍：

1. 静态定位（`Static `Positioning）
   - 这是`默认`的定位方式
   - 元素按照正常的文档流进行布局
   - `不受` top、bottom、left、right` 属性的影响`

2. 相对定位（`Relative` Positioning）
   - `相对于元素在文档中的正常位置进行定位`
   - 可以使用 top、bottom、left、right 属性进行微调
   - 不会影响其他元素的位置

3. 绝对定位（`Absolute `Positioning）
   - `相对于最近的已定位祖先元素`（非 static）进行定位
   - 如果没有已定位的祖先元素，则相对于初始包含块（通常是 <html>）
   - 会`脱离正常文档流，不占据空间`

4. 固定定位（`Fixed `Positioning）
   - `相对于浏览器窗口进行定位`
   - `元素的位置在滚动时不会改变`
   - 常用于`创建固定的页眉`、`页脚或侧边栏`

5. 粘性定位（`Sticky `Positioning）
   - `结合了相对定位和固定定位的特性`
   - 在`滚动到特定阈值之前表现为相对定位`
   - `滚动超过阈值后表现为固定定位`
   - 常用于`创建随滚动变化的导航栏`

每种定位方式都有其特定的应用场景，选择合适的定位方式可以更好地控制页面布局和元素位置。

## http版本的区别

HTTP 协议有几个主要版本，每个版本都有其特点和改进。以下是主要 HTTP 版本的区别：

1. HTTP/0.9（1991）
   - 极其简单的协议
   - 只支持 GET 方法
   - 不支持请求头
   - 只能传输 HTML 文件

2. HTTP/1.0（1996）
   - 引入了版本号概念
   - 增加了 HEAD、POST 等方法
   - 增加了请求头和响应头
   - 支持传输除 HTML 外的其他类型文件
   - 每个请求都需要建立一个新的 TCP 连接

3. HTTP/1.1（1997）
   - 默认使用持久连接（Keep-Alive），复用 TCP 连接
   - 引入管道机制，允许在同一连接中发送多个请求（但响应仍需要按顺序返回）
   - 增加了 PUT、DELETE 等方法
   - 引入了主机头（Host header），支持虚拟主机
   - 支持断点续传
   - 引入内容协商机制
   - 缓存机制改进

4. HTTP/2（2015）
   - 多路复用：允许同时通过单一 TCP 连接发送多个请求/响应
   - 二进制分帧：将信息分割为更小的帧，允许请求和响应的并行交错
   - 头部压缩（HPACK）：减少了重复头信息的传输
   - 服务器推送：允许服务器主动向客户端推送资源
   - 请求优先级：允许客户端设置请求的优先级
   - 默认使用加密（虽然理论上可以不加密）

5. HTTP/3（2022）
   - 基于 QUIC 协议，使用 UDP 而不是 TCP
   - 改进的多路复用：减少了队头阻塞问题
   - 更快的连接建立：结合了 TLS 1.3，减少了握手时间
   - 改进的拥塞控制
   - 连接迁移：支持网络切换（如从 Wi-Fi 切换到移动网络）而不中断连接

主要演进趋势：
1. 性能优化：从简单的短连接到持久连接，再到多路复用，每个版本都在提高传输效率。
2. 安全性增强：特别是 HTTP/2 和 HTTP/3，更加重视安全性。
3. 功能丰富：逐步增加了更多的方法、头部和特性，使协议更加灵活和强大。
4. 适应现代 Web：针对现代 Web 应用的需求，如移动设备、复杂页面结构等进行了优化。

目前，HTTP/1.1 仍然被广泛使用，但 HTTP/2 的采用率正在快速增长，而 HTTP/3 也开始在一些大型网站上部署。

## map和WeakMap区别

Map 和 WeakMap 都是用于`存储键值对`的集合，但它们有几个重要的区别：

a) 键的类型：

- Map：可以使用`任何类型的值`（原始值或对象）作为键。
- WeakMap：只能使用`对象作为键`（不能使用原始值）。

b) 键的引用：

- Map：`强引用键`，即使`没有其他引用`，键`也不会被垃圾回收`。
- WeakMap：`弱引用键`，如果`没有其他引用`，键可能会`被垃圾回收`。

c) 迭代和大小：

- Map：可以迭代键值对，有 size 属性。
- WeakMap：`不可迭代`，`没有 size 属性`，也不支持 clear() 方法。

d) 用途：

- Map：适用于需要`经常添加或删除键值对`的场景。
- WeakMap：主要用于`存储对象的私有数据`，或者需要`自动清理的数据`。

e) 内存管理：

- Map：可能导致内存泄漏，因为它保留对键的强引用。
- WeakMap：有助于防止内存泄漏，因为它允许键被垃圾回收。

示例：

```javascript
// Map
let map = new Map();
let obj = {};
map.set(obj, 'value');
obj = null;  // map 仍然保持对原始对象的引用

// WeakMap
let weakMap = new WeakMap();
let obj2 = {};
weakMap.set(obj2, 'value');
obj2 = null;  // 如果没有其他引用，obj2 可能会被垃圾回收
```

## 水平居中

1. 行内元素居中

对于行内元素（如文本或链接），可以使用：

```css
.parent {
  text-align: center;
}
```

1. 块级元素居中

对于固定宽度的块级元素：

```css
.child {
  width: 300px;
  margin: 0 auto;
}
```

1. Flexbox 布局

使用 Flexbox 可以轻松实现水平居中：

```css
.parent {
  display: flex;
  justify-content: center;
}
```

1. Grid 布局

Grid 布局也可以实现水平居中：

```css
.parent {
  display: grid;
  justify-content: center;
}
```

1. calc() 函数

使用 calc() 函数计算左边距：

```css
.child {
  width: 300px;
  margin-left: calc(50% - 150px);
}
```

1. 使用 margin: auto 和 fit-content

对于不确定宽度的情况：

```css
.child {
  width: fit-content;
  margin: auto;
}
```

## 清除浮动

1. 使用清除属性（clear）

在浮动元素后添加一个空的块级元素，并给它设置 clear 属性：

```html
<div class="container">
  <div class="float-element">浮动元素</div>
  <div class="clear"></div>
</div>

<style>
.clear {
  clear: both;
}
</style>
```

1. 父元素使用 overflow

给父元素设置 overflow 属性：

```html
<div class="container">
  <div class="float-element">浮动元素</div>
</div>

<style>
.container {
  overflow: auto; /* 或者 hidden */
}
</style>
```

1. 使用伪元素（::after）

这是一种广泛使用的方法，通常被称为 "clearfix" 技巧：

```html
<div class="container clearfix">
  <div class="float-element">浮动元素</div>
</div>

<style>
.clearfix::after {
  content: "";
  display: block;
  clear: both;
}
</style>
```

1. 父元素也浮动

让包含浮动元素的父元素也浮动：

```html
<div class="container">
  <div class="float-element">浮动元素</div>
</div>

<style>
.container {
  float: left;
  width: 100%;
}
</style>
```

1. 使用 display: flow-root

这是一个较新的方法，创建一个新的块格式化上下文（BFC）：

```html
<div class="container">
  <div class="float-element">浮动元素</div>
</div>

<style>
.container {
  display: flow-root;
}
</style>
```

1. 使用 display: inline-block

将父元素设置为 inline-block：

```html
<div class="container">
  <div class="float-element">浮动元素</div>
</div>

<style>
.container {
  display: inline-block;
  width: 100%;
}
</style>
```

## 应用层除了http还有哪些其他常见协议，http和https的区别

1. FTP (File Transfer Protocol) - 用于文件传输
2. SMTP (Simple Mail Transfer Protocol) - 用于发送电子邮件
3. POP3 (Post Office Protocol version 3) - 用于接收电子邮件
4. IMAP (Internet Message Access Protocol) - 另一种用于接收电子邮件的协议
5. DNS (Domain Name System) - 用于域名解析
6. DHCP (Dynamic Host Configuration Protocol) - 用于动态分配 IP 地址
7. Telnet - 用于远程登录
8. SSH (Secure Shell) - 安全的远程登录和文件传输协议
9. SNMP (Simple Network Management Protocol) - 用于网络管理
10. MQTT (Message Queuing Telemetry Transport) - 用于物联网通信
11. WebSocket - 用于全双工通信的协议



#### 关于 HTTP 和 HTTPS 的区别：

1. 安全性：
   - HTTP 是明文传输，数据可能被中间人截获。
   - HTTPS 使用 SSL/TLS 加密，提供了数据加密、身份认证和数据完整性保护。
2. 默认端口：
   - HTTP 默认使用 80 端口。
   - HTTPS 默认使用 443 端口。
3. URL 前缀：
   - HTTP 使用 "http://" 开头。
   - HTTPS 使用 "https://" 开头。
4. 证书：
   - HTTP 不需要证书。
   - HTTPS 需要 SSL 证书，通常由可信的第三方机构颁发。
5. 性能：
   - HTTP 通常比 HTTPS 快，因为它不需要加密/解密过程。
   - HTTPS 可能稍慢，但现代硬件和优化技术已经大大减小了这个差距。
6. SEO：
   - 搜索引擎更倾向于 HTTPS 网站，可能会给予更高的排名。
7. 数据完整性：
   - HTTP 不保证数据完整性。
   - HTTPS 可以检测数据是否被篡改。
8. 适用场景：
   - HTTP 适用于不需要安全传输的公开信息。
   - HTTPS 适用于涉及敏感信息（如登录凭证、支付信息等）的场景。

## 模块化规范的区别

模块化规范主要有以下几种，它们之间有一些重要的区别：

1. CommonJS

特点：
- 主要用于服务器端（Node.js）
- 同步加载
- 使用 require() 导入模块，module.exports 导出模块

示例：
```javascript
// 导入
const module = require('./module');

// 导出
module.exports = { /* ... */ };
```

2. AMD (Asynchronous Module Definition)

特点：
- 主要用于浏览器端
- 异步加载
- 使用 define() 定义模块，require() 加载模块

示例：
```javascript
define(['dependency1', 'dependency2'], function(dep1, dep2) {
    return { /* ... */ };
});

require(['module'], function(module) {
    // 使用模块
});
```

3. UMD (Universal Module Definition)

特点：
- 兼容 AMD 和 CommonJS
- 可以在浏览器和服务器端使用
- 通过判断环境来决定使用哪种模块系统

4. ES6 Modules

特点：
- ECMAScript 2015 (ES6) 标准
- 静态导入导出
- 浏览器原生支持（需要 type="module"）
- 可以通过构建工具用于服务器端

示例：
```javascript
// 导入
import module from './module';

// 导出
export default { /* ... */ };
```

主要区别：

1. 使用环境：
   - CommonJS 主要用于服务器端
   - AMD 主要用于浏览器端
   - UMD 兼容两者
   - ES6 Modules 可用于两者，但需要转译或特定环境支持

2. 加载方式：
   - CommonJS 是同步加载
   - AMD 是异步加载
   - ES6 Modules 可以同步或异步（使用 import() 函数）

3. 语法：
   - CommonJS 使用 require 和 module.exports
   - AMD 使用 define 和 require
   - ES6 Modules 使用 import 和 export

4. 静态/动态：
   - CommonJS 和 AMD 是动态加载
   - ES6 Modules 是静态的，有助于静态分析和树摇（tree-shaking）

5. 浏览器支持：
   - CommonJS 不直接支持浏览器
   - AMD 需要加载器库（如 RequireJS）
   - ES6 Modules 现代浏览器原生支持

6. 循环依赖处理：
   - CommonJS 和 AMD 可以处理循环依赖
   - ES6 Modules 也可以处理，但方式不同

7. 值拷贝 vs 引用：
   - CommonJS 导入的是值的拷贝
   - ES6 Modules 导入的是值的引用

8. 代码分割和懒加载：
   - AMD 原生支持
   - CommonJS 需要额外工具
   - ES6 Modules 通过动态 import() 支持

## vue3中ref和reactive底层实现的区别

Vue 3 中的 ref 和 reactive 都是用于创建响应式数据的 API，但它们在底层实现和使用场景上有一些重要的区别。让我们深入了解它们的底层实现：

1. reactive

reactive 的底层实现：

- 使用 ES6 的 Proxy 来创建对象的响应式版本。
- 对整个对象进行深层次的响应式转换。
- 直接代理原始对象，拦截对象的属性访问、修改等操作。

实现原理：

```javascript
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      track(target, key);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      trigger(target, key);
      return result;
    }
    // ... 其他拦截方法
  });
}
```

2. ref

ref 的底层实现：

- 将基本类型值包装在一个带有 value 属性的对象中。
- 使用 Object.defineProperty 或 Proxy（在 Vue 3.2+ 中）来实现响应式。
- 只对 .value 属性进行响应式处理。

实现原理：

```javascript
function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value');
      return value;
    },
    set value(newValue) {
      value = newValue;
      trigger(refObject, 'value');
    }
  };
  return refObject;
}
```

主要区别：

1. 数据类型处理：
   - reactive 主要用于对象（包括数组）
   - ref 可以用于任何类型，但主要用于基本类型

2. 访问方式：
   - reactive 创建的响应式对象可以直接访问属性
   - ref 创建的响应式数据需要通过 .value 访问

3. 响应式转换深度：
   - reactive 进行深层次的响应式转换
   - ref 只对 .value 属性进行响应式处理

4. 实现机制：
   - reactive 使用 Proxy
   - ref 在早期版本使用 Object.defineProperty，Vue 3.2+ 也使用 Proxy

5. 性能考虑：
   - reactive 对大型对象可能有轻微的性能开销
   - ref 对基本类型值的包装可能带来额外的内存使用

6. 解构和传递：
   - reactive 对象解构会失去响应性
   - ref 可以保持响应性，因为它是一个引用

7. 模板使用：
   - 在模板中，reactive 对象的属性可以直接使用
   - ref 在模板中会自动解包，不需要 .value

8. 类型推断：
   - reactive 在 TypeScript 中能更好地推断复杂对象的类型
   - ref 需要显式指定泛型类型

## flex是什么的简写

flex 是一个 CSS 简写属性，它是以下三个 flex 容器属性的缩写：

1. flex-grow
2. flex-shrink
3. flex-basis

具体解释如下：

1. flex-grow：
   - 定义了 flex 项目的增长因子，即如何分配容器中的剩余空间。
   - 默认值为 0，表示不会分配额外空间。
2. flex-shrink：
   - 定义了 flex 项目的收缩因子，即当容器空间不足时如何缩小。
   - 默认值为 1，表示会等比例缩小。
3. flex-basis：
   - 定义了 flex 项目在主轴方向上的初始大小。
   - 可以是长度值（如 px、em 等）或关键字（如 auto）。
   - 默认值为 auto。

## 单行溢出省略号

1. `white-space: nowrap;`
   - 确保文本不会换行，始终保持在一行内。
2. `overflow: hidden;`
   - 隐藏超出元素盒子的内容。
3. `text-overflow: ellipsis;`
   - 当文本溢出时，用省略号（...）表示被截断的部分。

完整的使用示例：

```html
<style>
  .single-line-ellipsis {
    width: 200px;  /* 设置一个固定宽度 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
</style>

<div class="single-line-ellipsis">
  这是一段很长的文本，当它超出容器宽度时会被截断并显示省略号。
</div>
```

注意事项：

1. 确保设置容器的宽度（width）或最大宽度（max-width）。如果容器宽度不受限制，文本就不会溢出，也就不会显示省略号。

## 多行溢出省略号

1. 使用 -webkit-line-clamp（最简单，但兼容性有限）

这是最简单的方法，但主要支持 WebKit 内核的浏览器（如 Chrome、Safari）：

```css
.multi-line-ellipsis {
  display: -webkit-box;
  -webkit-line-clamp: 3; /* 显示的行数 */
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

js也可以做,判断行高进行截断等

## 说说常用的数组方法，map和foreach的区别，是否都会改变原数组

常用的数组方法：

1. push(): 在数组末尾添加一个或多个元素，返回新的长度。
2. pop(): 删除并返回数组的最后一个元素。
3. shift(): 删除并返回数组的第一个元素。
4. unshift(): 在数组开头添加一个或多个元素，返回新的长度。
5. slice(): 返回数组的一个浅拷贝部分，不会修改原数组。
6. splice(): 可以删除、插入或替换数组的元素。
   1. splice返回一个被删除元素组成的数组
   2. 参数
      1. start（必需）：指定修改的开始位置（从0计数）
      2. deleteCount（可选）：表示要移除的数组元素的个数
      3. item1, item2, ... （可选）：要添加进数组的元素
7. concat(): 合并两个或多个数组，返回新数组。
8. join(): 将数组的所有元素连接成一个字符串。
9. indexOf(): 返回数组中指定元素的第一个索引。
10. lastIndexOf(): 返回数组中指定元素的最后一个索引。
11. find(): 返回数组中满足提供的测试函数的第一个元素的值。
12. filter(): 创建一个新数组，包含通过所提供函数实现的测试的所有元素。
13. map(): 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后的返回值。
14. forEach(): 对数组的每个元素执行一次给定的函数。
15. reduce(): 对数组中的每个元素执行一个由您提供的reducer函数，将其结果汇总为单个返回值。

map 和 forEach 的区别：

1. 返回值：
   - map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
   - forEach() 没有返回值，它只是对数组中的每个元素执行指定的操作。
2. 链式操作：
   - map() 返回一个新数组，因此可以链式调用其他数组方法。
   - forEach() 返回 undefined，不能链式调用。
3. 性能：
   - 在大多数情况下，map() 的性能略优于 forEach()，特别是当您需要生成新数组时。
4. 中断循环：
   - forEach() 不能通过 break 语句或使用 return 来中断循环。
   - map() 同样不能中断循环，但可以使用其他方法（如 some() 或 every()）来实现类似效果。
5. 稀疏数组：
   - map() 会跳过数组中的空位。
   - forEach() 同样会跳过空位。

是否会改变原数组：

- map() 不会改变原数组。它创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后的返回值。
- forEach() 本身不会改变原数组。但是，如果在回调函数中修改了原数组的元素，那么原数组会被改变。

## 数据类型隐式转换规则和显示转换的做法

1. 隐式转换规则

隐式转换发生在运算符应用于不同类型的操作数时。以下是一些常见的隐式转换规则：

a) 转换为字符串：

- 当 + 运算符的一个操作数是字符串时，另一个操作数会被转换为字符串。 例如：'3' + 4 结果为 '34'

b) 转换为数字：

- 在大多数数学运算中，操作数会被转换为数字。 例如：'3' - 1 结果为 2

c) 转换为布尔值：

- 在逻辑操作中，值会被转换为布尔值。
- falsy 值（转换为 false 的值）包括：false, 0, '', null, undefined, NaN
- 其他值都会转换为 true

d) 对象转换：

- 当对象需要被转换为原始值时，JavaScript 首先尝试调用 valueOf() 方法， 如果没有 valueOf() 或者 valueOf() 没有返回一个原始值，则调用 toString() 方法。

e) 特殊情况：

- null == undefined 结果为 true
- NaN 不等于任何值，包括它自身

1. 显式转换做法

显式转换是通过特定的函数或方法明确地进行类型转换。以下是一些常用的显式转换方法：

a) 转换为字符串：

- String(value)
- value.toString()
- value + ''

b) 转换为数字：

- Number(value)
- parseInt(value, 10) （用于整数）
- parseFloat(value) （用于浮点数）
- +value

c) 转换为布尔值：

- Boolean(value)
- !!value

d) 转换为对象：

- Object(value)

## js中有哪些是实现浅拷贝的方法。json转换实现深拷贝方法的局限性。写实现深拷贝的方法。

1. JavaScript 中实现浅拷贝的方法：

a) 展开运算符（Spread Operator）:

```javascript
const copy = {...original};
```

b) Object.assign():

```javascript
const copy = Object.assign({}, original);
```

c) Array.from() (用于数组):

```javascript
const copy = Array.from(original);
```

d) slice() (用于数组):

```javascript
const copy = original.slice();
```

1. JSON 转换实现深拷贝的局限性：

使用 JSON.parse(JSON.stringify(obj)) 进行深拷贝有以下局限：

a) 无法拷贝函数、undefined 和 Symbol。 b) 无法处理循环引用。 c) 会丢失原型链。 d) 无法正确处理 Date、RegExp、Error 等特殊对象。 e) 无法拷贝不可枚举的属性。

## 项目里路由权限控制怎么实现的

1. 使用路由元信息（meta fields）和全局路由守卫
2. 实现动态路由，根据用户角色动态添加路由
3. 创建自定义指令来控制元素的显示
4. 封装权限控制组件
5. 利用Vuex进行状态管理，存储和检查用户权限

1. #### 路由元信息（Meta Fields）

在路由配置中使用meta字段来定义每个路由的权限要求：

```javascript
const routes = [
  {
    path: '/admin',
    component: Admin,
    meta: { requiresAuth: true, role: 'admin' }
  }
]
```

然后在全局路由守卫中检查用户权限：

```javascript
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    // 检查用户是否已登录
    if (!isLoggedIn()) {
      next('/login')
    } else {
      // 检查用户角色
      if (to.meta.role && !hasRole(to.meta.role)) {
        next('/403')
      } else {
        next()
      }
    }
  } else {
    next()
  }
})
```

1. #### 动态路由

根据用户角色动态添加路由：

```javascript
// 定义路由
const asyncRoutes = [
  {
    path: '/admin',
    component: Admin,
    meta: { role: ['admin'] }
  }
]

// 根据用户角色过滤路由
function filterAsyncRoutes(routes, roles) {
  return routes.filter(route => {
    if (hasPermission(roles, route)) {
      if (route.children) {
        route.children = filterAsyncRoutes(route.children, roles)
      }
      return true
    }
    return false
  })
}

// 在用户登录后添加路由
store.dispatch('user/login').then(() => {
  const roles = store.getters['user/roles']
  const accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)
  router.addRoutes(accessedRoutes)
})
```

1. #### 指令方式

创建自定义指令来控制元素的显示：

```javascript
Vue.directive('permission', {
  inserted(el, binding) {
    const { value } = binding
    const roles = store.getters['user/roles']
    if (value && !roles.some(role => value.includes(role))) {
      el.parentNode && el.parentNode.removeChild(el)
    }
  }
})
```

在模板中使用：

```html
<button v-permission="['admin']">管理员操作</button>
```

1. #### Vuex 状态管理

在Vuex中存储用户权限信息，并在需要时进行检查：

```javascript
// store/modules/user.js
const state = {
  roles: []
}

const getters = {
  hasPermission: (state) => (requiredRoles) => {
    return state.roles.some(role => requiredRoles.includes(role))
  }
}
// 在组件中使用
if (this.$store.getters['user/hasPermission'](['admin'])) {
  // 执行管理员操作
}
```

## vue router 的实现原理

## 除了async和await其他实现同步接收的方式

- 回调函数（Callbacks）这是最传统的方式，但可能导致回调地狱。
- Promise
- Generator 函数
- 事件监听 使用事件监听模式，可以在异步操作完成时触发事件。
- 同步 XHR（不推荐） 在浏览器环境中，可以使用同步 XHR，但这会阻塞主线程，影响用户体验。
- Web Worker  虽然不是直接的同步处理方式，但 Web Worker 可以在后台线程中执行耗时操作，不会阻塞主线程。

## 如何理解HTML、CSS、JS

HTML 是网页的骨架，定义了网页的结构和内容。

- 作用：描述网页的结构和内容
- 特点：
  - 使用标签来定义元素
  - 形成树状结构（DOM）
  - 是静态的，本身不包含样式或交互功能



CSS 负责网页的外观和布局。

- 作用：定义 HTML 元素如何显示
- 特点：
  - 可以集中管理网页样式
  - 能够分离内容和表现
  - 提供了强大的布局能力

JavaScript 是一种编程语言，为网页添加交互性和动态功能。

- 作用：实现网页的动态行为和交互
- 特点：
  - 可以操作 DOM
  - 能够响应用户事件
  - 可以进行异步通信（AJAX）

1. HTML 提供内容结构
2. CSS 美化和布局内容
3. JavaScript 添加交互和动态功能

比喻：

- HTML 是房子的框架
- CSS 是房子的装修和布局
- JavaScript 是房子里的电器和智能系统
