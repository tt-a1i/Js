为什么非连续的最长递增子序列（LIS）可以使用二分查找
在求解最长递增子序列（Longest Increasing Subsequence, LIS）的问题中，尽管实际的子序列并不是连续的，但我们依然可以利用 二分查找 来优化算法的时间复杂度。这背后的核心思想在于维护一个辅助数组（通常称为 tails），该数组用于跟踪不同长度的递增子序列的最小尾部元素。下面详细解释这一过程及其合理性。

核心思想
维护 tails 数组：

tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素。
通过维护这个数组，我们确保对于每个可能的子序列长度，tails 中存储的是最小的尾部元素。这使得 tails 数组始终保持 递增 的顺序。
使用二分查找：

由于 tails 数组是递增的，我们可以对其使用二分查找来快速找到当前元素在 tails 中应当插入的位置。
这种查找方法有效地减少了遍历的时间，从而将整体时间复杂度降为 O(n log n)。
具体步骤
初始化：

创建一个空的 tails 数组，用于存储不同长度子序列的最小尾部元素。
遍历原数组：

对于数组中的每一个元素 num，使用二分查找在 tails 中找到第一个大于等于 num 的元素的位置 i。
如果找不到（即 num 大于 tails 中所有元素），则将 num 添加到 tails 的末尾，表示当前找到了更长的递增子序列。
如果找到，则将 tails[i] 替换为 num，以保持 tails 中对应长度子序列的最小尾部元素。
构建最长递增子序列：

最终，tails 的长度即为 LIS 的长度。
为了重建具体的子序列，可以另行维护一个 predecessors 数组，用于记录每个位置的前驱索引，从而通过回溯构建出实际的子序列。
示例解析
以数组 [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] 为例，求解其 LIS：

初始化 tails = []，predecessors = [-1, -1, ..., -1]。

遍历数组：

0：tails = [0]
8：tails = [0, 8]
4：替换 8，tails = [0, 4]
12：tails = [0, 4, 12]
2：替换 4，tails = [0, 2, 12]
10：替换 12，tails = [0, 2, 10]
6：替换 10，tails = [0, 2, 6]
14：tails = [0, 2, 6, 14]
1：替换 2，tails = [0, 1, 6, 14]
9：替换 14，tails = [0, 1, 6, 9]
5：替换 6，tails = [0, 1, 5, 9]
13：tails = [0, 1, 5, 9, 13]
3：替换 5，tails = [0, 1, 3, 9, 13]
11：替换 13，tails = [0, 1, 3, 9, 11]
7：替换 9，tails = [0, 1, 3, 7, 11]
15：tails = [0, 1, 3, 7, 11, 15]
最终 tails = [0, 1, 3, 7, 11, 15]，表示 LIS 为 [0, 1, 3, 7, 11, 15] 或者通过记录前驱索引构建的其他具体序列。

为什么二分查找适用
尽管 LIS 的实际序列不是连续的，但 tails 数组的构建方式确保了其内部始终是递增的。这种有序性使得二分查找成为可能，因为我们可以在 tails 中快速定位当前元素应插入的位置，从而有效地更新 tails。

通过这种方法，我们不需要遍历所有可能的子序列，而是通过维护一个有序的辅助数组，逐步构建出最优解。这不仅保持了算法的高效性，还确保了最终结果的正确性。

优化与总结
时间复杂度：O(n log n)，其中 n 是数组 nums 的长度。主要由遍历数组和每次二分查找所需的时间决定。
空间复杂度：O(n)，用于存储 tails 和 predecessors 数组。

tails存的是下标吧，既然存的是下标，为什么最终结果不能直接取下标依次填充结果数组呢，反而要多出来 // 重建LIS let lis = []; let index = tails[tails.length - 1]; while (index !== -1) { lis.push(nums[index]); index = predecessors[index]; }


tails 数组的作用
在 O(n log n) 的 LIS 算法中，tails 数组用于维护不同长度的递增子序列的最小尾部元素的下标。具体来说：

tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素的下标。
通过保持 tails 数组的有序性，可以确保在任意时候，tails 中的元素是最优的（即每个位置存储的是当前可能的最小尾部值）。
为什么不能直接使用 tails 构建 LIS
尽管 tails 数组存储的是下标，但它并不保存实际的子序列路径。具体原因如下：

tails 仅记录每个长度的最小尾部元素：

tails 数组中的每个元素只是对应长度子序列的结尾元素的下标，并不包含整个子序列的信息。
例如，tails[2] 记录的是所有长度为 3 的子序列中，尾部最小的那个子序列的最后一个元素的下标。
无法反映子序列的前驱关系：

tails 数组中的元素之间没有直接的前驱关系。即，tails[i] 并不指向 tails[i-1] 的前一个元素。
因此，无法通过 tails 数组直接遍历得到完整的子序列。
predecessors 数组的必要性
为了重建实际的最长递增子序列，需要一个额外的数组 predecessors 来记录每个元素在 LIS 中的前驱元素的下标。这使得我们可以从 tails 的最后一个元素开始，逐步回溯到序列的起始位置，从而构建出完整的 LIS。

详细解释
让我们通过一个示例来说明：

遍历数组并维护 tails 和 predecessors：

i = 0, num = 0:

tails = [0]（表示长度为1的子序列的尾部是0）
predecessors = [-1, -1, ..., -1]
i = 1, num = 8:

tails = [0, 1]（长度为2的子序列的尾部是8）
predecessors = [-1, 0, -1, ..., -1]
i = 2, num = 4:

替换 tails[1] 为2（因为4 < 8）
tails = [0, 2]
predecessors = [-1, 0, 0, -1, ..., -1]
i = 3, num = 12:

tails = [0, 2, 3]
predecessors = [-1, 0, 0, 2, -1, ..., -1]
依此类推，直到最后一个元素。

tails 最终状态：

tails = [0, 4, 6, 9, 13, 15]
这些下标对应的元素是 [0, 2, 6, 9, 11, 15]，即 LIS。
重建 LIS：

从 tails 最后一个元素的下标开始（15，对应的 predecessors[15] = 13）。
依次回溯：
15 -> 13
13 -> 9
9 -> 6
6 -> 2
2 -> 0
反向得到 LIS：[0, 2, 6, 9, 13, 15]
为什么不能直接使用 tails
假设我们直接使用 tails 中的下标 [0, 4, 6, 9, 13, 15] 对应的元素 [0, 2, 6, 9, 11, 15]，虽然在这个具体例子中是正确的，但这并不是在所有情况下都适用。原因在于：

不同情况可能导致错误：在某些情况下，tails 中的下标可能并不按照 LIS 的实际顺序排列。例如，如果遇到多个可能的前驱，tails 仅存储最优的尾部元素，但不记录完整的子序列路径。

不保证前驱一致性：没有 predecessors，无法确保 tails 中的元素之间实际上是可连接的，即它们是否真正形成一个递增的子序列。

结论
tails 数组用于优化和维护递增子序列的结构，但它并不直接保存完整的子序列路径。
predecessors 数组用于记录每个元素的前驱，从而允许我们从 tails 的末尾正确地重建整个 LIS。
必要步骤：为了确保我们得到的是一个实际存在的递增子序列，需要通过 predecessors 来追溯每个元素的前驱，构建最终的 LIS。


为什么要这样记录呢if (left > 0) { predecessors[i] = tails[left - 1]; }


为什么要记录 predecessors[i] = tails[left - 1]
在最长递增子序列（Longest Increasing Subsequence, LIS）的问题中，记录每个元素的前驱是为了能够在算法完成时重建实际的子序列。让我们深入理解这一点，并解释为什么需要这样记录前驱。

核心概念
tails 数组：

定义：tails[i] 存储的是长度为 i + 1 的递增子序列的最小尾部元素的下标。
目的：通过维护 tails 数组，使得在任何时刻，tails 保持递增且尾部尽可能小，从而为后续的元素提供更大的扩展空间。
性质：
tails 数组本身是递增的，因为每个 tails[i] 对应的元素比 tails[i - 1] 对应的元素更大。
它不直接存储子序列，而是为了高效地寻找和维护子序列的潜力。
predecessors 数组：

定义：predecessors[i] 存储的是当前元素 nums[i] 在 LIS 中的前一个元素的下标。
目的：帮助在最终阶段重建出实际的 LIS。
记录前驱的必要性
当我们遍历数组并更新 tails 时，仅通过 tails 数组无法知道每个元素在 LIS 中的具体位置及其前驱。因此，需要一个额外的 predecessors 数组来记录每个元素的前驱，从而在需要时能够回溯构建出完整的 LIS。

具体解释 predecessors[i] = tails[left - 1]
在代码中，有如下逻辑：

让我们分解并理解这一部分：

二分查找的结果：

left 表示当前元素 nums[i] 应该在 tails 数组中的位置。
如果 left 等于 tails.length，意味着 nums[i] 比 tails 中所有元素都大，可以扩展现有的最长子序列。
否则，nums[i] 替换 tails[left] 以保持 tails 中的最小尾部元素。
前驱的确定：

当 left > 0 时，表示 nums[i] 将成为长度为 left + 1 的子序列的新尾部。
此时，tails[left - 1] 存储的是长度为 left 的子序列的最小尾部元素的下标，也就是 nums[i] 在 LIS 中的前一个元素。
因此，predecessors[i] = tails[left - 1] 记录了当前元素在 LIS 中的前驱，方便后续的回溯。
举例说明
让我们通过一个具体的示例来理解这一过程：

输入数组：

遍历过程：

i = 0, num = 0：

tails = [0] （长度为1的子序列: [0]）
无前驱，predecessors = [-1, -1, ..., -1]
i = 1, num = 8：

tails = [0, 1] （长度为2的子序列: [0, 8]）
predecessors[1] = 0 （8 的前驱是 0）
i = 2, num = 4：

tails = [0, 2] （替换 8 为 4，长度为2的子序列: [0, 4]）
predecessors[2] = 0 （4 的前驱是 0）
i = 3, num = 12：

tails = [0, 2, 3] （长度为3的子序列: [0, 4, 12]）
predecessors[3] = 2 （12 的前驱是 4）
i = 4, num = 2：

tails = [0, 4, 3] （替换 4 为 2，长度为2的子序列: [0, 2, 12]）
predecessors[4] = 0 （2 的前驱是 0）
i = 5, num = 10：

tails = [0, 4, 5] （替换 12 为 10，长度为3的子序列: [0, 2, 10]）
predecessors[5] = 4 （10 的前驱是 2）
i = 6, num = 6：

tails = [0, 4, 6] （替换 10 为 6，长度为3的子序列: [0, 2, 6]）
predecessors[6] = 4 （6 的前驱是 2）
i = 7, num = 14：

tails = [0, 4, 6, 7] （长度为4的子序列: [0, 2, 6, 14]）
predecessors[7] = 6 （14 的前驱是 6）
i = 8, num = 1：

tails = [0, 8, 6, 7] （替换 2 为 1，长度为2的子序列: [0, 1, 6, 14]）
predecessors[8] = 0 （1 的前驱是 0）
i = 9, num = 9：

tails = [0, 1, 6, 9] （替换 14 为 9，长度为4的子序列: [0, 1, 6, 9]）
predecessors[9] = 6 （9 的前驱是 6）
... 继续类似的步骤，最终 tails 和 predecessors 将帮助我们重建 LIS。

重建 LIS 的过程
在 predecessors 数组的帮助下，我们可以从 tails 中的最后一个元素开始，逐步回溯找到 LIS 的完整序列。

重建步骤：

初始化：

创建一个空数组 lis。
从 tails 中获取最后一个元素的下标，即 tails[tails.length - 1]。
回溯：

将当前下标对应的数值添加到 lis。
更新当前下标为 predecessors[currentIndex]。
重复上述步骤，直到下标为 -1（表示序列的起始）。
反转：

因为我们是从后向前添加元素，所以需要反转 lis 得到正确的顺序。
示例代码：

在这个过程中，predecessors 数组确保我们能够连接每个元素的前驱，从而构建出一个正确且完整的最长递增子序列。

为什么不能直接使用 tails 中的下标
尽管 tails 数组存储的是下标，并且 tails 本身是递增的，但它 不包含完整的子序列路径。直接使用 tails 中的下标可能无法反映出实际的递增子序列，因为：

tails 的元素并不按序排列：

tails 保存的是 可能的子序列尾部元素 的下标，而不是一个连续的子序列。因此，直接按 tails 顺序取元素，可能不能保证其递增性。
缺乏前驱信息：

tails 只存储了当前最长子序列的尾部元素的位置，而没有记录该尾部元素的前驱。这意味着无法通过 tails 中的元素知道整个子序列的路径。
多个子序列的动态更新：

在遍历过程中，tails 可能会频繁更新，以保持最小尾部元素。这些更新并不保证之前的子序列结构，因此无法单纯依赖 tails 来重建。
结论
记录 predecessors[i] = tails[left - 1] 的目的是为了在最终阶段能够通过回溯前驱索引，准确地构建出最长递增子序列。tails 数组帮助我们高效地确定当前元素应插入的位置，从而维护子序列的长度和潜力，而 predecessors 数组则确保我们能够追溯到完整的子序列。