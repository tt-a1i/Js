//洗牌算法
/*没问题，我再试着从另一个角度解释一下。

### Fisher-Yates 洗牌算法的基本步骤：

1. **目标**：将一个数组打乱，确保每个可能的排列都是等概率出现的。
2. **过程**：
   - 对于数组索引从后向前遍历（从最后一个元素到第一个）。
   - 每次从未处理的部分选择一个随机元素与当前元素交换。

### 为什么从后往前遍历（`i--`）？

假设你有一个数组 `[A, B, C, D, E]`，从后往前遍历的话，步骤如下：

1. **第一步**：`E`随机与`[A, B, C, D, E]`中的一个交换。
2. **第二步**：`D`随机与`[A, B, C, D]`中的一个交换。
3. **第三步**：`C`随机与`[A, B, C]`中的一个交换。
4. **第四步**：`B`随机与`[A, B]`中的一个交换。
5. **`A`已在最终位置，不需要交换。**

### 为什么这样做是均匀的？

- 每个元素在它被处理时都有一个明确的范围（未处理的部分）供选择。
- 通过这种方式，元素不会因为之前的选择而受到隐形的限制——每次交换后，未处理区域的小范围选择向前推进。这样你总是保证“后面的”一些位置已经随机安排好。

### 若从前往后（`i++`）的问题：

假设你从前往后（`i++`）实现，你的步骤是这样的：

1. 第一个元素在它处理的时可能会影响到后续元素的随机化，也就是它选择时“偏早”对后遗症处理不当。
2. 后面的元素在处理时，其前面的元素位置是确定的，后续的随机化不再能够充分分配这些位置的多种可能。

这可能导致过早确定的位置对后续随机化不够彻底，从而使最终数组排列选择上产生偏差。

### 简单总结：

通过从后往前（`i--`）进行处理，每个元素在“足够大的选择空间”中被随机交换到一个位置，已经交换好的部分不再被改变。这样所有元素都有平等的机会在任何一个位置出现。

希望这个解释能帮助更好地理解！如果还有任何疑问，请随时提问。 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      // 生成一个随机索引 j，范围从 0 到 i
      const j = Math.floor(Math.random() * (i + 1));
      // 交换元素 array[i] 和 array[j]
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  
  // 使用示例
  const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  console.log('Original Array:', arr);
  console.log('Shuffled Array:', shuffleArray(arr));