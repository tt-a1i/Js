## Watch合Computed的区别

#### watch

监听数据或某个状态的变化,之后要执行某段逻辑

场景:搜索栏下方提示的展示

- **功能**：`watch`是用来监听特定数据的变化，当被监听的数据发生变化时，将会触发指定的回调函数。

- 特点

  ：

  - **无缓存**：每当监听的数据发生变化，不论变化前后值是否相等，`watch`都会执行回调函数。
  - **深度监听**：可以配置`deep`选项来深度监听对象内部属性的变化。
  - **异步处理**：`watch`不仅可以同步执行操作，还可以处理异步操作，例如在网络请求、批量更新等场景下非常有用。
  - **手动触发**：不同于计算属性，`watch`不会在初次绑定时自动执行，若需要在绑定时立即执行，可设置`immediate`为`true`。
  - 



#### computed

一个数据受其他数据的影响,随他的变化而变化,就将这个数据作为计算属性处理

场景:购物车总价

- **功能**：`计算属性用于根据其他数据派生出一个新的值`。当你有一些复杂的逻辑基于组件的状态但并不希望这些逻辑遍布模板中时，可以使用计算属性。

- 特点

  ：

  - **`缓存机制`**：计算属性具有缓存特性，当它的`依赖`（即计算属性中引用的其他数据）`没有发生变化`时，它不会重新计算，而是`直接返回缓存的值`，这提高了性能。
  - **`声明方式`**：计算属性通常定义为一个返回值的方法，此方法内包含计算逻辑，并且`必须返回`一个值。
  - **`自动追踪依赖`**：Vue能够`自动追踪`计算属性中依赖的所有`数据变化`

#### **总结差异**：

1. **目的**：计算属性专注于提供基于其他属性的派生值；而`watch`关注的是对特定数据变化做出反应并执行相关操作。
2. **执行时机**：计算属性会在依赖变化时自动、高效地计算新值；`watch`则是在数据变化后明确触发的回调。
3. **缓存策略**：计算属性有缓存机制，仅在必要时重新计算；`watch`每次触发都会执行回调函数。
4. **异步支持**：计算属性不适合异步操作，而`watch`支持异步回调。
5. **使用场景**：当需要基于多个属性简单计算得出单一值时，选择计算属性；当需要在数据变化时执行复杂逻辑或副作用操作时，选择`watch`。

## 了解webpack和vite吗

#### Webpack

**Webpack** Webpack是一个高度可配置的静态模块打包工具，常用于现代JavaScript应用程序的构建过程。它的核心功能包括：

- **模块化处理**：Webpack可以处理各种模块格式（CommonJS、AMD、ES6 Modules等），并将它们转换为合适的输出格式。
- **资源加载器**：通过Loader机制，Webpack可以处理不同类型资源（如JS、CSS、图片、字体等），将其转换和打包进最终的bundle中。
- **插件系统**：通过Plugin系统，Webpack可以执行更复杂的构建任务，比如代码压缩优化、分割代码块、热更新（Hot Module Replacement, HMR）等。
- **代码分割**：Webpack可以根据模块之间的依赖关系，智能地生成按需加载的代码片段，优化网页加载性能。
- **树形 shaking**：Webpack可以通过摇树优化去除未使用的代码，减少包体积。

#### Vite

**Vite** Vite由Vue.js作者尤雨溪创建，是一个专注于提高开发体验的新型构建工具，其主要特点包括：

- **快速冷启动**：Vite利用浏览器原生支持的ES模块（ESM），在开发环境中可以做到几乎无等待的即时预览，仅当文件发生改变时才对相关模块进行按需编译，大幅提高了开发环境下的刷新速度。
- **基于Esbuild**：Vite底层依赖于Esbuild进行快速的预构建和转译工作，Esbuild由于使用Go语言编写，具有极高的构建速度。
- **渐进式构建**：Vite在生产环境同样会进行完整的构建，但它主张在开发阶段尽量保持接近生产环境的状态，以便开发者能尽早发现问题。
- **零配置**：Vite默认配置就足够满足大部分开发需求，对于Vue.js项目尤其友好，但也支持React和其他框架。

#### 区别与比较

- **构建速度**：Vite在开发环境下构建速度显著优于Webpack，因为它避免了不必要的整体打包，而是采取增量编译的方式。
- **开发体验**：Vite提供的开发服务器无需经过打包即可直接运行源码，且HMR响应更快。
- **配置复杂度**：Webpack因其高度灵活性而拥有较高的学习曲线和配置复杂度，而Vite的默认配置简化了许多常见任务。
- **生态兼容**：Webpack作为老牌构建工具，有庞大的生态系统支持，兼容更多老项目和技术栈；Vite虽较新，但正在迅速发展，特别适合追求最新技术和高效开发流程的新项目。

## 为什么data属性是一个函数而不是一个对象



- 根实例对象`data`可以是对象也可以是函数（根实例是单例），不会产生数据污染情况

- 组件实例对象`data`必须为函数，目的是为了防止多个组件实例对象之间共用一个`data`，产生数据污染。采用函数的形式，`initData`时会将其作为工厂函数都会返回全新`data`对象

- `vue`组件可能会有很多个实例，采用函数返回一个全新`data`形式，使每个实例对象的数据不会受到其他实例对象数据的污染

- 当`data`是一个对象时，这个对象直接作为根组件的状态，并且在全局范围内只有一份该状态的拷贝。由于不存在复用根实例的情况，所以不同组件之间不会因为引用同一个`data`对象而导致数据污染。

- 而当`data`是一个函数时，Vue.js会调用这个函数来获取初始数据对象，这样每次创建新的组件实例时（对于非根实例而言），都会通过调用函数得到一个新的数据对象副本，确保各个组件实例的数据隔离

- 根实例作为整个应用的顶级组件，其`data`属性既可以是对象也可以是函数，这是因为根实例在整个应用中只有一个实例，即它是单例模式。由于根实例在整个应用程序中是独一无二的，因此不会存在多个根实例之间的数据共享问题。

- 在我们定义好一个组件的时候，`vue`最终都会通过`Vue.extend()`构成组件实例

  这里我们模仿组件构造函数，定义`data`属性，采用对象的形式

## `v-for`与`v-if`一同使用在vue2和vue3中的区别

- 在vue2中，`v-for` 的优先级比`v-if`更高。
- 在vue3中，`v-if`具有比`v-for`更高的优先级。

## 动态给vue的data添加一个新的属性时会发生什么？怎样解决？

- 如果为对象添加少量的新属性，可以直接采用`Vue.set()`
- 如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象
- `vue3`是用过`proxy`实现数据响应式的，直接动态添加新属性仍可以实现数据响应式

## Vue中组件和插件有什么区别

1. 组件 `(Component)` 是用来构成你的 `App` 的业务模块，它的目标是 `App.vue`

2. 插件 `(Plugin)` 是用来增强你的技术栈的功能模块，它的目标是 `Vue` 本身

   简单来说，插件就是指对`Vue`的功能的增强或补充

## Vue的双向数据绑定怎么实现的

Vue.js 实现双向数据绑定的核心机制主要包括两个关键部分：响应式系统（Reactivity System）和指令系统（Directives）。以下是简要概述：

1. **响应式系统**：
   - Vue使用`Object.defineProperty()`方法来监听数据对象的变化。当我们在Vue实例中定义`data`时，Vue会遍历这些数据属性并利用`defineProperty`将它们转化为getter和setter。
   - 通过getter和setter，Vue能够跟踪依赖关系（哪个组件或计算属性正在使用某个数据属性）并建立一个依赖收集系统。
   - 当数据发生变化时，Vue能通过setter触发相应的通知过程，这个过程会找到所有依赖于这个数据属性的视图组件，并迫使它们重新渲染。
2. **指令系统（v-model）**：
   - 双向绑定最常见的应用场景是表单元素与数据模型之间的同步。Vue通过`v-model`指令实现了这一点。
   - 在表单元素上使用`v-model`时，Vue会在背后监听元素值的变化（比如input的input事件），当用户输入导致值发生变动时，Vue会调用相应的setter来更新数据模型。
   - 同样地，如果数据模型的数据发生变化，响应式系统会触发视图更新，包括那些通过`v-model`绑定的表单元素，使其显示最新的数据。

总结起来，Vue通过响应式系统监听数据变化，并在数据变化时自动更新视图；同时，通过指令系统捕获用户的交互行为，并在适当的时候反向同步至数据模型，这就是Vue实现双向数据绑定的基本原理。

