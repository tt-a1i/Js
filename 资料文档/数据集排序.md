## gzip优化

```python
import json
import gzip
from flask import Response
from typing import Dict


def parse_input(data, usage: str):
    input = json.loads(data)
    if usage == 'singleEntityMetric':
        return input['unit_id'], input['metric_list'], input['dates'], input['perspective']
    elif usage == 'overallMetricStat':
        return input['metric_list'], input['dates'], input['stats'], input['perspective']
    elif usage == 'get_model_date_data':
        return input['models'], input['start_date'], input['end_date']


def parse_output(data: Dict, compress: bool = True):
    s = json.dumps(data, ensure_ascii=False)
    if compress:
        s = gzip.compress(s.encode('utf-8'))
    return Response(s, headers={
        'Content-Encoding': 'gzip',
        'Content-Type': 'application/json'  # 或其他适当的类型
    })
```

![image-20240812191410584](assets/image-20240812191410584.png)

**压缩率高达19.42%**

`gzip` 压缩算法的效率高主要有以下几个原因：

1. **字典编码**：
   - `gzip` 使用DEFLATE算法，这是一个组合式的算法，由LZ77和霍夫曼编码（Huffman Coding）组合而成。这种组合可以有效地将重复的数据片段进行压缩，从而达到高效的压缩效果。
2. **频率分析和编码优化**：
   - 在霍夫曼编码阶段，`gzip` 会根据数据的频率来构建编码表，频率越高的字符会被编码为更短的比特序列，从而减少总体的编码长度。
3. **适应性强**：
   - `gzip` 可以在不同的数据分块中自适应地调整其压缩策略，以确保不同类型的数据在压缩时都能达到较高的压缩比。
4. **冗余减少**：
   - `gzip` 可以有效地检测和去除冗余信息，例如重复的字符串和字符序列，因此可以显著减小文件的大小。

### 原理和优化点：

1. 转换数据为 JSON 字符串：
   - `s = json.dumps(data, ensure_ascii=False)` 将字典数据转换为 JSON 字符串。
2. 如果需要压缩：
   - `compress_s = gzip.compress(s.encode('utf-8'))` 将 JSON 字符串编码为 UTF-8 字节，再使用 `gzip` 压缩。
   - 设置响应头 `Content-Encoding` 为 `gzip`，并相应调整 `Content-Length`。
3. 如果不需要压缩：
   - 直接返回 JSON 字符串，调整 `Content-Length` 为未压缩的字节数。

### 关于压缩效率：

你提到 `Content-Length` 是 1048053（大约是 1,048,053 字节），而 `Size` 是 5437027（大约是 5,437,027 字节），这意味着：

压缩比大约是 19.3%。这种压缩效果通常非常显著，特别是对于结构化的文本数据（例如JSON），其中可能存在大量重复的字段名和值。

### 注意事项：

- 如果源数据已经是高度压缩的格式（如图像、视频等），`gzip` 的效果可能并不显著。
- `gzip` 增加了CPU负载，特别是对大数据量的压缩和解压缩。因此，在高性能需求的应用场景中需要权衡压缩带来的网络带宽节省与CPU消耗之间的平衡。

## 参数信息

这些参数和信息是与HTTP请求和响应有关的，各自有不同的功能和作用。以下是对这些参数的解释：

### 请求头（Request Headers）

1. **accept**:
   - 表示客户端可以处理的内容类型，具体为`application/json, text/plain, */*`，其中`*/*`表示客户端可以处理任何类型的内容。

2. **accept-encoding**:
   - 表示客户端支持的内容编码，用于告诉服务器可以用什么方式压缩响应内容。这里包括了`gzip`, `deflate`, `br`, `zstd`等。

3. **accept-language**:
   - 表示客户端期望的响应内容的语言，`zh-CN,zh;q=0.9`表示优先使用简体中文，次选是其他中文方言。

4. **authorization**:
   - 用户认证信息，`Basic bWFzaGl5YW86Z0ZnWnNhNm5jV1pmelJxdENxYVhMUw==`是一种简单的Base64编码形式的基础认证。

5. **cache-control**:
   - 控制缓存策略，`max-age=0`表示不缓存，每次都要从服务器获取最新内容。

6. **connection**:
   - 控制连接的管理，`keep-alive`表示希望保持HTTP连接以便复用。

7. **content-length**:
   - 客户端发送的内容长度，这里是67字节。

8. **content-type**:
   - 表示请求体的内容类型，这里是`application/json`。

9. **host**:
   - 请求的主机名，加上端口号，这里是`127.0.0.1:5000`。

10. **if-none-match**:
    - 用于条件请求，`a97303d7028a543661c5d653d7dc345f`是一个ETag，表示如果内容没有变化则返回304 Not Modified。

11. **origin**:
    - 发起此请求的源站，`http://localhost:8080`。

12. **referer**:
    - 表示从哪个URL来的请求，这里是`http://localhost:8080/`。

13. **sec-ch-ua**:
    - 表示用户代理的品牌和版本，这里是`"Not)A;Brand";v="99", "Google Chrome";v="127", "Chromium";v="127"`。

14. **sec-ch-ua-mobile**:
    - 表示是否为移动设备，这里是`?0`，表示不是移动设备。

15. **sec-ch-ua-platform**:
    - 表示用户代理的操作平台，这里是`"Windows"`。

16. **sec-fetch-dest**:
    - 表示请求的目的，`empty`表示并非文件请求。

17. **sec-fetch-mode**:
    - 表示请求的模式，`cors`表示跨域请求。

18. **sec-fetch-site**:
    - 表示请求的发起源，`cross-site`表示从不同源站发起的请求。

19. **user-agent**:
    - 表示客户端的一般信息，这里是`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36`。

### 响应头（Response Headers）

1. **access-control-allow-headers**:
   - 允许请求头中包含的字段，这里是`Content-Type, Authorization, If-None-Match`。

2. **access-control-allow-methods**:
   - 允许的HTTP方法，这里是`PUT, GET, HEAD, POST, DELETE, OPTIONS`。

3. **access-control-allow-origin**:
   - 允许的跨源请求的来源，这里是`http://localhost:8080`。

4. **access-control-max-age**:
   - 跨源请求的缓存时间，单位是秒，这里是3600秒（1小时）。

5. **content-length**:
   - 响应的内容长度，5437027字节。

6. **content-type**:
   - 响应的内容类型，`text/html; charset=utf-8`。

7. **date**:
   - 服务器的响应日期和时间，`Mon, 12 Aug 2024 09:16:18 GMT`。

8. **server**:
   - 服务器信息，`Werkzeug/0.16.1 Python/3.8.10`。

### 其他信息

- **Request URL**: 请求的具体URL。
- **Request Method**: 请求使用的方法，这里是POST。
- **Status Code**: 服务器返回的状态码，这里是200 OK，表示请求成功。
- **Remote Address**: 服务器的IP地址和端口，这里是 `127.0.0.1:5000`。
- **Referrer Policy**: 网页的引用策略，`strict-origin-when-cross-origin`。

## 模型列表接口

### 304缓存设置

```python
@app.route('/common/model/infos', methods=['GET', 'OPTIONS'])
@handle_options_request
@require_auth
def get_model_infos():
    if request.method == 'OPTIONS':
        return

    logger.info('Getting model infos')

    url = 'http://rd-gateway.patsnap.info/common/model/infos'
    headers = {
        'Accept': 'application/json',
        'Authorization': request.headers.get('Authorization')
    }

    try:
        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            data = response.json()

            # 使用更稳定的方法生成 ETag
            etag = hashlib.md5(str(data).encode()).hexdigest()

            # 检查 If-None-Match
            if request.headers.get('If-None-Match') == etag:
                resp = make_response('', 304)
                resp.headers['ETag'] = etag
                return add_cors_headers(resp)

            resp = make_response(data)
            resp.headers['ETag'] = etag
            resp.headers['Access-Control-Expose-Headers'] = 'ETag'
            resp.headers['Cache-Control'] = 'public, max-age=30000'
            resp.headers['Expires'] = (datetime.utcnow() + timedelta(seconds=30000)).strftime(
                '%a, %d %b %Y %H:%M:%S GMT')

            return add_cors_headers(resp)
        else:
            logger.error(f"Error fetching model infos: {response.status_code}")
            return add_cors_headers(make_response({'error': 'Failed to fetch model infos'}, response.status_code))

    except requests.RequestException as e:
        logger.error(f"Request failed: {str(e)}")
        return add_cors_headers(make_response({'error': 'Request failed'}, 500))
```

### `@app.route('/common/model/infos', methods=['GET', 'OPTIONS'])` 实现304和接口功能的详细讲解

#### 1. 引入装饰器

```python
@app.route('/common/model/infos', methods=['GET', 'OPTIONS'])
@handle_options_request
@require_auth
```

这里声明了一个新的路由`/common/model/infos`，支持GET和OPTIONS两种HTTP方法。装饰器`@handle_options_request`和`@require_auth`用于处理OPTIONS请求和进行身份验证。

#### 2. 请求处理流程

```python
def get_model_infos():
    if request.method == 'OPTIONS':
        return
```

- 在函数一开始就检查请求方法，如果是`OPTIONS`，则直接返回。`OPTIONS`请求一般用于CORS预检请求。

```python
    logger.info('Getting model infos')

    url = 'http://rd-gateway.patsnap.info/common/model/infos'
    headers = {
        'Accept': 'application/json',
        'Authorization': request.headers.get('Authorization')
    }
```

- 记录日志以跟踪请求。
- 定义将要向其发送请求的目标URL，以及请求头部信息，其中包括接受的数据类型和Authorization头。

#### 3. 向目标服务发送请求

```python
    try:
        response = requests.get(url, headers=headers)
```

- 使用`requests`库发送GET请求。

#### 4. 处理响应

```python
        if response.status_code == 200:
            data = response.json()

            # 使用更稳定的方法生成 ETag
            etag = hashlib.md5(str(data).encode()).hexdigest()
```

- 如果目标服务返回200 OK，说明请求成功。
- 将响应内容解析为JSON。
- 使用MD5算法生成ETag，ETag可以作为此请求响应的唯一标识符。

```python
            # 检查 If-None-Match
            if request.headers.get('If-None-Match') == etag:
                resp = make_response('', 304)
                resp.headers['ETag'] = etag
                return add_cors_headers(resp)
```

- 检查请求头中的`If-None-Match`字段，它包含的值是上次客户端所缓存的ETag。
- 如果此ETag与新计算的ETag相同，说明响应内容没有变化，直接返回304状态码，不携带任何响应体内容。
  
```python
            resp = make_response(data)
            resp.headers['ETag'] = etag
            resp.headers['Access-Control-Expose-Headers'] = 'ETag'
            resp.headers['Cache-Control'] = 'public, max-age=30000'
            resp.headers['Expires'] = (datetime.utcnow() + timedelta(seconds=30000)).strftime(
                '%a, %d %b %Y %H:%M:%S GMT')

            return add_cors_headers(resp)
```

- 如果ETag不匹配或者客户端未携带ETag，返回实际数据。
- 设置ETag响应头，并设置响应缓存策略和过期时间。

#### 5. 处理错误和异常

```python
        else:
            logger.error(f"Error fetching model infos: {response.status_code}")
            return add_cors_headers(make_response({'error': 'Failed to fetch model infos'}, response.status_code))

    except requests.RequestException as e:
        logger.error(f"Request failed: {str(e)}")
        return add_cors_headers(make_response({'error': 'Request failed'}, 500))
```

- 如果目标服务返回非200状态码，会记录错误日志并返回一个包含错误信息的响应。
- 捕获请求中的异常，并返回500状态码和相应错误信息。

### 实现304优化的过程解析

1. **检测客户端缓存情况**：
   - 通过请求头中的`If-None-Match`字段对比ETag。
   - 如果客户端缓存未失效，直接返回304状态码，无需再次传输相同的数据。

2. **减少带宽使用和服务器负载**：
   - 直接返回304状态码大幅减少带宽消耗和服务器处理时间。
   - 减少了客户端对网络资源的需求，有助于提升整体系统性能。

### CORS和OPTIONS预检请求处理

- `handle_options_request`装饰器处理OPTIONS请求，为跨域请求提供支持。
- `add_cors_headers`函数在所有响应中添加必要的CORS头部，确保跨域请求可以正常工作。

### 总结

以上代码实现了一个高效的接口，通过ETag和304状态码减少了重复的数据传输，同时确保了跨域请求的安全和兼容性。通过日志记录和错误处理机制，提升了代码的可维护性和可调试性。

## 304

为了确保客户端请求和服务端实现 304 Not Modified 逻辑的功能相匹配，我们需要确保几个关键点。以下是针对提供的 Axios 请求的几个建议：

1. **ETag 的处理**：客户端应接受返回的 ETag，并在后续相同请求中通过 `If-None-Match` 头字段发送。在成功请求时，将返回的 ETag 存储并在下次相同请求时使用。

2. **数据和 URI 的一致性**：确保 `models`、`start_date` 和 `end_date` 数据格式与服务端一致。

假设你已经在服务端实现了上述 ETag 和 304 Not Modified 逻辑，客户端的代码修改如下：

```javascript
axios({
  method: 'POST',
  url: 'http://127.0.0.1:5000/compute/metric_generator/get_model_date_data',
  headers: {
    Authorization: 'Basic bWFzaGl5YW86Z0ZnWnNhNm5jV1pmelJxdENxYVhMUw==',
    'If-None-Match': this.etag // 发送上次响应中保存的 ETag
  },
  data: {
    models: [this.dataset_value],
    start_date: this.formattedDates[0],
    end_date: this.formattedDates[1]
  }
})
.then(response => {
  if (response.status === 200) {
    // 存储新的 ETag 以备下次使用
    this.etag = response.headers.etag;
    // 处理正常响应数据
    console.log('Data:', response.data);
  } else if (response.status === 304) {
    // 处理 304 响应，无需再次获取数据
    console.log('Data not modified, using cached data');
  }
})
.catch(error => {
  // 处理错误
  console.error('Request failed:', error);
});
```

### 关键要点：

1. **接收并存储 ETag**：在成功的响应中，使用 `response.headers.etag` 来获取并存储 ETag。这是确保下次请求发出时可以使用相同 ETag 的关键步骤。

2. **处理 304 响应**：处理 304 响应时，表明数据未修改，可以继续使用缓存数据，而不需要进行额外的数据处理。

3. **确保数据格式正确性**：确保 `models`、`start_date` 和 `end_date` 的格式与服务端预期的格式一致。根据你的应用，这可能需要对日期进行格式化或对 `models` 进行验证。

通过这样的设置，客户端可以实现与服务端协作，减少数据传输量，同时高效响应。

## 为什么axios会把304状态码作为错误抛出，怎么配置

在 Axios 中，如果服务器返回的 HTTP 状态码不是成功状态（即 2xx 范围内的状态码），则会将其视为错误并在 `catch` 块中处理。由于 HTTP 304 状态码不在 2xx 范围内，Axios 默认会将其视为错误。

为了正确处理 HTTP 304 状态码，你可以通过几个选项来定制 Axios 的行为：

### 方法 1: 使用 Axios 配置 `validateStatus`

你可以通过配置 Axios 的 `validateStatus` 来定义哪些 HTTP 状态码应该被视为有效的响应，而不是错误。这样，你可以让 Axios 将 304 状态码视为成功的响应。

```javascript
axios({
  method: 'POST',
  url: 'http://127.0.0.1:5000/compute/metric_generator/get_model_date_data',
  headers: {
    Authorization: 'Basic bWFzaGl5YW86Z0ZnWnNhNm5jV1pmelJxdENxYVhMUw==',
    'If-None-Match': this.etag
  },
  data: {
    models: [this.dataset_value],
    start_date: this.formattedDates[0],
    end_date: this.formattedDates[1]
  },
  validateStatus: function (status) {
    return status >= 200 && status < 300 || status === 304; // 允许 304 状态被认为是成功
  }
})
.then(response => {
  if (response.status === 200) {
    this.etag = response.headers.etag;
    console.log('Data:', response.data);
  } else if (response.status === 304) {
    console.log('Data not modified, using cached data');
  }
})
.catch(error => {
  console.error('Request failed:', error);
});
```

### 关键点：

- **`validateStatus` 函数**：这个函数用于定义响应成功的条件。默认情况下，它只认 2xx 状态码为成功；通过修改它，可以指定 304 也是成功的状态码。
  
- **处理逻辑**：调整 `then` 块中的逻辑，以分别处理 200 和 304 状态码。

通过这种方式，你可以更灵活地处理 HTTP 响应状态码，尤其在使用诸如缓存控制这样的特性时。